<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="前端匍匐前进">
    <meta name="keyword"  content="前端">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        前端模块化（二） - ......
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> less code more art. </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>......</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前端的四种模块化方案-webpack-require-js-seajs-browserify）"><span class="toc-text">前端的四种模块化方案(webpack/require.js/seajs/browserify）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-CommonJS"><span class="toc-text">1.CommonJS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AMD"><span class="toc-text">2.AMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CMD"><span class="toc-text">3.CMD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一-模块化"><span class="toc-text">一.模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-函数封装"><span class="toc-text">1. 函数封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-对象"><span class="toc-text">2. 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-立即执行函数"><span class="toc-text">3. 立即执行函数</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> less code more art. </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        前端模块化（二）
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-08-27 14:11:00</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#模块化" title="模块化">模块化</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content ">
        <p>综述：<br>    Commonjs,AMD,CMD,ES6的模块化总结<br><a id="more"></a></p>
<h2 id="前端的四种模块化方案-webpack-require-js-seajs-browserify）"><a href="#前端的四种模块化方案-webpack-require-js-seajs-browserify）" class="headerlink" title="前端的四种模块化方案(webpack/require.js/seajs/browserify）"></a>前端的四种模块化方案(webpack/require.js/seajs/browserify）</h2><p>JS不具备原生的模块化技能，因此需要采用第三方开发的模块依赖处理库来实现模块化：CommonJS、AMD、CMD、ES6</p>
<p>这四种方案的实现对比：</p>
<blockquote>
<p>CommonJS:  exports + require </p>
</blockquote>
<blockquote>
<p>AMD: define + require </p>
</blockquote>
<blockquote>
<p>CMD：define+require+exports/exports </p>
</blockquote>
<p>Ps. CommonJS 和AMD上下的require也不是一样的,cmd与amd的文字一样内容差了好多参数） </p>
<blockquote>
<p>ES6: export + import</p>
</blockquote>
<p>由于ES6本身是原生语言支持实现的模块化，但是现代浏览器大多都还未支持，因此必须使用相应的transpiler工具转换成ES5的AMD,CMD模块，再借助于systemjs/requirejs等模块加载工具才能使用。其中ES6的transpiler（代码转换器）一般是用babel，他的作用是将ES6</p>
<h3 id="1-CommonJS"><a href="#1-CommonJS" class="headerlink" title="1.CommonJS"></a>1.CommonJS</h3><p>适合服务器端</p>
<p>commonJS由nodeJS发扬光大，这标志着js模块化正式登场。</p>
<p>1.1定义模块<br>根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。</p>
<p>2.2 模块输出<br>模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。<strong> 或者是exports，这些全都是因为commonjs规范一和规范二 </strong></p>
<p>2.3加载模块<br>加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象或者是exports。</p>
<blockquote>
<p>注意<br>(1). exports 与module.exports 的区别：exports 是对 module.exports 的引用，不能直接给exports 赋值，直接赋值无效，结果是一个空对象,module.exports 可以直接赋值：如示例</p>
</blockquote>
<pre><code>module.exports = 123; //123

module.exports = function () { //[Function]
    console.log(123)
}

 exports = 123; //{}
 exports = function(){ //{}
    console.log(123)
}
</code></pre><blockquote>
<p>（2)一个文件不能写多个module.exports如果写多个，对外暴露的接口是最后一个module.exports<br>（3）模块如果没有指定使用module.exports 或者exports 对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象{}</p>
</blockquote>
<p>仔细看上面的代码，您会注意到 require 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。<br>然而， 这在浏览器端问题多多。<br>浏览器端，加载 JavaScript 最佳、最容易的方式是在 document中插入<code>&lt;script&gt;</code>标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载。</p>
<p>解决思路是，用一套标准模板来封装模块定义：</p>
<h3 id="2-AMD"><a href="#2-AMD" class="headerlink" title="2.AMD"></a>2.AMD</h3><p>Asynchronous Module Definition，称为异步模块。<br>由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。<br>requireJS主要解决两个问题：<br>1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。<br>2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。</p>
<blockquote>
<p>语法： requireJS定义了一个函数define，它是全局变量，用来定义模块。</p>
</blockquote>
<blockquote>
<p>define(id,dependencies,factory) </p>
</blockquote>
<blockquote>
<p>id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） </p>
</blockquote>
<blockquote>
<p>依赖dependencies是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。有默认值，长度是三个 </p>
</blockquote>
<blockquote>
<p>factory工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。</p>
</blockquote>
<p>在页面上使用require函数加载模块；</p>
<p>require([dependencies], function(){}); 与上面的commonjs的require差别很大，上面是找文件这里的呢，是id+回调</p>
<p>require()函数接受两个参数：</p>
<p>——第一个参数是一个数组，表示所依赖的模块；</p>
<p>——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</p>
<p>AMD推崇的是依赖前置，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块</p>
<h3 id="3-CMD"><a href="#3-CMD" class="headerlink" title="3.CMD"></a>3.CMD</h3><p>即common module definition，就像AMD有个requireJS,CMD有个浏览器实现的sea.js，sj要解决的问题和rj一样，只不过在模块定义方式和模块加载时机上有所不同。</p>
<blockquote>
<p>1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 </p>
<p>2、CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>
</blockquote>
<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>
<p>AMD和CMD最大的区别：依赖模块执行时机不同</p>
<p>同样都是异步加载模块，AMD在加载模块完成后就会执行该模块<strong>（这里执行的被加载的模块而不是用户写的主逻辑模块），所有模块都加载执行完后会进入require的回调函数</strong>，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行<br>上面加载的模块需要：加载+执行<br>下面加载的模块：加载<br>CMD加载完某个依赖模块后并不执行<strong>，只是下载而已</strong>，在所有依赖模块加载完成后进入主逻辑，<strong>遇到require语句的时候才执行对应的模块</strong>，这样模块的执行顺序和书写顺序是完全一致的</p>
<h2 id="一-模块化"><a href="#一-模块化" class="headerlink" title="一.模块化"></a>一.模块化</h2><p>模块化开发，一个实现特定功能的文件就是一个模块，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。<br>模块化开发的4点好处：
　　</p>
<ul>
<li>1 避免变量污染，命名冲突 　　</li>
<li>2  提高代码复用率 　　</li>
<li>3 提高维护性 　　</li>
<li>4 依赖关系的管理</li>
</ul>
<p>前端模块化规范从原始野蛮阶段现在慢慢进入“文艺复兴”时代，实现的过程如下：</p>
<h3 id="1-函数封装"><a href="#1-函数封装" class="headerlink" title="1. 函数封装"></a>1. 函数封装</h3><p>我们在讲到函数逻辑的时候提到过，函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了</p>
<blockquote>
<p> 详情见模块化（一）</p>
</blockquote>
<p>缺点：污染了全局变量，并且不能保证和其他模块起冲突，模块成员看起来似乎没啥关系</p>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2. 对象"></a>2. 对象</h3><p>为了解决这个问题，有了新方法，将所有模块成员封装在一个对象中</p>
<blockquote>
<p> 详情见模块化（一）</p>
</blockquote>
<p>这样 两个函数就被包在这个对象中， 嘿嘿 看起来没毛病是吗 继续往下：<br>当我们要使用的时候，就是调用这个对象的属性<br>module.m1()<br>诶嘿 那么问题来了 这样写法会暴露全部的成员，内部状态可以被外部改变，比如外部代码可直接改变计数器的值</p>
<pre><code>//坏人的操作

module._count = 10;
</code></pre><h3 id="3-立即执行函数"><a href="#3-立即执行函数" class="headerlink" title="3. 立即执行函数"></a>3. 立即执行函数</h3><p>这样就可以达到不暴露私有成员的目的<br>外部无法访问内部私有变量</p>
<blockquote>
<p> 详情见模块化（一）</p>
</blockquote>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
