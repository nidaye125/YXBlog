<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="前端匍匐前进">
    <meta name="keyword"  content="前端">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        前端模块化-2CommonJS - ......
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> less code more art. </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>......</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <!-- <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li> -->
            <!-- <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>目录</span>
                </a>
            </li> -->
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <!-- <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li> -->
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-摘要"><span class="toc-text">1.摘要</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-总结"><span class="toc-text">1.1 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-前端的四种模块化方案"><span class="toc-text">1.2  前端的四种模块化方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-CommonJS"><span class="toc-text">2. CommonJS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-简介"><span class="toc-text">2.1 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-格式"><span class="toc-text">2.2 格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-模块解析"><span class="toc-text">2.3 模块解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-commonjs总结"><span class="toc-text">2.4 commonjs总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-commonjs缺点"><span class="toc-text">2.5 commonjs缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-module对象"><span class="toc-text">3 module对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-module-exports属性"><span class="toc-text">3.1 module.exports属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-exports变量"><span class="toc-text">3.2 exports变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-require命令"><span class="toc-text">4 require命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-基本用法"><span class="toc-text">4.1 基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-加载规则"><span class="toc-text">4.2 加载规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-目录的加载规则"><span class="toc-text">4.3 目录的加载规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文献"><span class="toc-text">参考文献</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> less code more art. </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        前端模块化-2CommonJS
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-08-27 14:08:43</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#javascript" title="javascript">javascript</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <p>上一篇讲了前端模块化中的旧方法，下面就讲我们常见但是易混的三个前端模块化。这里先讲commonjs</p>
<a id="more"></a>
<h2 id="1-摘要"><a href="#1-摘要" class="headerlink" title="1.摘要"></a>1.摘要</h2><h3 id="1-1-总结"><a href="#1-1-总结" class="headerlink" title="1.1 总结"></a>1.1 总结</h3><p>前端模块规范有三种：CommonJs,AMD和CMD。</p>
<ul>
<li>CommonJs用在服务器端，AMD和CMD用在浏览器环境</li>
<li>AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。<strong>AMD提前执行（异步加载：依赖先执行）+延迟执行）</strong></li>
<li>CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 <strong>CMD:延迟执行（运行到需加载，根据顺序执行）</strong></li>
</ul>
<h3 id="1-2-前端的四种模块化方案"><a href="#1-2-前端的四种模块化方案" class="headerlink" title="1.2  前端的四种模块化方案"></a>1.2  前端的四种模块化方案</h3><p>(webpack/require.js/seajs/browserify）</p>
<p>JS不具备原生的模块化技能，因此需要采用第三方开发的模块依赖处理库来实现模块化：CommonJS、AMD、CMD、ES6</p>
<p>这四种方案的实现对比：</p>
<blockquote>
<p>CommonJS:  exports（或者module.exports）+ require </p>
<p>AMD: define + require </p>
<p>CMD：define+require+exports/exports </p>
<p>ES6: export + import</p>
</blockquote>
<p><strong>++Ps. CommonJS 和AMD上下的require也不是一样的,cmd与amd的文字一样内容差了好多参数)++</strong></p>
<p>由于ES6本身是原生语言支持实现的模块化，但是现代浏览器大多都还未支持，因此必须使用相应的transpiler工具转换成ES5的AMD,CMD模块，再借助于systemjs/requirejs等模块加载工具才能使用。其中ES6的transpiler（代码转换器）一般是用babel，他的作用是将ES6</p>
<h2 id="2-CommonJS"><a href="#2-CommonJS" class="headerlink" title="2. CommonJS"></a>2. CommonJS</h2><h3 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1 简介"></a>2.1 简介</h3><p>Node 应用由模块组成，采用 CommonJS 模块规范。</p>
<p>每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。</p>
<p>所以<strong>虽然JavaScript在web端发展这么多年，第一个流行的模块化规范却由服务器端的JavaScript应用带来，</strong> CommonJS规范是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p>
<h3 id="2-2-格式"><a href="#2-2-格式" class="headerlink" title="2.2 格式"></a>2.2 格式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。</p>
<p>如果想在多个文件分享变量，必须定义为global对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">global.warning = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的<code>warning</code>变量，可以被所有文件读取。当然，这样写法是不推荐的。</p>
<p><code>CommonJS</code>规范规定，每个模块内部，<code>module</code>变量代表当前模块。这个变量是一个对象，它的<code>exports</code>属性（即<code>module.exports</code>）是对外的接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</p>
<p>看个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块定义 myModel.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Byron'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printFullName</span>(<span class="params">firstName</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(firstName + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    printName: printName,</span><br><span class="line">    printFullName: printFullName</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="comment">// module.exports.printName = printName;</span></span><br><span class="line"><span class="comment">// module.exports.printFullName = printFullName;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> nameModule = <span class="built_in">require</span>(<span class="string">'./myModel.js'</span>);</span><br><span class="line"></span><br><span class="line">nameModule.printName();</span><br></pre></td></tr></table></figure>
<h3 id="2-3-模块解析"><a href="#2-3-模块解析" class="headerlink" title="2.3 模块解析"></a>2.3 模块解析</h3><p>根据CommonJS规范，</p>
<ol>
<li><p>一个单独的文件就是一个模块。<br><strong>每一个模块都是一个单独的作用域</strong>，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性</p>
</li>
<li><p>模块输出：<br><strong>模块只有一个出口，module.exports对象</strong>，我们需要把模块希望输出的内容放入该对象</p>
</li>
<li><p>加载模块：<br>加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象</p>
</li>
</ol>
<h3 id="2-4-commonjs总结"><a href="#2-4-commonjs总结" class="headerlink" title="2.4 commonjs总结"></a>2.4 commonjs总结</h3><blockquote>
<p>总结如下：</p>
<p>1.所有代码都运行在模块作用域，不会污染全局作用域。</p>
<p>2.模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</p>
<p>3.模块加载的顺序，按照其在代码中出现的顺序。</p>
</blockquote>
<h3 id="2-5-commonjs缺点"><a href="#2-5-commonjs缺点" class="headerlink" title="2.5 commonjs缺点"></a>2.5 commonjs缺点</h3><p>仔细看上面的代码，<strong>++会发现require是同步的++</strong>。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。</p>
<p>这在服务器端实现很简单也很自然，然而， 想在浏览器端实现问题却很多。</p>
<p>因为浏览器端，加载JavaScript最佳、最容易的方式是在document中插入script 标签。<strong>++但脚本标签script天生异步，传统CommonJS模块在浏览器环境中无法正常加载。++</strong></p>
<p>解决思路之一是，开发一个服务器端组件，对模块代码作静态分析，将模块与它的依赖列表一起返回给浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</p>
<p>另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧：</p>
<blockquote>
<p>总结CommonJs适合服务器端，比如node，不适合浏览器</p>
</blockquote>
<h2 id="3-module对象"><a href="#3-module对象" class="headerlink" title="3 module对象"></a>3 module对象</h2><p>这部分是不是属于node的知识点了。</p>
<p>Node内部提供一个<code>Module</code>构建函数。所有模块都是<code>Module</code>的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Module</span>(<span class="params">id, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.id = id;</span><br><span class="line">  <span class="keyword">this</span>.exports = &#123;&#125;;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>每个模块内部，都有一个<code>module</code>对象，代表当前模块。它有以下属性。</p>
<blockquote>
<p>module.id 模块的识别符，通常是带有绝对路径的模块文件名。</p>
<p>module.filename 模块的文件名，带有绝对路径。</p>
<p>module.loaded 返回一个布尔值，表示模块是否已经完成加载。</p>
<p>module.parent 返回一个对象，表示调用该模块的模块。</p>
<p>module.children 返回一个数组，表示该模块要用到的其他模块。</p>
<p>module.exports 表示模块对外输出的值。</p>
</blockquote>
<p>下面是一个示例文件，最后一行输出module变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> jquery = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">exports.$ = jquery;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure>
<p>执行这个文件，命令行会输出如下信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">id</span>: <span class="string">'.'</span>,</span><br><span class="line">  exports: &#123; <span class="string">'$'</span>: [<span class="built_in">Function</span>] &#125;,</span><br><span class="line">  parent: <span class="literal">null</span>,</span><br><span class="line">  filename: <span class="string">'/path/to/example.js'</span>,</span><br><span class="line">  loaded: <span class="literal">false</span>,</span><br><span class="line">  children:</span><br><span class="line">   [ &#123; <span class="attr">id</span>: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       exports: [<span class="built_in">Function</span>],</span><br><span class="line">       parent: [Circular],</span><br><span class="line">       filename: <span class="string">'/path/to/node_modules/jquery/dist/jquery.js'</span>,</span><br><span class="line">       loaded: <span class="literal">true</span>,</span><br><span class="line">       children: [],</span><br><span class="line">       paths: [<span class="built_in">Object</span>] &#125; ],</span><br><span class="line">  paths:</span><br><span class="line">   [ <span class="string">'/home/user/deleted/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/user/node_modules'</span>,</span><br><span class="line">     <span class="string">'/home/node_modules'</span>,</span><br><span class="line">     <span class="string">'/node_modules'</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果在命令行下调用某个模块，比如<code>node something.js</code>，那么<code>module.parent</code>就是<code>null</code>。如果是在脚本之中调用，比如<code>require(&#39;./something.js&#39;)</code>，那么<code>module.parent</code>就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">module</span>.parent) &#123;</span><br><span class="line">    <span class="comment">// ran with `node something.js`</span></span><br><span class="line">    app.listen(<span class="number">8088</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'app listening on port 8088'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// used with `require('/.something.js')`</span></span><br><span class="line">    <span class="built_in">module</span>.exports = app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-module-exports属性"><a href="#3-1-module-exports属性" class="headerlink" title="3.1 module.exports属性"></a>3.1 module.exports属性</h3><p><code>module.exports</code>属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取<code>module.exports</code>变量。</p>
<h3 id="3-2-exports变量"><a href="#3-2-exports变量" class="headerlink" title="3.2 exports变量"></a>3.2 exports变量</h3><p>为了方便，<code>Node</code>为每个模块提供一个<code>exports</code>变量，指向<code>module.exports</code>。这等同在每个模块头部，有一行这样的命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br></pre></td></tr></table></figure>
<p>造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * r * r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">exports.circumference = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * r;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，不能直接将<code>exports</code>变量指向一个值，<strong>因为这样等于切断了<code>exports</code>与<code>module.exports</code>的联系。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exports = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;<span class="built_in">console</span>.log(x)&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">exports.hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="string">'Hello world'</span>;</span><br></pre></td></tr></table></figure>
<p>第一句 ：上面这样的写法是无效的，因为<code>exports</code>不再指向<code>module.exports</code>了。<br>第二句 hello函数是无法对外输出的，因为<code>module.exports</code>被重新赋值了。</p>
<p><strong>这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用<code>exports</code>输出，只能使用<code>module.exports</code>输出。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>)</span>&#123; <span class="built_in">console</span>.log(x);&#125;;</span><br></pre></td></tr></table></figure>
<p>如果你觉得，<code>exports</code>与<code>module.exports</code>之间的区别很难分清，一个简单的处理方法，就是放弃使用<code>exports</code>，只使用<code>module.exports</code>。</p>
<h2 id="4-require命令"><a href="#4-require命令" class="headerlink" title="4 require命令"></a>4 require命令</h2><h3 id="4-1-基本用法"><a href="#4-1-基本用法" class="headerlink" title="4.1 基本用法"></a>4.1 基本用法</h3><p><code>Node</code>使用<code>CommonJS</code>模块规范，内置的<code>require</code>命令用于加载模块文件。</p>
<p><code>require</code>命令的基本功能是，读入并执行一个<code>JavaScript</code>文件，然后返回该模块的<code>exports</code>对象。如果没有发现指定模块，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="keyword">var</span> invisible = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"invisible"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.message = <span class="string">"hi"</span>;</span><br><span class="line"></span><br><span class="line">exports.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行下面的命令，可以输出exports对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="built_in">require</span>(<span class="string">'./example.js'</span>);</span><br><span class="line">example</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   message: "hi",</span></span><br><span class="line"><span class="comment">//   say: [Function]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果模块输出的是一个函数，那就不能定义在<code>exports</code>对象上面，而要定义在<code>module.exports</code>变量上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./example2.js'</span>)()</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>require命令</code>调用自身，等于是执行<code>module.exports</code>，因此会输出 <code>hello world</code>。</p>
<h3 id="4-2-加载规则"><a href="#4-2-加载规则" class="headerlink" title="4.2 加载规则"></a>4.2 加载规则</h3><p><code>require</code>命令用于加载文件，后缀名默认为<code>.js</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="comment">//  等同于</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">'foo.js'</span>);</span><br></pre></td></tr></table></figure>
<p>根据参数的不同格式，require命令去不同路径寻找模块文件。</p>
<p>-（1）如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。</p>
<p>-（2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。</p>
<p>-（3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。<br><strong>反正去node_module里面去找</strong><br>举例来说，脚本/home/user/projects/foo.js执行了require(‘bar.js’)命令，Node会依次搜索以下文件。</p>
<blockquote>
<p>/usr/local/lib/node/bar.js</p>
<p>/home/user/projects/node_modules/bar.js</p>
<p>/home/user/node_modules/bar.js</p>
<p>/home/node_modules/bar.js</p>
<p>/node_modules/bar.js</p>
</blockquote>
<p>这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。</p>
<p>（4）如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(‘example-module/path/to/file’)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。</p>
<p>（5）如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。</p>
<p>（6）如果想得到require命令加载的确切文件名，使用require.resolve()方法。</p>
<h3 id="4-3-目录的加载规则"><a href="#4-3-目录的加载规则" class="headerlink" title="4.3 目录的加载规则"></a>4.3 目录的加载规则</h3><p>通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让<code>require</code>方法可以通过这个入口文件，加载整个目录。</p>
<p>在目录中放置一个<code>package.json</code>文件，并且将入口文件写入<code>main</code>字段。</p>
<p>发包时候已经使用到了</p>
<p><code>require</code>发现 参数 字符串指向一个目录以后，会自动查看该目录的<code>package.json</code>文件，然后加载<code>main字</code>段指定的入口文件。如果<code>package.json</code>文件没有<code>main</code>字段，或者根本就没有<code>package.json</code>文件，则会加载该目录下的<code>index.js文件</code>或<code>index.node文件</code>。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">阮一峰的nodejs-commjs规范</a></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
