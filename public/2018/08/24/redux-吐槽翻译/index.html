<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="前端匍匐前进">
    <meta name="keyword"  content="前端">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        redux - ......
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> less code more art. </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>......</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <!-- <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li> -->
            <!-- <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>目录</span>
                </a>
            </li> -->
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <!-- <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li> -->
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-前言"><span class="toc-text">1.前言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-mirror"><span class="toc-text">1.1 mirror</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-redux"><span class="toc-text">1.2 redux</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-redux"><span class="toc-text">2 redux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Actions"><span class="toc-text">2.1 Actions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-Reducing-Boilerplate"><span class="toc-text">2.1.1 Reducing Boilerplate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-Actions-意义"><span class="toc-text">2.1.2 Actions 意义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-Actions-格式"><span class="toc-text">2.1.3 Actions 格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-Actions-in-Diwork"><span class="toc-text">2.1.4  Actions in Diwork</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Action-Creators"><span class="toc-text">2.3 Action Creators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Generating-Action-Creators"><span class="toc-text">2.3 Generating Action Creators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Async-Action-Creators"><span class="toc-text">2.4 Async Action Creators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-middleware"><span class="toc-text">2.4.1 middleware</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Reducers"><span class="toc-text">2.5 Reducers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-Generating-Reducers"><span class="toc-text">2.6 Generating Reducers</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-diwork项目中的redux"><span class="toc-text">4 diwork项目中的redux</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>
        <div class="index-about-mobile">
            <i> less code more art. </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        redux
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2018-08-24 10:00:30</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#redux" title="redux">redux</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <p>有一篇redux的吐槽写的甚好，翻译一下。<br>通过这篇吐槽，反而更能理解redux。<br><a id="more"></a></p>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><h3 id="1-1-mirror"><a href="#1-1-mirror" class="headerlink" title="1.1 mirror"></a>1.1 mirror</h3><p>A simple and powerful React framework with minimal API and zero boilerplate. (Inspired by dva and jumpstate)</p>
<p>mirror是一款简洁、高效、易上手的 React 框架，有最少的api和0模板。（受dva 和 jumpstate 启发）</p>
<h3 id="1-2-redux"><a href="#1-2-redux" class="headerlink" title="1.2 redux"></a>1.2 redux</h3><blockquote>
<p>Painless React and Redux.<br>Why?</p>
</blockquote>
<p>We love React and Redux.<br>A typical React/Redux app looks like the following:</p>
<p>一个<strong>典型的</strong> React/Redux 应用看起来像下面这样：</p>
<ul>
<li><p>An actions/ directory to manually create all action types (or action creators)</p>
<blockquote>
<p> 一个 actions/ 目录用来手动创建所有的 action type（或者 action creator）</p>
</blockquote>
</li>
<li><p>A reducers/ directory and tons of switch clause to capture all action types</p>
<blockquote>
<p> 一个 reducers/ 目录和超级多的 switch语句 来捕获所有的 action type</p>
</blockquote>
</li>
<li><p>Apply middlewares to handle async actions</p>
<blockquote>
<p> 必须要依赖 middleware 才能处理 异步 action；</p>
</blockquote>
</li>
<li><p>Explicitly invoke dispatch method to dispatch all actions</p>
<blockquote>
<p>   显示调用 dispatch 方法来 dispatch 所有的 action；</p>
</blockquote>
</li>
<li><p>Manually create history to router and/or sync with store</p>
<blockquote>
<p> 手动创建 history 对象关联路由组件，可能还需要与 store 同步；</p>
</blockquote>
</li>
<li><p>Invoke methods in history or dispatch actions to programmatically changing routes</p>
<blockquote>
<p>调用 history 上的方法或者 dispatch action 来手动更新路由；</p>
</blockquote>
</li>
</ul>
<p><strong>The problem?  <a href="https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md" target="_blank" rel="noopener">Too much boilerplates</a> and a little bit tedious.</strong><br><strong>存在的问题？太多的  <a href="https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md" target="_blank" rel="noopener">样板文件</a>以及繁琐甚至重复的劳动</strong></p>
<p>In fact, most part of the above steps could be simplified. Like, create actions and reducers in a single method, or dispatch both sync and async actions by simply invoking a function without extra middleware, or define routes without caring about history, etc.</p>
<p>实际上，上述大部分操作都是可以简化的。比如，在单个 API 中创建所有的 action 和 reducer；比如，简单地调用一个函数来 dispatch 所有的同步和异步 action，且不需要额外引入 middleware；再比如，使用路由的时候只需要关心定义具体的路由，不用去关心 history 对象，等等。</p>
<p>That’s exactly what Mirror does, encapsulates the tedious or repetitive work in very few APIs to offer a high level abstraction with efficiency and simplicity, and without breaking the pattern.</p>
<p>这正是 Mirror 的使命，用极少数的 API 封装所有繁琐甚至重复的工作，提供一种简洁高效的更高级抽象，同时保持原有的开发模式。</p>
<h2 id="2-redux"><a href="#2-redux" class="headerlink" title="2 redux"></a>2 redux</h2><p><strong>超级重点，样板文件</strong><br>2-1 Actions<br>2-2 Action Creators<br>2-3 Generating Action Creators<br>2-4 Async Action Creators<br>2-5 Reducers<br>2-6 Generating Reducers</p>
<h3 id="2-1-Actions"><a href="#2-1-Actions" class="headerlink" title="2.1 Actions"></a>2.1 Actions</h3><h4 id="2-1-1-Reducing-Boilerplate"><a href="#2-1-1-Reducing-Boilerplate" class="headerlink" title="2.1.1 Reducing Boilerplate"></a>2.1.1 Reducing Boilerplate</h4><p>Redux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we’d like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</p>
<p>Redux的部分是受Flux启发的，关于Flux最常见的抱怨就是它让你写出很多样板文件的。在下面的介绍中，我们将意识到当基于个人风格、团队偏好、长期可维护性等等因素时，Redux是如何让我们选择使用这种超级冗长的代码。</p>
<h4 id="2-1-2-Actions-意义"><a href="#2-1-2-Actions-意义" class="headerlink" title="2.1.2 Actions 意义"></a>2.1.2 Actions 意义</h4><p>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It’s important that actions being objects you have to dispatch is not boilerplate, but one of the fundamental design choices of Redux.</p>
<p> Actions  是一个描述app中发生了什么的普通对象（变量），也是唯一一种方式来描述数据意图变化。要意识到是你必须dispatch的action ，并不是无用的模板，而是redux基本设计规则 。</p>
<p>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement hot reloading with time travel. If you’d rather modify data directly, you don’t need Redux.</p>
<p>有些框架声称类似Flux，但是没有action概念。就可预测而言，这些框架相比Flux和react是一种倒退。如果没有action对象， it is impossible to record and replay user sessions, or to implement hot reloading with time travel. 。如果你宁愿选择直接修改数据，则不需要使用Redux。</p>
<h4 id="2-1-3-Actions-格式"><a href="#2-1-3-Actions-格式" class="headerlink" title="2.1.3 Actions 格式"></a>2.1.3 Actions 格式</h4><p><span id="action">Actions look like this:</span><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>, <span class="attr">text</span>: <span class="string">'Use Redux'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'REMOVE_TODO'</span>, <span class="attr">id</span>: <span class="number">42</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'LOAD_ARTICLE'</span>, <span class="attr">response</span>: &#123; ...&#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not Symbols for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</p>
<p>约定习俗，actions有一个type（是个常量），目的为了帮助reducers（或者Stores in Flux）识别他们。我们建议将type定义成string类型或者不是symbols类型，因为strings are serializable,并且使用symbols类型会让你记录或者重演的行为变得更困难</p>
<p>In Flux, it is traditionally thought that you would define every action type as a string constant:<br>在Flux，一般都会把type定义成一个字符串常量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">'ADD_TODO'</span></span><br><span class="line"><span class="keyword">const</span> REMOVE_TODO = <span class="string">'REMOVE_TODO'</span></span><br><span class="line"><span class="keyword">const</span> LOAD_ARTICLE = <span class="string">'LOAD_ARTICLE'</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'ADD_TODO'</span>, <span class="attr">text</span>: <span class="string">'Use Redux'</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'REMOVE_TODO'</span>, <span class="attr">id</span>: <span class="number">42</span> &#125;</span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">'LOAD_ARTICLE'</span>, <span class="attr">response</span>: &#123; ...&#125; &#125;</span><br></pre></td></tr></table></figure>
<p>Why is this beneficial? It is often claimed that constants are unnecessary, and for small projects, this might be correct. For larger projects, there are some benefits to defining action types as constants:</p>
<p>为什么好呢？在小项目中，常量声明不是必须的，但是在大项目中，type定义成常量的好处如下：</p>
<ul>
<li><p>It helps keep the naming consistent because all action types are gathered in a single place.</p>
<blockquote>
<p>它有助于保持命名的一致性，因为所有操作类型都集中在一个地方。</p>
</blockquote>
</li>
<li><p>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn’t know.</p>
<blockquote>
<p>有时再添加新特性之前需要查看一下所有已存在的actions。也有可能你需要新增的action，你的队友已经添加但是你不知道</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</p>
<blockquote>
<p>  action的type列表，删除添加修改等操作很容易跟踪到</p>
</blockquote>
</li>
<li><p>If you make a typo when importing an action constant, you will get undefined. Redux will immediately throw when dispatching such an action, and you’ll find the mistake sooner.</p>
<blockquote>
<p>当你引入一个action常量的时候出现书写错误，那么你会得到undefined。当dispatch这个action的时候，redux立即报出问题，你就会很快地发现问题。</p>
</blockquote>
</li>
</ul>
<p>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</p>
<p>这取决于你，在项目中使用约定习俗 。你可以使用inline strings, and later transition to constants 或者把他们都放入一个单独文件中。redux在这里没做任何要求。</p>
<h4 id="2-1-4-Actions-in-Diwork"><a href="#2-1-4-Actions-in-Diwork" class="headerlink" title="2.1.4  Actions in Diwork"></a>2.1.4  Actions in Diwork</h4><p>（个人公司实际项目使用，这部分不是英文文档）<br><strong>（把它们放入一个单独文件中使我们项目中使用方式，就是diwork工作台）</strong></p>
<p>在diwork中一个store中会有四个文件<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">actions.js </span><br><span class="line">api.js</span><br><span class="line">index.js</span><br><span class="line">types.js</span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js中的createTypes</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createTypes = <span class="function">(<span class="params">...types</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> types.reduce(<span class="function">(<span class="params">obj, type</span>) =&gt;</span> &#123;</span><br><span class="line">    obj[type] = type;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;, &#123;&#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createTypes &#125; <span class="keyword">from</span> <span class="string">'@u'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createTypes(</span><br><span class="line">  <span class="string">'GET_APPLICATION_LIST'</span>,</span><br><span class="line">  <span class="string">'MODIFY_APPLICATION_STATE'</span>,</span><br><span class="line">  <span class="string">'GET_APPLICATION_SERVICE'</span>,</span><br><span class="line">  <span class="string">'SET_APPLICATION_SERVICE'</span>,</span><br><span class="line">);</span><br><span class="line"><span class="comment">// actions.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; createActions &#125; <span class="keyword">from</span> <span class="string">'@u'</span>;</span><br><span class="line"><span class="keyword">import</span> types <span class="keyword">from</span> <span class="string">'./types'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  getApplicationList,</span><br><span class="line">  modifyApplicationState,</span><br><span class="line">  getApplicationService,</span><br><span class="line">  setApplicationService,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./api'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;</span><br><span class="line">  GET_APPLICATION_LIST,</span><br><span class="line">  MODIFY_APPLICATION_STATE,</span><br><span class="line">  GET_APPLICATION_SERVICE,</span><br><span class="line">  SET_APPLICATION_SERVICE,</span><br><span class="line">&#125; = types;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> actions = createActions(</span><br><span class="line">  &#123;</span><br><span class="line">    namespace: <span class="string">'application'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    [GET_ALL_USER_LIST]: getAllUserList,</span><br><span class="line">    [MODIFY_APPLICATION_STATE]: modifyApplicationState,</span><br><span class="line">    [GET_APPLICATION_SERVICE]: getApplicationService,</span><br><span class="line">    [SET_APPLICATION_SERVICE]: setApplicationService,</span><br><span class="line">    </span><br><span class="line">  &#125;,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> actions;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Action-Creators"><a href="#2-3-Action-Creators" class="headerlink" title="2.3 Action Creators"></a>2.3 Action Creators</h3><p>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</p>
<p>另外一个约定习俗是：不要在你要dispatch action的地方内联式地创建action，而是创建些生成他们的函数更好</p>
<p>For example, instead of calling dispatch with an object literal:</p>
<p>比如不要dipatch一个字面量对象</p>
<p>somewhere in an event handler</p>
<pre><code>dispatch({
  type: &apos;ADD_TODO&apos;,
  text: &apos;Use Redux&apos;
})
</code></pre><p>You might write an action creator in a separate file, and import it into your component:<br>你最好在一个独立文件中写个action creator，然后import进来</p>
<pre><code>actionCreators.js

export function addTodo(text) {
  return {
    type: &apos;ADD_TODO&apos;,
    text
  }
}

AddTodo.js

import { addTodo } from &apos;./actionCreators&apos;

// somewhere in an event handler
dispatch(addTodo(&apos;Use Redux&apos;))
</code></pre><p><span id="actionCreators"></span></p>
<p>其实action creators就是return 一个action(一个action表现形式是type+其他内容)。就是把action封装下，在action的周围可以加上其他逻辑，如下：</p>
<p>Action creators have often been criticized as boilerplate. Well, you don’t have to write them! You can use object literals if you feel this better suits your project. There are, however, some benefits for writing action creators you should know about.</p>
<p>Action creator经常被批评为是模板文件。好吧，实际上你可以不写他们。如果你觉得合适，你可以使用字面量对象。但是关于action creator的好处你需要知道一下</p>
<p>Let’s say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with redux-thunk middleware and adding an early exit:</p>
<p>假设一个设计师在检查完原型之后回来告诉我们，我们需要允许最多三个任务。我们可以通过使用redux-thunk中间件将我们的action creator重写回调，并添加一个提前退出来实现这一点:</p>
<pre><code> function addTodoWithoutCheck(text) {
      return {
        type: &apos;ADD_TODO&apos;,
        text
      }
    }


export function addTodo(text) {
      // This form is allowed by Redux Thunk middleware
      // described below in “Async Action Creators” section.
      return function (dispatch, getState) {
        if (getState().todos.length === 3) {
          // Exit early
          return
        }
        dispatch(addTodoWithoutCheck(text))
      }
    }
</code></pre><p>We just modified how the addTodo action creator behaves, completely invisible to the calling code. We don’t have to worry about looking at each place where todos are being added, to make sure they have this check. Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It’s very handy when the application is under heavy development, and the requirements change often.</p>
<p>我们只需要修改addTodo这个action creator，完全可以忽略调用这个函数的任何地方（因此不用找到所有调用这个函数的地方添加任何额外操作）。action creator把dispatch an action周围的附加逻辑与发出这些动作的实际组件分离开来。<br>在繁重的开发阶段以及需求经常变动的情况下，这样开发变得非常敏捷</p>
<h3 id="2-3-Generating-Action-Creators"><a href="#2-3-Generating-Action-Creators" class="headerlink" title="2.3 Generating Action Creators"></a>2.3 Generating Action Creators</h3><p>Some frameworks like Flummox generate action type constants automatically from the action creator function definitions. The idea is that you don’t need to both define ADD_TODO constant and addTodo() action creator. Under the hood, such solutions still generate action type constants, but they’re created implicitly so it’s a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</p>
<p>一些框架像Flummox可以通过action creator函数来生成action的type常量。这种想法意味着你不需要同时定义ADD_TODO 常量和 addTodo()这个 action creator。但是实质上还是需要生成action type常量，并且这种隐式创建会导致混淆。我们建议显式地创建action type</p>
<p>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:<br>编写简单的action creator是非常累人的，并且常常会生成冗余的样板代码:</p>
<pre><code>export function addTodo(text) {
  return {
    type: &apos;ADD_TODO&apos;,
    text
  }
}

export function editTodo(id, text) {
  return {
    type: &apos;EDIT_TODO&apos;,
    id,
    text
  }
}

export function removeTodo(id) {
  return {
    type: &apos;REMOVE_TODO&apos;,
    id
  }
}
</code></pre><p>You can always write a function that generates an action creator:</p>
<pre><code>function makeActionCreator(type, ...argNames) {
  return function (...args) {
    const action = { type }
    argNames.forEach((arg, index) =&gt; {
      action[argNames[index]] = args[index]
    })
    return action
  }
}

const ADD_TODO = &apos;ADD_TODO&apos;
const EDIT_TODO = &apos;EDIT_TODO&apos;
const REMOVE_TODO = &apos;REMOVE_TODO&apos;

export const addTodo = makeActionCreator(ADD_TODO, &apos;text&apos;)
export const editTodo = makeActionCreator(EDIT_TODO, &apos;id&apos;, &apos;text&apos;)
export const removeTodo = makeActionCreator(REMOVE_TODO, &apos;id&apos;)
//上面的这个函数会返回来
addTodo(&apos;hahah&apos;)
{type: &quot;ADD_TODO&quot;, text: &quot;hahah&quot;}
</code></pre><blockquote>
<p>上面代码真的很不错，可以学习一下，闭包知识也有用到，type，argNames被保存了。注意返回的是一个函数</p>
</blockquote>
<p>There are also utility libraries to aid in generating action creators, such as redux-act and redux-actions. These can help reduce boilerplate code and enforce adherence to standards such as Flux Standard Action (FSA).</p>
<p>有一些公共库帮助生成action creators，比如redux-act 和redux-actions . 这样可以减少模板代码和强制遵循FSA规范</p>
<h3 id="2-4-Async-Action-Creators"><a href="#2-4-Async-Action-Creators" class="headerlink" title="2.4 Async Action Creators"></a>2.4 Async Action Creators</h3><p>异步的action creators</p>
<p>Middleware lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</p>
<p>Middleware 允许您注入自定义逻辑在每个action对象中 before it is dispatched。异步操作是middleware最常见的用例。</p>
<h4 id="2-4-1-middleware"><a href="#2-4-1-middleware" class="headerlink" title="2.4.1 middleware"></a>2.4.1 middleware</h4><p>Without any middleware, dispatch only accepts a plain object, so we have to perform AJAX calls inside our components:</p>
<p>没有middleware，<strong>dispatch只接受普通对象，因此我们不得不在组件中执行AJAX调用</strong>:</p>
<pre><code>actionCreators.js //其实action creators就是return 一个action(一个action表现形式是type+其他内容)。就是把action封装下，在action的周围可以加上其他逻辑

export function loadPostsSuccess(userId, response) {
  return {
    type: &apos;LOAD_POSTS_SUCCESS&apos;,
    userId,
    response
  }
}

export function loadPostsFailure(userId, error) {
  return {
    type: &apos;LOAD_POSTS_FAILURE&apos;,
    userId,
    error
  }
}

export function loadPostsRequest(userId) {
  return {
    type: &apos;LOAD_POSTS_REQUEST&apos;,
    userId
  }
}
</code></pre><p>UserInfo.js</p>
<pre><code>import { Component } from &apos;react&apos;
import { connect } from &apos;react-redux&apos;
import {
  loadPostsRequest,
  loadPostsSuccess,
  loadPostsFailure
} from &apos;./actionCreators&apos;

class Posts extends Component {
  loadData(userId) {
    // Injected into props by React Redux `connect()` call:
    // 通过调用React Redux `connect()`注入了props
    const { dispatch, posts } = this.props

    if (posts[userId]) {
      // There is cached data! Don&apos;t do anything.
      // 是否有缓存数据
      return
    }

    // Reducer can react to this action by setting
    // `isFetching` and thus letting us show a spinner.
    // 显示加载
    dispatch(loadPostsRequest(userId))

    // Reducer can react to these actions by filling the
    // `users`.

    fetch(`http://myapi.com/users/${userId}/posts`).then(
      response =&gt; dispatch(loadPostsSuccess(userId, response)),
      error =&gt; dispatch(loadPostsFailure(userId, error))
    );//问题出现在这里，正确错误这部分代码若存在上千个组件，那么重写这块上千次
  }

  componentDidMount() {
    this.loadData(this.props.userId)
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.userId !== this.props.userId) {
      this.loadData(nextProps.userId)
    }
  }

  render() {
    if (this.props.isFetching) {
      return &lt;p&gt;Loading...&lt;/p&gt;
    }

    const posts = this.props.posts.map(post =&gt;
      &lt;Post post={post} key={post.id} /&gt;
    )

    return &lt;div&gt;{posts}&lt;/div&gt;
  }
}

export default connect(state =&gt; ({
  posts: state.posts,
  isFetching: state.isFetching
}))(Posts)
</code></pre><p>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</p>
<p>然而这很快就会重复因为不同的组件使用相同api来请求数据，而且，我们希望重用许多组件中的一些逻辑（比如缓存数据存在的时候提前退出）<br>（如果有多个组件，需要重写很多次fetch请求呢）</p>
<p>Middleware lets us write more expressive, potentially async action creators. It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.</p>
<p>Middleware使我们能够编写更有表现力的、潜在的异步action creator。它允许我们dispatch something 而不是普通对象，并interprets the values。例如，middleware可以“捕获”已发出的promise，并将它们转换为一对请求+成功/失败操作。</p>
<p>The simplest example of middleware is redux-thunk. “Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.</p>
<p>middleware最简单的例子就是redux-thunk。<strong>thunk是允许你将action creators作为thunks，就是函数返回函数。这种反转控件，你可以将dispatch作为参数，因为写一个可以dispatch很多次的action creator</strong></p>
<blockquote>
<p>Note ：</p>
<p>Thunk middleware is just one example of middleware. Middleware is<br>not about “letting you dispatch functions”. It’s about letting you<br>dispatch anything that the particular middleware you use knows how to<br>handle. Thunk middleware adds a specific behavior when you dispatch<br>functions, but it really depends on the middleware you use. Thunk</p>
<p>middleware只是一个简单例子，Middleware不是让你‘dispatch functions’。他是让你dispatch<br>任何Middleware知道如何处理的事情。Thunk Middleware可以在你dispatch<br>functions之前添加一些特殊操作，不过这一切取决你你使用的Middleware</p>
</blockquote>
<p>Consider the code above rewritten with redux-thunk:</p>
<p>actionCreators.js</p>
<pre><code>export function loadPosts(userId) {
  // Interpreted by the thunk middleware:
  // 交给thunk Middleware 解释
  return function (dispatch, getState) {
    const { posts } = getState()
    if (posts[userId]) {
      // There is cached data! Don&apos;t do anything.
      return
    }

    dispatch({
      type: &apos;LOAD_POSTS_REQUEST&apos;,
      userId
    })

    // Dispatch vanilla actions asynchronously
    fetch(`http://myapi.com/users/${userId}/posts`).then(
      response =&gt;
        dispatch({
          type: &apos;LOAD_POSTS_SUCCESS&apos;,
          userId,
          response
        }),
      error =&gt;
        dispatch({
          type: &apos;LOAD_POSTS_FAILURE&apos;,
          userId,
          error
        })
    )
  }
}
</code></pre><p>UserInfo.js</p>
<pre><code>import { Component } from &apos;react&apos;
import { connect } from &apos;react-redux&apos;
import { loadPosts } from &apos;./actionCreators&apos;

class Posts extends Component {
  componentDidMount() {
    this.props.dispatch(loadPosts(this.props.userId));//这块就变得超级简洁了，error与response都在actioncreator.js中处理了
  }

  componentWillReceiveProps(nextProps) {
    if (nextProps.userId !== this.props.userId) {
      this.props.dispatch(loadPosts(nextProps.userId))
    }
  }

  render() {
    if (this.props.isFetching) {
      return &lt;p&gt;Loading...&lt;/p&gt;
    }

    const posts = this.props.posts.map(post =&gt;
      &lt;Post post={post} key={post.id} /&gt;
    )

    return &lt;div&gt;{posts}&lt;/div&gt;
  }
}

export default connect(state =&gt; ({
  posts: state.posts,
  isFetching: state.isFetching
}))(Posts)
</code></pre><p>This is much less typing! If you’d like, you can still have “vanilla” action creators like loadPostsSuccess which you’d use from a container loadPosts action creator.</p>
<p>更少的书写。如果你喜欢，你可以有vanilla action creators，如loadPostsSuccess<br>（其实就是把第一个UserInfo.js中loadData提出来加工一下改为loadPosts）</p>
<p>Finally, you can write your own middleware. Let’s say you want to generalize the pattern above and describe your async action creators like this instead:</p>
<p>最后你可以编写自己的Middleware。如果你想要概括并推广上面的模式，可以这样的描述你的异步action creators</p>
<pre><code>export function loadPosts(userId) {
  return {

    // Types of actions to emit before and after定义Types
    types: [&apos;LOAD_POSTS_REQUEST&apos;, &apos;LOAD_POSTS_SUCCESS&apos;, &apos;LOAD_POSTS_FAILURE&apos;],

    // Check the cache (optional):检查缓存
    shouldCallAPI: state =&gt; !state.posts[userId],

    // Perform the fetching:执行fetch
    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),
    // Arguments to inject in begin/end actions 参数注入在开始或者结束的actions
    payload: { userId }
  }
}
</code></pre><p>The middleware that interprets such actions could look like this:</p>
<p>定义这个actions的middleware需要写成如下：</p>
<pre><code>function callAPIMiddleware({ dispatch, getState }) {
  return next =&gt; action =&gt; {
    const {
      types,
      callAPI,
      shouldCallAPI = () =&gt; true,
      payload = {}
    } = action

    if (!types) {
      // Normal action: pass it on
      return next(action)
    }

    if (
      !Array.isArray(types) ||
      types.length !== 3 ||
      !types.every(type =&gt; typeof type === &apos;string&apos;)
    ) {
      throw new Error(&apos;Expected an array of three string types.&apos;)
    }

    if (typeof callAPI !== &apos;function&apos;) {
      throw new Error(&apos;Expected callAPI to be a function.&apos;)
    }

    if (!shouldCallAPI(getState())) {
      return
    }

    const [requestType, successType, failureType] = types

    dispatch(
      Object.assign({}, payload, {
        type: requestType
      })
    )

    return callAPI().then(
      response =&gt;
        dispatch(
          Object.assign({}, payload, {
            response,
            type: successType
          })
        ),
      error =&gt;
        dispatch(
          Object.assign({}, payload, {
            error,
            type: failureType
          })
        )
    )
  }
}
</code></pre><p>After passing it once to applyMiddleware(…middlewares), you can write all your API-calling action creators the same way:</p>
<p>只要使用一次applyMiddleware(…middlewares), 您可以用同样的方式编写所有api调用的action creators</p>
<pre><code>export function loadPosts(userId) {
  return {
    types: [&apos;LOAD_POSTS_REQUEST&apos;, &apos;LOAD_POSTS_SUCCESS&apos;, &apos;LOAD_POSTS_FAILURE&apos;],
    shouldCallAPI: state =&gt; !state.posts[userId],
    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),
    payload: { userId }
  }
}

export function loadComments(postId) {
  return {
    types: [
      &apos;LOAD_COMMENTS_REQUEST&apos;,
      &apos;LOAD_COMMENTS_SUCCESS&apos;,
      &apos;LOAD_COMMENTS_FAILURE&apos;
    ],
    shouldCallAPI: state =&gt; !state.comments[postId],
    callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`),
    payload: { postId }
  }
}

export function addComment(postId, message) {
  return {
    types: [
      &apos;ADD_COMMENT_REQUEST&apos;,
      &apos;ADD_COMMENT_SUCCESS&apos;,
      &apos;ADD_COMMENT_FAILURE&apos;
    ],
    callAPI: () =&gt;
      fetch(`http://myapi.com/posts/${postId}/comments`, {
        method: &apos;post&apos;,
        headers: {
          Accept: &apos;application/json&apos;,
          &apos;Content-Type&apos;: &apos;application/json&apos;
        },
        body: JSON.stringify({ message })
      }),
    payload: { postId, message }
  }
}
</code></pre><h3 id="2-5-Reducers"><a href="#2-5-Reducers" class="headerlink" title="2.5 Reducers"></a>2.5 Reducers</h3><p>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</p>
<p>Redux通过将更新逻辑描述为函数，大大减少了Flux样板。函数比对象简单，比类简单得多。</p>
<p>Consider this Flux store:</p>
<pre><code>const _todos = []

const TodoStore = Object.assign({}, EventEmitter.prototype, {
  getAll() {
    return _todos
  }
})

AppDispatcher.register(function (action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO:
      const text = action.text.trim()
      _todos.push(text)
      TodoStore.emitChange()
  }
})

export default TodoStore
</code></pre><p>With Redux, the same update logic can be described as a reducing function:</p>
<p><span id="reducer">使用redux，同样的更新操作可以写成这样</span></p>
<pre><code>export function todos(state = [], action) {
  switch (action.type) {
    case ActionTypes.ADD_TODO:
      const text = action.text.trim()
      return [...state, text]
    default:
      return state
  }
}
</code></pre><blockquote>
<p>去掉了TodoStore 和 TodoStore.emitCHange()，同时用state和return state来代替</p>
</blockquote>
<p>The switch statement is not the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app)。</p>
<p>这是对Flux的解析：<br>Switch语句不是真正冗余，Flux真正冗余的是概念：<br>需要emit an update<br>需要用一个dispatcher来注册store（就是store需要被注册在一个dispatcher上）<br>需要store是个对象（当你想要一个通用app的时候这就会非常的复杂）</p>
<p>It’s unfortunate that many still choose Flux framework based on whether it uses switch statements in the documentation. If you don’t like switch, you can solve this with a single function, as we show below.</p>
<p>愚蠢的是，许多人仍然根据文档中是否使用switch语句来选择Flux框架。如果您不喜欢switch，可以使用一个函数来解决这个问题，如下所示。</p>
<h3 id="2-6-Generating-Reducers"><a href="#2-6-Generating-Reducers" class="headerlink" title="2.6 Generating Reducers"></a>2.6 Generating Reducers</h3><p>Let’s write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our todos reducers to be defined like this:</p>
<p>让我们编写一个函数，让我们将reducers表述为一个对象映射，映射关系是action type 映射到 handlers。例如，如果我们希望我们的todos是这样定义的:</p>
<pre><code>export const todos = createReducer([], {
  [ActionTypes.ADD_TODO]: (state, action) =&gt; {
    const text = action.text.trim()
    return [...state, text]
  }
})
</code></pre><p>越来越像我们diwork项目中用到了这种映射关系。去掉了switch，We can write the following helper to accomplish this:<br>可以使用下面的帮助来完成</p>
<pre><code>function createReducer(initialState, handlers) {
  return function reducer(state = initialState, action) {
    if (handlers.hasOwnProperty(action.type)) {
      return handlers[action.type](state, action)
    } else {
      return state
    }
  }
}
</code></pre><p>This wasn’t difficult, was it? Redux doesn’t provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.<br>The Redux reducer API is (state, action) =&gt; newState, but how you create those reducers is up to you.</p>
<p>这并不难，不是吗?</p>
<p>Redux默认情况下不提供这样的帮助helper，因为有很多方法可以编写它。也许您希望它自动将普通JS对象转换为不可变对象，以适应服务器状态。（玩事就是讲js对象转化成immutable对象）。也许您希望将返回的state与当前state合并。也有很多不同的方式来使用‘catch all’handler。所有这些都取决于您根据特定项目中选择的约定。</p>
<p>Redux reducer API是(state, action) =&gt; newState，但是如何创建这些reducer取决于您。</p>
<p>##3 总结<br>看完全篇之后有几个概念是我们经常遇见的，</p>
<blockquote>
<p>action 、 action creators 、 reducer以及之间 的区别</p>
<p>action  = type + new value <a href="#action">点击跳转</a></p>
<p>action creators = logic + action <a href="#actionCreators">点击跳转</a></p>
<p>reducer = state +  action creators<br><a href="#reducer">点击跳转</a></p>
</blockquote>
<h2 id="4-diwork项目中的redux"><a href="#4-diwork项目中的redux" class="headerlink" title="4 diwork项目中的redux"></a>4 diwork项目中的redux</h2><p><img src="https://raw.githubusercontent.com/XYooo/image/master/redux2@2x.png" alt="单页中完整redux分成四个文件"><br><img src="https://raw.githubusercontent.com/XYooo/image/master/redux3@2x.png" alt="actions目录"><br><img src="https://raw.githubusercontent.com/XYooo/image/master/redux4@2x.png" alt="reducer目录"></p>

        
            <div class="donate-container">
    <div class="donate-button">
        <button id="donate-button">赞赏</button>
    </div>
    <div class="donate-img-container hide" id="donate-img-container">
        <img id="donate-img" src="" data-src="/img/donate.jpg">
        <p> 感谢鼓励 </p>
    </div>
</div>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>
    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
