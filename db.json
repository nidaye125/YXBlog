{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/yilia2/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia2/source/main.de30a6.css","path":"main.de30a6.css","modified":1,"renderable":1},{"_id":"themes/yilia2/source/slider.b612b4.js","path":"slider.b612b4.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/main.de30a6.js","path":"main.de30a6.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/mobile.5eaeff.js","path":"mobile.5eaeff.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia2/source/img/avatar.png","path":"img/avatar.png","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"4bfc4692582d3ff70dc839cce4a37c5dbed519b6","modified":1531562764052},{"_id":"themes/yilia2/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1531563287265},{"_id":"themes/yilia2/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1531563287265},{"_id":"themes/yilia2/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1531563287266},{"_id":"themes/yilia2/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1531563287266},{"_id":"themes/yilia2/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1531563287266},{"_id":"themes/yilia2/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1531563287266},{"_id":"themes/yilia2/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1531563287266},{"_id":"themes/yilia2/_config.yml","hash":"3f82a104bd1f0d7f188c0705feb6ec9ce36bb50e","modified":1535022013889},{"_id":"themes/yilia2/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1531563287276},{"_id":"themes/yilia2/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1531563287298},{"_id":"source/_posts/git.md","hash":"6d68944ffac63fee53fcc6fbd3e7c43bd493e817","modified":1535357100756},{"_id":"source/_posts/redux.md","hash":"98e45af2c4584b34867e91dbf3c56ca0284d237a","modified":1535090146355},{"_id":"source/_posts/react_hoc_2.md","hash":"8128ffeba544db0632b57854eee663b0de32ce59","modified":1531564423407},{"_id":"source/_posts/react_hoc_1.md","hash":"fc77d5e61c96a93a8dc6f432ee51cce204e1d3d0","modified":1531564358950},{"_id":"source/_posts/webpack单页多页初试水.md","hash":"0c70ba85cd7ca46e8f444c37560c3848cf338ab5","modified":1535357140388},{"_id":"source/_posts/前端模块化（一）.md","hash":"c6a4fab17aedf04e6faab197825e8a654fb54e8d","modified":1535350543127},{"_id":"source/_posts/前端模块化（二）.md","hash":"fa3132f8413d1b5c7006852eef2db32f66b9712c","modified":1535353477959},{"_id":"source/whatIFeel/index.ejs","hash":"fc8db044a07565c3149a956ed10f2224859c3934","modified":1531565777781},{"_id":"source/whatIFeel/ins.css","hash":"c69183cde47e77a6a7db78171ea94bfcf7a1f855","modified":1531566253511},{"_id":"source/whatIFeel/ins.js","hash":"cf9140c46b52f128800cb8c2b90067bee1f1fde9","modified":1531565936982},{"_id":"source/whatIFeel/ins.json","hash":"636600e403a8fd2c3e1d7f66d5cf29aae27c30b2","modified":1531565569557},{"_id":"themes/yilia2/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1531563287256},{"_id":"themes/yilia2/.git/COMMIT_EDITMSG","hash":"49d6a24a4edc08a665964fd6ec0886f65cd08616","modified":1535006905830},{"_id":"themes/yilia2/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1531563287258},{"_id":"themes/yilia2/.git/FETCH_HEAD","hash":"1efc9d034adf6456e816fcbb20023807ca64bbd0","modified":1531563324594},{"_id":"themes/yilia2/.git/ORIG_HEAD","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1531563324610},{"_id":"themes/yilia2/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1531563270763},{"_id":"themes/yilia2/.git/index","hash":"68d04671570d8913e83abc46415a9de0ea3380fe","modified":1535006905829},{"_id":"themes/yilia2/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1531563287254},{"_id":"themes/yilia2/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1531563287267},{"_id":"themes/yilia2/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1531563287267},{"_id":"themes/yilia2/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1531563287267},{"_id":"themes/yilia2/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1531563287267},{"_id":"themes/yilia2/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1531563287267},{"_id":"themes/yilia2/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1531563287267},{"_id":"themes/yilia2/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1531563287268},{"_id":"themes/yilia2/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1531563287275},{"_id":"themes/yilia2/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1531563287275},{"_id":"themes/yilia2/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1531563287275},{"_id":"themes/yilia2/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1531563287275},{"_id":"themes/yilia2/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1531563287276},{"_id":"themes/yilia2/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1531563287275},{"_id":"themes/yilia2/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1531563287276},{"_id":"themes/yilia2/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1535006223910},{"_id":"themes/yilia2/source/main.de30a6.css","hash":"b6cbda58112c6de28f67f56fe1af5f65325fde02","modified":1535006604779},{"_id":"themes/yilia2/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1531563287276},{"_id":"themes/yilia2/source/slider.b612b4.js","hash":"e569d13173d17936dc904f8bb88d5f64d3ee2e29","modified":1535006604779},{"_id":"themes/yilia2/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1535006223913},{"_id":"themes/yilia2/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1531563287292},{"_id":"themes/yilia2/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1531563287274},{"_id":"themes/yilia2/source/main.de30a6.js","hash":"58652c8969ae30adfd42960cf6f18601dfc11dd7","modified":1535006604779},{"_id":"themes/yilia2/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1535006223911},{"_id":"themes/yilia2/source/mobile.5eaeff.js","hash":"626699cf1b79f6d3095e1de65687ee702e4dca36","modified":1535006604779},{"_id":"themes/yilia2/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1535006223912},{"_id":"themes/yilia2/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1531563270766},{"_id":"themes/yilia2/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1531563270764},{"_id":"themes/yilia2/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1531563270767},{"_id":"themes/yilia2/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1531563270765},{"_id":"themes/yilia2/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1531563270768},{"_id":"themes/yilia2/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1531563270766},{"_id":"themes/yilia2/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1531563270768},{"_id":"themes/yilia2/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1531563270767},{"_id":"themes/yilia2/.git/info/exclude","hash":"bb5a85730dcf100facee799c05cc4f6affec0745","modified":1531563270763},{"_id":"themes/yilia2/.git/logs/HEAD","hash":"75c0cb5c9d55dcce965d86757aa9f12db315d3db","modified":1535006905831},{"_id":"themes/yilia2/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1531563270765},{"_id":"themes/yilia2/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1531563270768},{"_id":"themes/yilia2/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1531563287268},{"_id":"themes/yilia2/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1531563287268},{"_id":"themes/yilia2/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1531563287268},{"_id":"themes/yilia2/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1531563287269},{"_id":"themes/yilia2/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1531563287269},{"_id":"themes/yilia2/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1531563287268},{"_id":"themes/yilia2/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1531563287269},{"_id":"themes/yilia2/layout/_partial/css.ejs","hash":"f59af4f884d271dbaf4504a5b6c4da88ce78de9d","modified":1535006604781},{"_id":"themes/yilia2/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1535006204866},{"_id":"themes/yilia2/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1531563287270},{"_id":"themes/yilia2/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1531563287269},{"_id":"themes/yilia2/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1531563287270},{"_id":"themes/yilia2/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1531563287270},{"_id":"themes/yilia2/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1531563287270},{"_id":"themes/yilia2/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1531563287274},{"_id":"themes/yilia2/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1531563287274},{"_id":"themes/yilia2/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1535006604781},{"_id":"themes/yilia2/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1535006604781},{"_id":"themes/yilia2/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1535006604781},{"_id":"themes/yilia2/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1535006604780},{"_id":"themes/yilia2/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1535006604780},{"_id":"themes/yilia2/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1535006604781},{"_id":"themes/yilia2/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1535006604780},{"_id":"themes/yilia2/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1535006604780},{"_id":"themes/yilia2/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1535006604780},{"_id":"themes/yilia2/source/img/avatar.png","hash":"1547f25927881f9b582fcb2a8d932ff92d94c398","modified":1535008175629},{"_id":"themes/yilia2/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1531563287277},{"_id":"themes/yilia2/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1531563287277},{"_id":"themes/yilia2/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1531563287277},{"_id":"themes/yilia2/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1531563287278},{"_id":"themes/yilia2/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1531563287278},{"_id":"themes/yilia2/source-src/css/article-inner.scss","hash":"ba155504cda20fc1d5b1aac05812a207013d0937","modified":1535006506869},{"_id":"themes/yilia2/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1531563287278},{"_id":"themes/yilia2/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1531563287279},{"_id":"themes/yilia2/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1531563287278},{"_id":"themes/yilia2/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1531563287281},{"_id":"themes/yilia2/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1531563287283},{"_id":"themes/yilia2/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1531563287284},{"_id":"themes/yilia2/source-src/css/grid.scss","hash":"248277a474bc7fc299a25b4f505bfbb1f819f505","modified":1535006533885},{"_id":"themes/yilia2/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1531563287284},{"_id":"themes/yilia2/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1531563287285},{"_id":"themes/yilia2/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1531563287285},{"_id":"themes/yilia2/source-src/css/left.scss","hash":"3034b8377ae0e09aee81451d3401a06478362aa8","modified":1535006521035},{"_id":"themes/yilia2/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1531563287286},{"_id":"themes/yilia2/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1531563287286},{"_id":"themes/yilia2/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1531563287286},{"_id":"themes/yilia2/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1531563287287},{"_id":"themes/yilia2/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1531563287287},{"_id":"themes/yilia2/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1531563287287},{"_id":"themes/yilia2/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1531563287287},{"_id":"themes/yilia2/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1531563287287},{"_id":"themes/yilia2/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1531563287288},{"_id":"themes/yilia2/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1531563287288},{"_id":"themes/yilia2/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1531563287289},{"_id":"themes/yilia2/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1531563287289},{"_id":"themes/yilia2/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1531563287290},{"_id":"themes/yilia2/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1531563287290},{"_id":"themes/yilia2/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1531563287289},{"_id":"themes/yilia2/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1531563287290},{"_id":"themes/yilia2/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1531563287290},{"_id":"themes/yilia2/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1531563287289},{"_id":"themes/yilia2/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1531563287290},{"_id":"themes/yilia2/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1531563287291},{"_id":"themes/yilia2/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1531563287291},{"_id":"themes/yilia2/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1531563287291},{"_id":"themes/yilia2/layout/_partial/script.ejs","hash":"e83075444e8b89d300fef9d62f5e0850121c57c6","modified":1535006604781},{"_id":"themes/yilia2/.git/objects/6b/11f83c798a47f5b61abc50aff76278773404ed","hash":"e388282656f217b745c37049c280b562b818a592","modified":1535006905831},{"_id":"themes/yilia2/.git/objects/46/2575aa242e34e28167e295c93c4fae6fcabdd9","hash":"dc986c4d5370f97f01a76e72286100eec987969c","modified":1535006899102},{"_id":"themes/yilia2/.git/objects/10/ae538b3a35534aa4766edd78aa7368565b5a9b","hash":"aec325e7cf8b530aa922160d1317e3d063fa99fb","modified":1535006899105},{"_id":"themes/yilia2/.git/objects/2c/d93729df0b675f2e8e09d71ab3bbe040ab45fa","hash":"33c6c76ba66954bfd4004adbf7021fd0a5a92d48","modified":1535006899094},{"_id":"themes/yilia2/.git/objects/71/a416d59d1ef6d2c2c531de358b16ed901f81b4","hash":"740a7be5d4c5ddb7bed9878047e85be45f3cef29","modified":1535006899101},{"_id":"themes/yilia2/.git/objects/82/0b72df4058e471c5a8b5bf95cf6142ee21397f","hash":"14f0ceb62b1e36b3d2ea0eb245559c19c592d182","modified":1535006905824},{"_id":"themes/yilia2/.git/objects/9c/a6bcb1780beb5045f8dd638e0922f5ff5483de","hash":"b378236d1b26e7a1c5062d33ccdae2b68588a262","modified":1535006905828},{"_id":"themes/yilia2/.git/objects/7b/a3c6d58418bc3db1565fd936764fdcc10c6d2e","hash":"ecbcd451539c0b77ce79b8488ce2346d9aa60d75","modified":1535006899101},{"_id":"themes/yilia2/.git/objects/54/d500a61d4a9b8fdf6f7bcc38a5e4e34e1772a3","hash":"6293bf770b84c83dc61bc0a7f3710f4b0d53f566","modified":1535006905826},{"_id":"themes/yilia2/.git/objects/29/2af28a1d32d0501a1d33ea74274df36646295d","hash":"39cbf22deda224a30a09a7e42b3c232354bda35d","modified":1535006899115},{"_id":"themes/yilia2/.git/objects/a2/bf5bf20351b8d94e38b7fad0c96f9cd995d745","hash":"32e85ece3ffe5fc7872443ddda4fcf6670fd0658","modified":1535006905828},{"_id":"themes/yilia2/.git/objects/c1/d7b5838e96edc2cf42d10df981fa95cd2c9e8e","hash":"f9beb582a3614cfa1f1095fbb763a3d06a1817ce","modified":1535006905825},{"_id":"themes/yilia2/.git/objects/a3/9f8debbc5d76d11b5aac873b8729e757531fe4","hash":"aad806544ce779a5b149fa93bd18fba38a25b3eb","modified":1535006905827},{"_id":"themes/yilia2/.git/objects/pack/pack-4ea115ea551bddb7dfbba8549e99744c338c11f5.idx","hash":"fa67089ee1ad846ff7249deebdea253cb0b37339","modified":1531563287239},{"_id":"themes/yilia2/.git/objects/ad/36b5d606b076abde7a92930a7a02a842fcc491","hash":"8ee8bcb3642364c57ec918d84fea1c187e042352","modified":1535006899100},{"_id":"themes/yilia2/.git/refs/heads/master","hash":"4b2535dc272f4636e698cf1ed72e8f338abe7fa3","modified":1535006905831},{"_id":"themes/yilia2/.git/objects/de/5c074a6a3bdf52ffb105dc383ba1432d2b7365","hash":"902094d8915fb9c09dfb78b9ea757319a53a70cd","modified":1535006899108},{"_id":"themes/yilia2/.git/objects/e7/398fe8c0c384f44ca8588ad41f9c01c23ae788","hash":"960181906d1ff6989b691397daf4f574a0ca6feb","modified":1535006899113},{"_id":"themes/yilia2/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1531563287270},{"_id":"themes/yilia2/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1531563287271},{"_id":"themes/yilia2/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1531563287271},{"_id":"themes/yilia2/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1531563287271},{"_id":"themes/yilia2/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1531563287271},{"_id":"themes/yilia2/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1531563287272},{"_id":"themes/yilia2/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1531563287272},{"_id":"themes/yilia2/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1531563287272},{"_id":"themes/yilia2/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1531563287272},{"_id":"themes/yilia2/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1531563287273},{"_id":"themes/yilia2/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1531563287279},{"_id":"themes/yilia2/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1531563287279},{"_id":"themes/yilia2/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1531563287281},{"_id":"themes/yilia2/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1531563287280},{"_id":"themes/yilia2/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1531563287280},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1531563287281},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1531563287282},{"_id":"themes/yilia2/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1531563287285},{"_id":"themes/yilia2/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1531563287284},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1531563287283},{"_id":"themes/yilia2/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1531563287282},{"_id":"themes/yilia2/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1531563287285},{"_id":"themes/yilia2/.git/logs/refs/heads/master","hash":"75c0cb5c9d55dcce965d86757aa9f12db315d3db","modified":1535006905834},{"_id":"themes/yilia2/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1531563287256},{"_id":"themes/yilia2/.git/logs/refs/remotes/origin/HEAD","hash":"dc44a64b0b437aa0d7519371060276abe6d2e2a7","modified":1531563287256},{"_id":"themes/yilia2/.git/objects/pack/pack-4ea115ea551bddb7dfbba8549e99744c338c11f5.pack","hash":"73e65d3196952cb93c5f99df243f4ac69f85c5e7","modified":1531563287237},{"_id":"public/whatIFeel/ins.css","hash":"c69183cde47e77a6a7db78171ea94bfcf7a1f855","modified":1535363306586},{"_id":"public/whatIFeel/ins.js","hash":"cf9140c46b52f128800cb8c2b90067bee1f1fde9","modified":1535363306679},{"_id":"public/whatIFeel/ins.json","hash":"071511a7dded0951f6d5d4f4e1cfe8113f73c5ef","modified":1535363306691},{"_id":"public/content.json","hash":"06850c2434da1813ffec2f2fc67b09efd1b78788","modified":1535363306691},{"_id":"public/whatIFeel/index.html","hash":"daf955308736f453b1b16eb63367350322181677","modified":1535363306694},{"_id":"public/2018/08/27/webpack单页多页初试水/index.html","hash":"5b2afd364bf4d8fcf7ffa9437eb50fb9e528030d","modified":1535363306694},{"_id":"public/2018/08/27/前端模块化（二）/index.html","hash":"6540168f656ed89c7999f0c75d91ee7377654849","modified":1535363306694},{"_id":"public/2018/08/27/前端模块化（一）/index.html","hash":"840a66ebbf49cf4130ef7378261e38daea8daab8","modified":1535363306694},{"_id":"public/2018/08/24/redux/index.html","hash":"9a3f8de1f57ee0297fd489b7b25e54570afe2339","modified":1535363306694},{"_id":"public/2018/08/23/git/index.html","hash":"ebac593ba3eaa65f0311298e5b306ee6e9d1f332","modified":1535363306695},{"_id":"public/2018/06/25/react_hoc_2/index.html","hash":"c901d6bf46b0b65a4b71797bc92feeb3f6deb151","modified":1535363306695},{"_id":"public/2018/06/25/react_hoc_1/index.html","hash":"20108e29db3336d6ddeedfb7c8466ac3ff56b76e","modified":1535363306695},{"_id":"public/archives/index.html","hash":"79e5d1ea2ca7ace73a323192763176611d8ac785","modified":1535363306695},{"_id":"public/archives/2018/index.html","hash":"a85c1ca5d47485a447f9c98cc212e989b4f9792c","modified":1535363306695},{"_id":"public/archives/2018/06/index.html","hash":"30bd8d9388070835f58fb687d59163b4fc59f445","modified":1535363306695},{"_id":"public/archives/2018/08/index.html","hash":"69f50fe04522fda709674fd7dac332dc91ad4303","modified":1535363306695},{"_id":"public/index.html","hash":"b34e36350679cffde4437879fd15c3cac1bb2041","modified":1535363306695},{"_id":"public/tags/git/index.html","hash":"fd04c5604d197e03ecb01213ba372b51a0c4fac3","modified":1535363306695},{"_id":"public/tags/react/index.html","hash":"071f0cbc0201a21be451d1df3b988c6e75568398","modified":1535363306696},{"_id":"public/tags/hoc-react/index.html","hash":"be4d3b4fbca8d1f3d44139bdfacc972218530873","modified":1535363306696},{"_id":"public/tags/模块化/index.html","hash":"6ca006142b268c756ebe276fa53cb147ff7cfa22","modified":1535363306696},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1535363306698},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1535363306698},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1535363306698},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1535363306698},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1535363306698},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1535363306698},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1535363306698},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1535363306698},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1535363306698},{"_id":"public/img/avatar.png","hash":"1547f25927881f9b582fcb2a8d932ff92d94c398","modified":1535363306699},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1535363306706},{"_id":"public/main.de30a6.css","hash":"b6cbda58112c6de28f67f56fe1af5f65325fde02","modified":1535363306706},{"_id":"public/slider.b612b4.js","hash":"e569d13173d17936dc904f8bb88d5f64d3ee2e29","modified":1535363306706},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1535363306706},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1535363306706},{"_id":"public/mobile.5eaeff.js","hash":"626699cf1b79f6d3095e1de65687ee702e4dca36","modified":1535363306707},{"_id":"public/main.de30a6.js","hash":"58652c8969ae30adfd42960cf6f18601dfc11dd7","modified":1535363306707},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1535363306707}],"Category":[],"Data":[],"Page":[{"layout":"post","slug":"WhatIFeel","title":"WhatIFeel","noDate":"true","comments":0,"_content":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<ul class=\"feel-content\" id=\"feelContent\">\n    <li class=\"content-item\">\n        <span class=\"content-time\"></span>\n        <span class=\"content-spec\"></span>\n    </li>\n</ul>\n\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n","source":"whatIFeel/index.ejs","raw":"---\nlayout: post\nslug: \"WhatIFeel\"\ntitle: \"WhatIFeel\"\nnoDate: \"true\"\ncomments: \"false\"\n---\n<link rel=\"stylesheet\" href=\"./ins.css\">\n<ul class=\"feel-content\" id=\"feelContent\">\n    <li class=\"content-item\">\n        <span class=\"content-time\"></span>\n        <span class=\"content-spec\"></span>\n    </li>\n</ul>\n\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n","date":"2018-07-14T10:56:17.781Z","updated":"2018-07-14T10:56:17.781Z","path":"whatIFeel/index.html","_id":"cjlc3o50o0001vds6lmkyxwso","content":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<ul class=\"feel-content\" id=\"feelContent\">\n    <li class=\"content-item\">\n        <span class=\"content-time\"></span>\n        <span class=\"content-spec\"></span>\n    </li>\n</ul>\n\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n","site":{"data":{}},"excerpt":"","more":"<link rel=\"stylesheet\" href=\"./ins.css\">\n<ul class=\"feel-content\" id=\"feelContent\">\n    <li class=\"content-item\">\n        <span class=\"content-time\"></span>\n        <span class=\"content-spec\"></span>\n    </li>\n</ul>\n\n<script>\n  (function() {\n    var loadScript = function(path) {\n      var $script = document.createElement('script')\n      document.getElementsByTagName('body')[0].appendChild($script)\n      $script.setAttribute('src', path)\n    }\n    setTimeout(function() {\n      loadScript('./ins.js')\n    }, 0)\n  })()\n</script>\n"},{"_content":".article-header {\n    \n    border-bottom: 1px solid #ddd;\n}\n.content-item{\n\tmin-height: 150px;\n\tpadding-top: 10px;\n\tlist-style: none;\n\tborder-bottom: 3px dashed pink;\n}\n.content-item span{\n\tdisplay: block;\n\tfont-size:18px;\n}\nspan.content-spec {\n    padding: 20px;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}","source":"whatIFeel/ins.css","raw":".article-header {\n    \n    border-bottom: 1px solid #ddd;\n}\n.content-item{\n\tmin-height: 150px;\n\tpadding-top: 10px;\n\tlist-style: none;\n\tborder-bottom: 3px dashed pink;\n}\n.content-item span{\n\tdisplay: block;\n\tfont-size:18px;\n}\nspan.content-spec {\n    padding: 20px;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}","date":"2018-07-14T11:04:13.511Z","updated":"2018-07-14T11:04:13.511Z","path":"whatIFeel/ins.css","layout":"false","title":"","comments":1,"_id":"cjlc3o50r0003vds6ecs1j2l0","content":".article-header {\n    \n    border-bottom: 1px solid #ddd;\n}\n.content-item{\n\tmin-height: 150px;\n\tpadding-top: 10px;\n\tlist-style: none;\n\tborder-bottom: 3px dashed pink;\n}\n.content-item span{\n\tdisplay: block;\n\tfont-size:18px;\n}\nspan.content-spec {\n    padding: 20px;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}","site":{"data":{}},"excerpt":"","more":".article-header {\n    \n    border-bottom: 1px solid #ddd;\n}\n.content-item{\n\tmin-height: 150px;\n\tpadding-top: 10px;\n\tlist-style: none;\n\tborder-bottom: 3px dashed pink;\n}\n.content-item span{\n\tdisplay: block;\n\tfont-size:18px;\n}\nspan.content-spec {\n    padding: 20px;\n}\n\n@media screen and (max-width:600px) {\n\t.instagram .thumb {\n\t\twidth: 50%;\n\t\tpadding-bottom: 50%;\n\t}\n\t.instagram .album li {\n\t\twidth: 100%;\n\t\tposition: relative;\n\t\tpadding-bottom: 100%;\n\t\ttext-align: center;\n\t}\n\t.instagram .album div.img-box{\n\t\tmargin: 0;\n\t\twidth: 90%;\n\t\theight: 90%;\n\t}\n}"},{"_content":"\n(function(searchData) {\n    function render(data){\n      console.log(data)\n      var telDom = '';\n      data.list.forEach(item => {\n        telDom += '<li class=\"content-item\">'\n        +'<span class=\"content-time\">'+item.date+'</span>'\n        +'<span class=\"content-spec\">'+item.content+'</span>'\n        +'</li>';\n      })\n      document.getElementById('feelContent').innerHTML = telDom;\n    }\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n    Ins.init();\n    // export default impush;\n\n    /***/\n})(undefined);","source":"whatIFeel/ins.js","raw":"\n(function(searchData) {\n    function render(data){\n      console.log(data)\n      var telDom = '';\n      data.list.forEach(item => {\n        telDom += '<li class=\"content-item\">'\n        +'<span class=\"content-time\">'+item.date+'</span>'\n        +'<span class=\"content-spec\">'+item.content+'</span>'\n        +'</li>';\n      })\n      document.getElementById('feelContent').innerHTML = telDom;\n    }\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n    Ins.init();\n    // export default impush;\n\n    /***/\n})(undefined);","date":"2018-07-14T10:58:56.982Z","updated":"2018-07-14T10:58:56.982Z","path":"whatIFeel/ins.js","layout":"false","title":"","comments":1,"_id":"cjlc3o50w0006vds64gysk1cz","content":"\n(function(searchData) {\n    function render(data){\n      console.log(data)\n      var telDom = '';\n      data.list.forEach(item => {\n        telDom += '<li class=\"content-item\">'\n        +'<span class=\"content-time\">'+item.date+'</span>'\n        +'<span class=\"content-spec\">'+item.content+'</span>'\n        +'</li>';\n      })\n      document.getElementById('feelContent').innerHTML = telDom;\n    }\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n    Ins.init();\n    // export default impush;\n\n    /***/\n})(undefined);","site":{"data":{}},"excerpt":"","more":"\n(function(searchData) {\n    function render(data){\n      console.log(data)\n      var telDom = '';\n      data.list.forEach(item => {\n        telDom += '<li class=\"content-item\">'\n        +'<span class=\"content-time\">'+item.date+'</span>'\n        +'<span class=\"content-spec\">'+item.content+'</span>'\n        +'</li>';\n      })\n      document.getElementById('feelContent').innerHTML = telDom;\n    }\n    function loadData(success) {\n      if (!searchData) {\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', './ins.json?t=' + +new Date(), true);\n\n        xhr.onload = function() {\n          if (this.status >= 200 && this.status < 300) {\n            var res = JSON.parse(this.response);\n            searchData = res;\n            success(searchData);\n          } else {\n            console.error(this.statusText);\n          }\n        };\n\n        xhr.onerror = function() {\n          console.error(this.statusText);\n        };\n\n        xhr.send();\n      } else {\n        success(searchData);\n      }\n    }\n    var Ins = {\n      init: function init() {\n        loadData(function(data) {\n          render(data);\n        });\n      }\n    };\n    Ins.init();\n    // export default impush;\n\n    /***/\n})(undefined);"},{"_content":"{\n\t\"list\": [{\n\t\t\"date\": \"2017-07\",\n\t\t\"content\":\"不知道该怎么说，就这么算了\"\n\t},{\n\t\t\"date\": \"2018-07\",\n\t\t\"content\":\"我也是真正的作死\"\n\t}]\n}","source":"whatIFeel/ins.json","raw":"{\n\t\"list\": [{\n\t\t\"date\": \"2017-07\",\n\t\t\"content\":\"不知道该怎么说，就这么算了\"\n\t},{\n\t\t\"date\": \"2018-07\",\n\t\t\"content\":\"我也是真正的作死\"\n\t}]\n}","date":"2018-07-14T10:52:49.557Z","updated":"2018-07-14T10:52:49.557Z","path":"whatIFeel/ins.json","layout":"false","title":"","comments":1,"_id":"cjlc3o50y0008vds6r3bsdda4","content":"{\"list\":[{\"date\":\"2017-07\",\"content\":\"不知道该怎么说，就这么算了\"},{\"date\":\"2018-07\",\"content\":\"我也是真正的作死\"}]}","site":{"data":{}},"excerpt":"","more":"{\"list\":[{\"date\":\"2017-07\",\"content\":\"不知道该怎么说，就这么算了\"},{\"date\":\"2018-07\",\"content\":\"我也是真正的作死\"}]}"}],"Post":[{"title":"git新操作备注","_content":"\n使用git进行工程的操作，长期下来git pull 、git add 、git push、就可以完成日常所需，但是近期有些其他的操作，记录下来都是亲身测试有效的\n\n<!-- more -->\n### 1.开个新分支\n（1）如果新建一个以develop内容为基础的分支\n\n - git checkout develop \n - git checkout -b yx0628develop_new\n\n不断修改不断的保存也是可以生成log的\n\n - git add .  //这是提交全部修改，慎重 \n - git commit -m'全部修改提交'\n\n（2）把新分支的代码合并到develop\n 前提：先把新分支yx0628develop_new的代码add完毕，commit完毕\n \n\n - git checkout develop  \n - git merge yx0628develop_new\n无冲突\n - git push \n有冲突\n - 解决冲突\n - git add 冲突文件\n - git commit -m'随便你想写什么'\n - git push\n\n###2.代码迁移仓库（保留log）\n不保留log等提交的记录的迁移就不说了，soeasy！\n目标：把A仓库的代码迁移到B仓库并且保存所有的git log，B仓库已经存在了哦，哪怕是个空仓库。\n\n再说这个之前先说点其他。在使用git的时候我们可能见到这样的命令。不想看解说想直接看步骤的，[直接步骤](#1)\n\n>     git pull origin master //拉取远程master分支的代码\n>     git push origin master //把代码推到远程master分支上去\n\n有没有人好奇为什么是origin，而不是其他名字，比如git pull orginal master或者git pull origin2 master;\n\n解答上面的问题很简单，请在你的工程中输入\n\n>     git remote\n发现了什么呢？默认就有一个origin，代表远程仓库。origin是有地址，地址就是当前仓库的git地址，是个url哦。所以为什么git push origin master就自动相应的推到的远程仓库的master分支了。\n\n\n<h2 id=\"1\">下面是正确的操作步骤，(看准情况分类很重要，就两种)</h2>\n不管哪种情况请从情况1开始看哈哈：\n\n<h2>情况1：</h2>\n**B仓库是一个空仓库，除了默认的master分支，没有任何分支**。把A的branch1,branch2,branch3...依次迁入B，B也就有branch1,branch2,branch3,\n\n - 进入A工程\n - git remote     \n    > 原因：看下当前远程仓库有啥名字，然后取个崭新的名字，不重复的名字，名字是过渡，不必纠结。这里取名origin2\n\n - git remote add origin2 master\n  > 不纠结照抄这就话\n - git remote set-url origin2 git@git.hub.com:B.git\n    > 原因：后面的B仓库地址url才是关键，origin2只是过渡，百人百种起法\n\n -  进入A工程的branch1分支上\n - git pull \n   > 原因：拉取一下最新代码\n\n -  git checkout -b branchB1 \n > 原因：branchB1是基于A工程branch1开的新分支，代码跟A工程branch1一毛一样，**但是这个名字branchB1非常重要，非常重要**，原因只有一个：这个分支会被推到B工程，结果就是B工程下面就有这个分支。所以你懂的，万一你的B工程下面已经有了该分支名字，你这个做了好多工作的branchB1是根本推不上去的，是不是很疯狂\n\n - git push origin2\n \n > 结果：这一步能不能成功就看上一步，不多说，就看你取名字瞎不瞎\n\n\n如果上面的结束，说明已经成功迁移出一个分支了。常见问题：\n\n疑问1:问其他的分支怎么做，请重复\n - 进入A工程的branch2分支上\n - git pull \n - git checkout -b branchB2\n - git push origin2\nbranch2 变成branchB2然后被推到B仓库\n\n疑问2:你还问我第三个分支怎么迁移，不解释啦实在不行哎我还能说啥。\n\n疑问3: 我打眼一看B工程中的分支名字都是branchB1,branchB2....怎么破，\n改分支的名字直接登陆git.hub.com,打开工程你会看到branches这个，点进去可以修改.至于改名字，代码都迁移过去了，改个名字还很远吗\n\n<h2>情况2：</h2>\n**B仓库不是一个空仓库，里面各种各样乱七八糟的分支**。把A的branch1,branch2,branch3...一次迁入B，B也就有branch1,branch2,branch3,\n\n呃呃呃呃呃，\n步骤跟上面一毛一样，能不能推成功，就看你起名字的功夫了。什么名字，就是你最后要推到B工程上去的分支名字，注意在这里.\n\n\n\n\n\n\n \n","source":"_posts/git.md","raw":"\n---\ntitle: \"git新操作备注\"\ntags: \n\t- \"git\"\n---\n\n使用git进行工程的操作，长期下来git pull 、git add 、git push、就可以完成日常所需，但是近期有些其他的操作，记录下来都是亲身测试有效的\n\n<!-- more -->\n### 1.开个新分支\n（1）如果新建一个以develop内容为基础的分支\n\n - git checkout develop \n - git checkout -b yx0628develop_new\n\n不断修改不断的保存也是可以生成log的\n\n - git add .  //这是提交全部修改，慎重 \n - git commit -m'全部修改提交'\n\n（2）把新分支的代码合并到develop\n 前提：先把新分支yx0628develop_new的代码add完毕，commit完毕\n \n\n - git checkout develop  \n - git merge yx0628develop_new\n无冲突\n - git push \n有冲突\n - 解决冲突\n - git add 冲突文件\n - git commit -m'随便你想写什么'\n - git push\n\n###2.代码迁移仓库（保留log）\n不保留log等提交的记录的迁移就不说了，soeasy！\n目标：把A仓库的代码迁移到B仓库并且保存所有的git log，B仓库已经存在了哦，哪怕是个空仓库。\n\n再说这个之前先说点其他。在使用git的时候我们可能见到这样的命令。不想看解说想直接看步骤的，[直接步骤](#1)\n\n>     git pull origin master //拉取远程master分支的代码\n>     git push origin master //把代码推到远程master分支上去\n\n有没有人好奇为什么是origin，而不是其他名字，比如git pull orginal master或者git pull origin2 master;\n\n解答上面的问题很简单，请在你的工程中输入\n\n>     git remote\n发现了什么呢？默认就有一个origin，代表远程仓库。origin是有地址，地址就是当前仓库的git地址，是个url哦。所以为什么git push origin master就自动相应的推到的远程仓库的master分支了。\n\n\n<h2 id=\"1\">下面是正确的操作步骤，(看准情况分类很重要，就两种)</h2>\n不管哪种情况请从情况1开始看哈哈：\n\n<h2>情况1：</h2>\n**B仓库是一个空仓库，除了默认的master分支，没有任何分支**。把A的branch1,branch2,branch3...依次迁入B，B也就有branch1,branch2,branch3,\n\n - 进入A工程\n - git remote     \n    > 原因：看下当前远程仓库有啥名字，然后取个崭新的名字，不重复的名字，名字是过渡，不必纠结。这里取名origin2\n\n - git remote add origin2 master\n  > 不纠结照抄这就话\n - git remote set-url origin2 git@git.hub.com:B.git\n    > 原因：后面的B仓库地址url才是关键，origin2只是过渡，百人百种起法\n\n -  进入A工程的branch1分支上\n - git pull \n   > 原因：拉取一下最新代码\n\n -  git checkout -b branchB1 \n > 原因：branchB1是基于A工程branch1开的新分支，代码跟A工程branch1一毛一样，**但是这个名字branchB1非常重要，非常重要**，原因只有一个：这个分支会被推到B工程，结果就是B工程下面就有这个分支。所以你懂的，万一你的B工程下面已经有了该分支名字，你这个做了好多工作的branchB1是根本推不上去的，是不是很疯狂\n\n - git push origin2\n \n > 结果：这一步能不能成功就看上一步，不多说，就看你取名字瞎不瞎\n\n\n如果上面的结束，说明已经成功迁移出一个分支了。常见问题：\n\n疑问1:问其他的分支怎么做，请重复\n - 进入A工程的branch2分支上\n - git pull \n - git checkout -b branchB2\n - git push origin2\nbranch2 变成branchB2然后被推到B仓库\n\n疑问2:你还问我第三个分支怎么迁移，不解释啦实在不行哎我还能说啥。\n\n疑问3: 我打眼一看B工程中的分支名字都是branchB1,branchB2....怎么破，\n改分支的名字直接登陆git.hub.com,打开工程你会看到branches这个，点进去可以修改.至于改名字，代码都迁移过去了，改个名字还很远吗\n\n<h2>情况2：</h2>\n**B仓库不是一个空仓库，里面各种各样乱七八糟的分支**。把A的branch1,branch2,branch3...一次迁入B，B也就有branch1,branch2,branch3,\n\n呃呃呃呃呃，\n步骤跟上面一毛一样，能不能推成功，就看你起名字的功夫了。什么名字，就是你最后要推到B工程上去的分支名字，注意在这里.\n\n\n\n\n\n\n \n","slug":"git","published":1,"date":"2018-08-23T06:34:22.822Z","updated":"2018-08-27T08:05:00.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o50j0000vds630pt4y7a","content":"<p>使用git进行工程的操作，长期下来git pull 、git add 、git push、就可以完成日常所需，但是近期有些其他的操作，记录下来都是亲身测试有效的</p>\n<a id=\"more\"></a>\n<h3 id=\"1-开个新分支\"><a href=\"#1-开个新分支\" class=\"headerlink\" title=\"1.开个新分支\"></a>1.开个新分支</h3><p>（1）如果新建一个以develop内容为基础的分支</p>\n<ul>\n<li>git checkout develop </li>\n<li>git checkout -b yx0628develop_new</li>\n</ul>\n<p>不断修改不断的保存也是可以生成log的</p>\n<ul>\n<li>git add .  //这是提交全部修改，慎重 </li>\n<li>git commit -m’全部修改提交’</li>\n</ul>\n<p>（2）把新分支的代码合并到develop<br> 前提：先把新分支yx0628develop_new的代码add完毕，commit完毕</p>\n<ul>\n<li>git checkout develop  </li>\n<li>git merge yx0628develop_new<br>无冲突</li>\n<li>git push<br>有冲突</li>\n<li>解决冲突</li>\n<li>git add 冲突文件</li>\n<li>git commit -m’随便你想写什么’</li>\n<li>git push</li>\n</ul>\n<p>###2.代码迁移仓库（保留log）<br>不保留log等提交的记录的迁移就不说了，soeasy！<br>目标：把A仓库的代码迁移到B仓库并且保存所有的git log，B仓库已经存在了哦，哪怕是个空仓库。</p>\n<p>再说这个之前先说点其他。在使用git的时候我们可能见到这样的命令。不想看解说想直接看步骤的，<a href=\"#1\">直接步骤</a></p>\n<blockquote>\n<pre><code>git pull origin master //拉取远程master分支的代码\ngit push origin master //把代码推到远程master分支上去\n</code></pre></blockquote>\n<p>有没有人好奇为什么是origin，而不是其他名字，比如git pull orginal master或者git pull origin2 master;</p>\n<p>解答上面的问题很简单，请在你的工程中输入</p>\n<blockquote>\n<pre><code>git remote\n</code></pre><p>发现了什么呢？默认就有一个origin，代表远程仓库。origin是有地址，地址就是当前仓库的git地址，是个url哦。所以为什么git push origin master就自动相应的推到的远程仓库的master分支了。</p>\n</blockquote>\n<p></p><h2 id=\"1\">下面是正确的操作步骤，(看准情况分类很重要，就两种)</h2><br>不管哪种情况请从情况1开始看哈哈：<p></p>\n<p></p><h2>情况1：</h2><br><strong>B仓库是一个空仓库，除了默认的master分支，没有任何分支</strong>。把A的branch1,branch2,branch3…依次迁入B，B也就有branch1,branch2,branch3,<p></p>\n<ul>\n<li>进入A工程</li>\n<li><p>git remote     </p>\n<blockquote>\n<p>原因：看下当前远程仓库有啥名字，然后取个崭新的名字，不重复的名字，名字是过渡，不必纠结。这里取名origin2</p>\n</blockquote>\n</li>\n<li><p>git remote add origin2 master</p>\n<blockquote>\n<p>不纠结照抄这就话</p>\n</blockquote>\n</li>\n<li><p>git remote set-url origin2 <a href=\"mailto:git@git.hub.com\" target=\"_blank\" rel=\"noopener\">git@git.hub.com</a>:B.git</p>\n<blockquote>\n<p>原因：后面的B仓库地址url才是关键，origin2只是过渡，百人百种起法</p>\n</blockquote>\n</li>\n<li><p>进入A工程的branch1分支上</p>\n</li>\n<li><p>git pull </p>\n<blockquote>\n<p>原因：拉取一下最新代码</p>\n</blockquote>\n</li>\n<li><p>git checkout -b branchB1 </p>\n<blockquote>\n<p>原因：branchB1是基于A工程branch1开的新分支，代码跟A工程branch1一毛一样，<strong>但是这个名字branchB1非常重要，非常重要</strong>，原因只有一个：这个分支会被推到B工程，结果就是B工程下面就有这个分支。所以你懂的，万一你的B工程下面已经有了该分支名字，你这个做了好多工作的branchB1是根本推不上去的，是不是很疯狂</p>\n</blockquote>\n</li>\n<li><p>git push origin2</p>\n<blockquote>\n<p>结果：这一步能不能成功就看上一步，不多说，就看你取名字瞎不瞎</p>\n</blockquote>\n</li>\n</ul>\n<p>如果上面的结束，说明已经成功迁移出一个分支了。常见问题：</p>\n<p>疑问1:问其他的分支怎么做，请重复</p>\n<ul>\n<li>进入A工程的branch2分支上</li>\n<li>git pull </li>\n<li>git checkout -b branchB2</li>\n<li>git push origin2<br>branch2 变成branchB2然后被推到B仓库</li>\n</ul>\n<p>疑问2:你还问我第三个分支怎么迁移，不解释啦实在不行哎我还能说啥。</p>\n<p>疑问3: 我打眼一看B工程中的分支名字都是branchB1,branchB2….怎么破，<br>改分支的名字直接登陆git.hub.com,打开工程你会看到branches这个，点进去可以修改.至于改名字，代码都迁移过去了，改个名字还很远吗</p>\n<p></p><h2>情况2：</h2><br><strong>B仓库不是一个空仓库，里面各种各样乱七八糟的分支</strong>。把A的branch1,branch2,branch3…一次迁入B，B也就有branch1,branch2,branch3,<p></p>\n<p>呃呃呃呃呃，<br>步骤跟上面一毛一样，能不能推成功，就看你起名字的功夫了。什么名字，就是你最后要推到B工程上去的分支名字，注意在这里.</p>\n","site":{"data":{}},"excerpt":"<p>使用git进行工程的操作，长期下来git pull 、git add 、git push、就可以完成日常所需，但是近期有些其他的操作，记录下来都是亲身测试有效的</p>","more":"<h3 id=\"1-开个新分支\"><a href=\"#1-开个新分支\" class=\"headerlink\" title=\"1.开个新分支\"></a>1.开个新分支</h3><p>（1）如果新建一个以develop内容为基础的分支</p>\n<ul>\n<li>git checkout develop </li>\n<li>git checkout -b yx0628develop_new</li>\n</ul>\n<p>不断修改不断的保存也是可以生成log的</p>\n<ul>\n<li>git add .  //这是提交全部修改，慎重 </li>\n<li>git commit -m’全部修改提交’</li>\n</ul>\n<p>（2）把新分支的代码合并到develop<br> 前提：先把新分支yx0628develop_new的代码add完毕，commit完毕</p>\n<ul>\n<li>git checkout develop  </li>\n<li>git merge yx0628develop_new<br>无冲突</li>\n<li>git push<br>有冲突</li>\n<li>解决冲突</li>\n<li>git add 冲突文件</li>\n<li>git commit -m’随便你想写什么’</li>\n<li>git push</li>\n</ul>\n<p>###2.代码迁移仓库（保留log）<br>不保留log等提交的记录的迁移就不说了，soeasy！<br>目标：把A仓库的代码迁移到B仓库并且保存所有的git log，B仓库已经存在了哦，哪怕是个空仓库。</p>\n<p>再说这个之前先说点其他。在使用git的时候我们可能见到这样的命令。不想看解说想直接看步骤的，<a href=\"#1\">直接步骤</a></p>\n<blockquote>\n<pre><code>git pull origin master //拉取远程master分支的代码\ngit push origin master //把代码推到远程master分支上去\n</code></pre></blockquote>\n<p>有没有人好奇为什么是origin，而不是其他名字，比如git pull orginal master或者git pull origin2 master;</p>\n<p>解答上面的问题很简单，请在你的工程中输入</p>\n<blockquote>\n<pre><code>git remote\n</code></pre><p>发现了什么呢？默认就有一个origin，代表远程仓库。origin是有地址，地址就是当前仓库的git地址，是个url哦。所以为什么git push origin master就自动相应的推到的远程仓库的master分支了。</p>\n</blockquote>\n<p></p><h2 id=\"1\">下面是正确的操作步骤，(看准情况分类很重要，就两种)</h2><br>不管哪种情况请从情况1开始看哈哈：<p></p>\n<p></p><h2>情况1：</h2><br><strong>B仓库是一个空仓库，除了默认的master分支，没有任何分支</strong>。把A的branch1,branch2,branch3…依次迁入B，B也就有branch1,branch2,branch3,<p></p>\n<ul>\n<li>进入A工程</li>\n<li><p>git remote     </p>\n<blockquote>\n<p>原因：看下当前远程仓库有啥名字，然后取个崭新的名字，不重复的名字，名字是过渡，不必纠结。这里取名origin2</p>\n</blockquote>\n</li>\n<li><p>git remote add origin2 master</p>\n<blockquote>\n<p>不纠结照抄这就话</p>\n</blockquote>\n</li>\n<li><p>git remote set-url origin2 <a href=\"mailto:git@git.hub.com\" target=\"_blank\" rel=\"noopener\">git@git.hub.com</a>:B.git</p>\n<blockquote>\n<p>原因：后面的B仓库地址url才是关键，origin2只是过渡，百人百种起法</p>\n</blockquote>\n</li>\n<li><p>进入A工程的branch1分支上</p>\n</li>\n<li><p>git pull </p>\n<blockquote>\n<p>原因：拉取一下最新代码</p>\n</blockquote>\n</li>\n<li><p>git checkout -b branchB1 </p>\n<blockquote>\n<p>原因：branchB1是基于A工程branch1开的新分支，代码跟A工程branch1一毛一样，<strong>但是这个名字branchB1非常重要，非常重要</strong>，原因只有一个：这个分支会被推到B工程，结果就是B工程下面就有这个分支。所以你懂的，万一你的B工程下面已经有了该分支名字，你这个做了好多工作的branchB1是根本推不上去的，是不是很疯狂</p>\n</blockquote>\n</li>\n<li><p>git push origin2</p>\n<blockquote>\n<p>结果：这一步能不能成功就看上一步，不多说，就看你取名字瞎不瞎</p>\n</blockquote>\n</li>\n</ul>\n<p>如果上面的结束，说明已经成功迁移出一个分支了。常见问题：</p>\n<p>疑问1:问其他的分支怎么做，请重复</p>\n<ul>\n<li>进入A工程的branch2分支上</li>\n<li>git pull </li>\n<li>git checkout -b branchB2</li>\n<li>git push origin2<br>branch2 变成branchB2然后被推到B仓库</li>\n</ul>\n<p>疑问2:你还问我第三个分支怎么迁移，不解释啦实在不行哎我还能说啥。</p>\n<p>疑问3: 我打眼一看B工程中的分支名字都是branchB1,branchB2….怎么破，<br>改分支的名字直接登陆git.hub.com,打开工程你会看到branches这个，点进去可以修改.至于改名字，代码都迁移过去了，改个名字还很远吗</p>\n<p></p><h2>情况2：</h2><br><strong>B仓库不是一个空仓库，里面各种各样乱七八糟的分支</strong>。把A的branch1,branch2,branch3…一次迁入B，B也就有branch1,branch2,branch3,<p></p>\n<p>呃呃呃呃呃，<br>步骤跟上面一毛一样，能不能推成功，就看你起名字的功夫了。什么名字，就是你最后要推到B工程上去的分支名字，注意在这里.</p>"},{"title":"redux","date":"2018-08-24T02:00:30.000Z","_content":"\n\n\n有一篇redux的吐槽写的甚好，翻译一下\n---\n\n<!-- more -->\n## 1.前言\nmirror\nA simple and powerful React framework with minimal API and zero boilerplate. (Inspired by dva and jumpstate)\n一款简洁、高效、易上手的 React 框架。（Inspired by dva and jumpstate）\n\n> Painless React and Redux.\n> \n> Why?\n\nWe love React and Redux.\n我们热爱 React 和 Redux。\nA typical React/Redux app looks like the following:\n一个**典型的** React/Redux 应用看起来像下面这样：\n\n - An actions/ directory to manually create all action types (or action creators)\n>  \n>  一个 actions/ 目录用来手动创建所有的 action type（或者 action creator）\n\n - A reducers/ directory and tons of switch clause to capture all action types\n>  一个 reducers/ 目录和超级多的 switch语句 来捕获所有的 action type\n> \n - Apply middlewares to handle async actions\n>  必须要依赖 middleware 才能处理 异步 action；\n\n - Explicitly invoke dispatch method to dispatch all actions\n>    显示调用 dispatch 方法来 dispatch 所有的 action；\n\n - Manually create history to router and/or sync with store\n>  手动创建 history 对象关联路由组件，可能还需要与 store 同步；\n\n>  - Invoke methods in history or dispatch actions to programmatically changing routes\n调用 history 上的方法或者 dispatch action 来手动更新路由；\n  \nThe problem?  [Too much boilerplates](https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md) and a little bit tedious.\n\n存在的问题？太多的  [样板文件](https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md)以及繁琐甚至重复的劳动。\n\n\nIn fact, most part of the above steps could be simplified. Like, create actions and reducers in a single method, or dispatch both sync and async actions by simply invoking a function without extra middleware, or define routes without caring about history, etc.\n实际上，上述大部分操作都是可以简化的。比如，在单个 API 中创建所有的 action 和 reducer；比如，简单地调用一个函数来 dispatch 所有的同步和异步 action，且不需要额外引入 middleware；再比如，使用路由的时候只需要关心定义具体的路由，不用去关心 history 对象，等等。\n\nThat's exactly what Mirror does, encapsulates the tedious or repetitive work in very few APIs to offer a high level abstraction with efficiency and simplicity, and without breaking the pattern.\n这正是 Mirror 的使命，用极少数的 API 封装所有繁琐甚至重复的工作，提供一种简洁高效的更高级抽象，同时保持原有的开发模式。\n 2.超级重点，样板文件\n\n> 2-1 Actions\n\n> 2-2 Action Creators\n\n> 2-3 Generating Action Creators\n\n> 2-4 Async Action Creators\n\n> 2-5 Reducers\n\n> 2-6 Generating Reducers\n\n\n ### Reducing Boilerplate\n\n\n----------\n\n\nRedux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.\n\nRedux的部分是受Flux启发的，关于Flux最常见的抱怨就是它让你写出很多样板文件的。在下面的介绍中，我们将意识到Redux是如何让我们选择使用这种超级冗长的代码，当然这种选择也取决于个人风格、团队偏好、长期可维护性等等。\n\n 2-1 Actions\n\n----------\n\n\nActions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that actions being objects you have to dispatch is not boilerplate, but one of the fundamental design choices of Redux.\n\nActions是一个描述app中发生了什么的普通对象（变量），也是唯一一种方式来描述数据意图变化。\n要意识到是你必须dispatch的action，并不是无用的模板，而是redux基本设计规则\n\nThere are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement hot reloading with time travel. If you'd rather modify data directly, you don't need Redux.\n\n有些框架声称类似Flux，但是没有action概念。就可预测而言，这些框架相比Flux和react是一种倒退。如果没有action对象，是不可能记录和重演用户会话，也不可能实行热重载。如果你宁愿选择直接修改数据，则不需要使用Redux。\n\n> Actions look like this: \n\n> { type: 'ADD_TODO', text: 'Use Redux' } \n\n> {type: 'REMOVE_TODO', id: 42 } \n\n> { type: 'LOAD_ARTICLE', response: { ...} }\n\n\nIt is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not Symbols for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.\n\n约定习俗，actions有一个type（是个常量），目的为了帮助reducers（或者Stores in Flux）识别他们。我们建议将type定义成string类型或者不是symbols类型，因为strings are serializable,并且使用symbols类型会让你记录或者重演的行为变得更困难\n\nIn Flux, it is traditionally thought that you would define every action type as a string constant:\n\n> const ADD_TODO = 'ADD_TODO' \nconst REMOVE_TODO = 'REMOVE_TODO'\nconst LOAD_ARTICLE = 'LOAD_ARTICLE'\n\n在Flux，一般都会把type定义成一个字符串常量\n\nWhy is this beneficial? It is often claimed that constants are unnecessary, and for small projects, this might be correct. For larger projects, there are some benefits to defining action types as constants:\n\n为什么好呢？在小项目中，常量声明不是必须的，但是在大项目中，type定义成常量的好处如下：\n\n - It helps keep the naming consistent because all action types are gathered in a single place.\n\n> 它有助于保持命名的一致性，因为所有操作类型都集中在一个地方。\n\n - Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.\n   \n> 有时再添加新特性之前需要查看一下所有已存在的actions。也有可能你需要新增的action，你的队友已经添加但是你不知道\n\n- The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.\n   \n>   action的type列表，删除添加修改等操作很容易跟踪到\n\n- If you make a typo when importing an action constant, you will get undefined. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.\n\n> 当你引入一个action常量的时候出现书写错误，那么你会得到undefined。当dispatch这个action的时候，redux立即报出问题，你就会很快地发现问题。\n\nIt is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.\n\n这取决于你，在项目中使用约定习俗 。你可以使用inline strings, and later transition to constants 或者把他们都放入一个单独文件中。redux在这里没做任何要求。\n（把它们放入一个单独文件中使我们项目中使用方式，可见diwork的配图）\n\n 2-2 Action Creators\n\n\n----------\n\n\nIt is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.\n\n另外一个约定习俗是：不要在你要dispatch action的地方内联式地创建action，而是创建些生成他们的函数更好\n\nFor example, instead of calling dispatch with an object literal:\n\n比如不要dipatch一个字面量对象\n\n// somewhere in an event handler\n\n    dispatch({\n      type: 'ADD_TODO',\n      text: 'Use Redux'\n    })\n\nYou might write an action creator in a separate file, and import it into your component:\n你最好在一个独立文件中写个action creator，然后import进来\n\n    actionCreators.js\n    \n    export function addTodo(text) {\n      return {\n        type: 'ADD_TODO',\n        text\n      }\n    }\n\n    AddTodo.js\n    \n    import { addTodo } from './actionCreators'\n    \n    // somewhere in an event handler\n    dispatch(addTodo('Use Redux'))\n    \n> 其实action creators就是return 一个action(一个action表现形式是type+其他内容)。就是把action封装下，在action的周围可以加上其他逻辑，如下：\n\n\nAction creators have often been criticized as boilerplate. Well, you don't have to write them! You can use object literals if you feel this better suits your project. There are, however, some benefits for writing action creators you should know about.\n\nAction creator经常被批评为是模板文件。好吧，实际上你可以不写他们。如果你觉得合适，你可以使用字面量对象。但是关于action creator的好处你需要知道一下\n\nLet's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with redux-thunk middleware and adding an early exit:\n\n假设一个设计师在检查完原型之后回来告诉我们，我们需要允许最多三个任务。我们可以通过使用redux-thunk中间件将我们的action creator重写回调，并添加一个提前退出来实现这一点:\n\n    function addTodoWithoutCheck(text) {\n      return {\n        type: 'ADD_TODO',\n        text\n      }\n    }\n\n\n    export function addTodo(text) {\n      // This form is allowed by Redux Thunk middleware\n      // described below in “Async Action Creators” section.\n      return function (dispatch, getState) {\n        if (getState().todos.length === 3) {\n          // Exit early\n          return\n        }\n        dispatch(addTodoWithoutCheck(text))\n      }\n    }\n\nWe just modified how the addTodo action creator behaves, completely invisible to the calling code. We don't have to worry about looking at each place where todos are being added, to make sure they have this check. Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.\n\n我们只需要修改addTodo这个action creator，完全可以忽略调用这个函数的任何地方（因此不用找到所有调用这个函数的地方添加任何额外操作）。action creator把dispatch an action周围的附加逻辑与发出这些动作的实际组件分离开来。\n在繁重的开发阶段以及需求经常变动的情况下，这样开发变得非常敏捷\n\n 2-3 Generating Action Creators\n\n\n----------\n\n\nSome frameworks like Flummox generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define ADD_TODO constant and addTodo() action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.\n\n一些框架像Flummox可以通过action creator函数来生成action的type常量。这种想法意味着你不需要同时定义ADD_TODO 常量和 addTodo()这个 action creator。但是实质上还是需要生成action type常量，并且这种隐式创建会导致混淆。我们建议显式地创建action type\n\nWriting simple action creators can be tiresome and often ends up generating redundant boilerplate code:\n编写简单的action creator是非常累人的，并且常常会生成冗余的样板代码:\n\n    export function addTodo(text) {\n      return {\n        type: 'ADD_TODO',\n        text\n      }\n    }\n    \n    export function editTodo(id, text) {\n      return {\n        type: 'EDIT_TODO',\n        id,\n        text\n      }\n    }\n    \n    export function removeTodo(id) {\n      return {\n        type: 'REMOVE_TODO',\n        id\n      }\n    }\n\nYou can always write a function that generates an action creator:\n\n    function makeActionCreator(type, ...argNames) {\n      return function (...args) {\n        const action = { type }\n        argNames.forEach((arg, index) => {\n          action[argNames[index]] = args[index]\n        })\n        return action\n      }\n    }\n\n    const ADD_TODO = 'ADD_TODO'\n    const EDIT_TODO = 'EDIT_TODO'\n    const REMOVE_TODO = 'REMOVE_TODO'\n    \n    export const addTodo = makeActionCreator(ADD_TODO, 'text')\n    export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'text')\n    export const removeTodo = makeActionCreator(REMOVE_TODO, 'id')\n    //上面的这个函数会返回来\n    addTodo('hahah')\n    {type: \"ADD_TODO\", text: \"hahah\"}\n\n> 上面代码真的很不错，可以学习一下，闭包知识也有用到，type，argNames被保存了。注意返回的是一个函数\n\nThere are also utility libraries to aid in generating action creators, such as redux-act and redux-actions. These can help reduce boilerplate code and enforce adherence to standards such as Flux Standard Action (FSA).\n\n有一些公共库帮助生成action creators，比如redux-act 和redux-actions . 这样可以减少模板代码和强制遵循FSA规范\n\n\n 2-4 Async Action Creators\n\n\n----------\n\n\n异步的action creators\n\nMiddleware lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.\n\nMiddleware 允许您注入自定义逻辑在每个action对象中 before it is dispatched。异步操作是middleware最常见的用例。\n\nWithout any middleware, dispatch only accepts a plain object, so we have to perform AJAX calls inside our components:\n\n没有middleware，dispatch只接受普通对象，因此我们不得不在组件中执行AJAX调用:\n\n    actionCreators.js\n    \n    export function loadPostsSuccess(userId, response) {\n      return {\n        type: 'LOAD_POSTS_SUCCESS',\n        userId,\n        response\n      }\n    }\n    \n    export function loadPostsFailure(userId, error) {\n      return {\n        type: 'LOAD_POSTS_FAILURE',\n        userId,\n        error\n      }\n    }\n\n    export function loadPostsRequest(userId) {\n      return {\n        type: 'LOAD_POSTS_REQUEST',\n        userId\n      }\n    }\n\nUserInfo.js\n\n    import { Component } from 'react'\n    import { connect } from 'react-redux'\n    import {\n      loadPostsRequest,\n      loadPostsSuccess,\n      loadPostsFailure\n    } from './actionCreators'\n    \n    class Posts extends Component {\n      loadData(userId) {\n        // Injected into props by React Redux `connect()` call:\n        // 通过调用React Redux `connect()`注入了props\n        const { dispatch, posts } = this.props\n    \n        if (posts[userId]) {\n          // There is cached data! Don't do anything.\n          // 是否有缓存数据\n          return\n        }\n    \n        // Reducer can react to this action by setting\n        // `isFetching` and thus letting us show a spinner.\n        // 显示加载\n        dispatch(loadPostsRequest(userId))\n    \n        // Reducer can react to these actions by filling the\n        // `users`.\n        \n        fetch(`http://myapi.com/users/${userId}/posts`).then(\n          response => dispatch(loadPostsSuccess(userId, response)),\n          error => dispatch(loadPostsFailure(userId, error))\n        )\n      }\n    \n      componentDidMount() {\n        this.loadData(this.props.userId)\n      }\n    \n      componentWillReceiveProps(nextProps) {\n        if (nextProps.userId !== this.props.userId) {\n          this.loadData(nextProps.userId)\n        }\n      }\n    \n      render() {\n        if (this.props.isFetching) {\n          return <p>Loading...</p>\n        }\n    \n        const posts = this.props.posts.map(post =>\n          <Post post={post} key={post.id} />\n        )\n    \n        return <div>{posts}</div>\n      }\n    }\n    \n    export default connect(state => ({\n      posts: state.posts,\n      isFetching: state.isFetching\n    }))(Posts)\n\n\nHowever, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.\n\n然而这很快就会重复因为不同的组件使用相同api来请求数据，而且，我们希望重用许多组件中的一些逻辑（比如缓存数据存在的时候提前退出）\n（如果有多个组件，需要重写很多次fetch请求呢）\n\nMiddleware lets us write more expressive, potentially async action creators. It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.\n\nMiddleware使我们能够编写更有表现力的、潜在的异步action creator。它允许我们dispatch something 而不是普通对象，并interprets the values。例如，middleware可以“捕获”已发出的promise，并将它们转换为一对请求+成功/失败操作。\n\nThe simplest example of middleware is redux-thunk. “Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.\n\nmiddleware最简单的例子就是redux-thunk。thunk是允许你将action creators作为thunks，就是函数返回函数。这种反转控件，你可以将dispatch作为参数，因为写一个可以dispatch很多次的action creator\n\n> Note \n\n> Thunk middleware is just one example of middleware. Middleware is\n> not about “letting you dispatch functions”. It's about letting you\n> dispatch anything that the particular middleware you use knows how to\n> handle. Thunk middleware adds a specific behavior when you dispatch\n> functions, but it really depends on the middleware you use. Thunk\n\n> middleware只是一个简单例子，Middleware不是让你‘dispatch functions’。他是让你dispatch\n> 任何Middleware知道如何处理的事情。Thunk Middleware可以在你dispatch\n> functions之前添加一些特殊操作，不过这一切取决你你使用的Middleware\n\nConsider the code above rewritten with redux-thunk:\n\nactionCreators.js\n\n    export function loadPosts(userId) {\n      // Interpreted by the thunk middleware:\n      // 交给thunk Middleware 解释\n      return function (dispatch, getState) {\n        const { posts } = getState()\n        if (posts[userId]) {\n          // There is cached data! Don't do anything.\n          return\n        }\n    \n        dispatch({\n          type: 'LOAD_POSTS_REQUEST',\n          userId\n        })\n    \n        // Dispatch vanilla actions asynchronously\n        fetch(`http://myapi.com/users/${userId}/posts`).then(\n          response =>\n            dispatch({\n              type: 'LOAD_POSTS_SUCCESS',\n              userId,\n              response\n            }),\n          error =>\n            dispatch({\n              type: 'LOAD_POSTS_FAILURE',\n              userId,\n              error\n            })\n        )\n      }\n    }\n\nUserInfo.js\n\n    import { Component } from 'react'\n    import { connect } from 'react-redux'\n    import { loadPosts } from './actionCreators'\n    \n    class Posts extends Component {\n      componentDidMount() {\n        this.props.dispatch(loadPosts(this.props.userId))\n      }\n    \n      componentWillReceiveProps(nextProps) {\n        if (nextProps.userId !== this.props.userId) {\n          this.props.dispatch(loadPosts(nextProps.userId))\n        }\n      }\n    \n      render() {\n        if (this.props.isFetching) {\n          return <p>Loading...</p>\n        }\n    \n        const posts = this.props.posts.map(post =>\n          <Post post={post} key={post.id} />\n        )\n    \n        return <div>{posts}</div>\n      }\n    }\n    \n    export default connect(state => ({\n      posts: state.posts,\n      isFetching: state.isFetching\n    }))(Posts)\n\nThis is much less typing! If you'd like, you can still have “vanilla” action creators like loadPostsSuccess which you'd use from a container loadPosts action creator.\n\n更少的书写。如果你喜欢，你可以有vanilla action creators，如loadPostsSuccess\n（其实就是把第一个UserInfo.js中loadData提出来加工一下改为loadPosts）\n\nFinally, you can write your own middleware. Let's say you want to generalize the pattern above and describe your async action creators like this instead:\n最后你可以编写自己的Middleware。如果你想要推广上面的模式，可以这样的描述你的异步action creators\n\n    export function loadPosts(userId) {\n      return {\n      \n        // Types of actions to emit before and after定义Types\n        types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n        \n        // Check the cache (optional):检查缓存\n        shouldCallAPI: state => !state.posts[userId],\n       \n        // Perform the fetching:执行fetch\n        callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),\n        // Arguments to inject in begin/end actions 参数注入在开始或者结束的actions\n        payload: { userId }\n      }\n    }\n\n\nThe middleware that interprets such actions could look like this:\n\nMiddleware这样定义actions\n\n    function callAPIMiddleware({ dispatch, getState }) {\n      return next => action => {\n        const {\n          types,\n          callAPI,\n          shouldCallAPI = () => true,\n          payload = {}\n        } = action\n    \n        if (!types) {\n          // Normal action: pass it on\n          return next(action)\n        }\n    \n        if (\n          !Array.isArray(types) ||\n          types.length !== 3 ||\n          !types.every(type => typeof type === 'string')\n        ) {\n          throw new Error('Expected an array of three string types.')\n        }\n    \n        if (typeof callAPI !== 'function') {\n          throw new Error('Expected callAPI to be a function.')\n        }\n    \n        if (!shouldCallAPI(getState())) {\n          return\n        }\n    \n        const [requestType, successType, failureType] = types\n    \n        dispatch(\n          Object.assign({}, payload, {\n            type: requestType\n          })\n        )\n    \n        return callAPI().then(\n          response =>\n            dispatch(\n              Object.assign({}, payload, {\n                response,\n                type: successType\n              })\n            ),\n          error =>\n            dispatch(\n              Object.assign({}, payload, {\n                error,\n                type: failureType\n              })\n            )\n        )\n      }\n    }\n\nAfter passing it once to applyMiddleware(...middlewares), you can write all your API-calling action creators the same way:\n\n只要使用一次applyMiddleware(...middlewares), 您可以用同样的方式编写所有api调用的action creators\n\n\n    export function loadPosts(userId) {\n      return {\n        types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n        shouldCallAPI: state => !state.posts[userId],\n        callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),\n        payload: { userId }\n      }\n    }\n    \n    export function loadComments(postId) {\n      return {\n        types: [\n          'LOAD_COMMENTS_REQUEST',\n          'LOAD_COMMENTS_SUCCESS',\n          'LOAD_COMMENTS_FAILURE'\n        ],\n        shouldCallAPI: state => !state.comments[postId],\n        callAPI: () => fetch(`http://myapi.com/posts/${postId}/comments`),\n        payload: { postId }\n      }\n    }\n    \n    export function addComment(postId, message) {\n      return {\n        types: [\n          'ADD_COMMENT_REQUEST',\n          'ADD_COMMENT_SUCCESS',\n          'ADD_COMMENT_FAILURE'\n        ],\n        callAPI: () =>\n          fetch(`http://myapi.com/posts/${postId}/comments`, {\n            method: 'post',\n            headers: {\n              Accept: 'application/json',\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ message })\n          }),\n        payload: { postId, message }\n      }\n    }\n\n\n 2-5 Reducers\n\n\n----------\n\n\nRedux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.\n\nRedux通过将更新逻辑描述为函数，大大减少了Flux样板。函数比对象简单，比类简单得多。\n\nConsider this Flux store:\n\n    const _todos = []\n    \n    const TodoStore = Object.assign({}, EventEmitter.prototype, {\n      getAll() {\n        return _todos\n      }\n    })\n    \n    AppDispatcher.register(function (action) {\n      switch (action.type) {\n        case ActionTypes.ADD_TODO:\n          const text = action.text.trim()\n          _todos.push(text)\n          TodoStore.emitChange()\n      }\n    })\n\n    export default TodoStore\n\n\nWith Redux, the same update logic can be described as a reducing function:\n\n    export function todos(state = [], action) {\n      switch (action.type) {\n        case ActionTypes.ADD_TODO:\n          const text = action.text.trim()\n          return [...state, text]\n        default:\n          return state\n      }\n    }\n\nThe switch statement is not the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app)。\n\n这是对Flux的解析：\nSwitch语句不是真正冗余，Flux真正冗余的是概念：\n需要emit an update\n需要用一个dispatcher来注册store（就是store需要被注册在一个dispatcher上）\n需要store是个对象（当你想要一个通用app的时候这就会非常的复杂）\n\nIt's unfortunate that many still choose Flux framework based on whether it uses switch statements in the documentation. If you don't like switch, you can solve this with a single function, as we show below.\n愚蠢的是，许多人仍然根据文档中是否使用switch语句来选择Flux框架。如果您不喜欢switch，可以使用一个函数来解决这个问题，如下所示。\n\n 2-6 Generating Reducers\n\n\n----------\n\n\nLet's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our todos reducers to be defined like this:\n\n让我们编写一个函数，让我们将reducers表述为一个对象映射，映射关系是action type 映射到 handlers。例如，如果我们希望我们的todos是这样定义的:\n\n    export const todos = createReducer([], {\n      [ActionTypes.ADD_TODO]: (state, action) => {\n        const text = action.text.trim()\n        return [...state, text]\n      }\n    })\n\n越来越像我们项目中用到了\n这种映射关系去掉了switch\nWe can write the following helper to accomplish this:\n可以使用下面的帮助来完成\n\n    function createReducer(initialState, handlers) {\n      return function reducer(state = initialState, action) {\n        if (handlers.hasOwnProperty(action.type)) {\n          return handlers[action.type](state, action)\n        } else {\n          return state\n        }\n      }\n    }\n\n\nThis wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.\nThe Redux reducer API is (state, action) => newState, but how you create those reducers is up to you.\n\n这并不难，不是吗?\n\nRedux默认情况下不提供这样的帮助helper，因为有很多方法可以编写它。也许您希望它自动将普通JS对象转换为不可变对象，以适应服务器状态。也许您希望将返回的状态与当前状态合并。也有很多不同的方式来使用‘catch all’handler。所有这些都取决于您根据特定项目中选择的约定。\n\nRedux reducer API是(state, action) => newState，但是如何创建这些reducer取决于您。\n\n> action 、 action creators 、 reducer 的区别\n\n> action  = type + new value\n\n> action creators = logic + action\n\n> reducer = state +  action creators\n\n\n 3.diwork\ndiwork工作台的redux如下\n\n\n  [单页中完整redux分成四个文件]: https://raw.githubusercontent.com/XYooo/image/master/redux2@2x.png\n  [actions目录]: https://raw.githubusercontent.com/XYooo/image/master/redux3@2x.png\n  [reducer目录]: https://raw.githubusercontent.com/XYooo/image/master/redux4@2x.png\n\n\n\n\n\n","source":"_posts/redux.md","raw":"---\ntitle: redux\ndate: 2018-08-24 10:00:30\ntags:\n---\n\n\n\n有一篇redux的吐槽写的甚好，翻译一下\n---\n\n<!-- more -->\n## 1.前言\nmirror\nA simple and powerful React framework with minimal API and zero boilerplate. (Inspired by dva and jumpstate)\n一款简洁、高效、易上手的 React 框架。（Inspired by dva and jumpstate）\n\n> Painless React and Redux.\n> \n> Why?\n\nWe love React and Redux.\n我们热爱 React 和 Redux。\nA typical React/Redux app looks like the following:\n一个**典型的** React/Redux 应用看起来像下面这样：\n\n - An actions/ directory to manually create all action types (or action creators)\n>  \n>  一个 actions/ 目录用来手动创建所有的 action type（或者 action creator）\n\n - A reducers/ directory and tons of switch clause to capture all action types\n>  一个 reducers/ 目录和超级多的 switch语句 来捕获所有的 action type\n> \n - Apply middlewares to handle async actions\n>  必须要依赖 middleware 才能处理 异步 action；\n\n - Explicitly invoke dispatch method to dispatch all actions\n>    显示调用 dispatch 方法来 dispatch 所有的 action；\n\n - Manually create history to router and/or sync with store\n>  手动创建 history 对象关联路由组件，可能还需要与 store 同步；\n\n>  - Invoke methods in history or dispatch actions to programmatically changing routes\n调用 history 上的方法或者 dispatch action 来手动更新路由；\n  \nThe problem?  [Too much boilerplates](https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md) and a little bit tedious.\n\n存在的问题？太多的  [样板文件](https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md)以及繁琐甚至重复的劳动。\n\n\nIn fact, most part of the above steps could be simplified. Like, create actions and reducers in a single method, or dispatch both sync and async actions by simply invoking a function without extra middleware, or define routes without caring about history, etc.\n实际上，上述大部分操作都是可以简化的。比如，在单个 API 中创建所有的 action 和 reducer；比如，简单地调用一个函数来 dispatch 所有的同步和异步 action，且不需要额外引入 middleware；再比如，使用路由的时候只需要关心定义具体的路由，不用去关心 history 对象，等等。\n\nThat's exactly what Mirror does, encapsulates the tedious or repetitive work in very few APIs to offer a high level abstraction with efficiency and simplicity, and without breaking the pattern.\n这正是 Mirror 的使命，用极少数的 API 封装所有繁琐甚至重复的工作，提供一种简洁高效的更高级抽象，同时保持原有的开发模式。\n 2.超级重点，样板文件\n\n> 2-1 Actions\n\n> 2-2 Action Creators\n\n> 2-3 Generating Action Creators\n\n> 2-4 Async Action Creators\n\n> 2-5 Reducers\n\n> 2-6 Generating Reducers\n\n\n ### Reducing Boilerplate\n\n\n----------\n\n\nRedux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.\n\nRedux的部分是受Flux启发的，关于Flux最常见的抱怨就是它让你写出很多样板文件的。在下面的介绍中，我们将意识到Redux是如何让我们选择使用这种超级冗长的代码，当然这种选择也取决于个人风格、团队偏好、长期可维护性等等。\n\n 2-1 Actions\n\n----------\n\n\nActions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that actions being objects you have to dispatch is not boilerplate, but one of the fundamental design choices of Redux.\n\nActions是一个描述app中发生了什么的普通对象（变量），也是唯一一种方式来描述数据意图变化。\n要意识到是你必须dispatch的action，并不是无用的模板，而是redux基本设计规则\n\nThere are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement hot reloading with time travel. If you'd rather modify data directly, you don't need Redux.\n\n有些框架声称类似Flux，但是没有action概念。就可预测而言，这些框架相比Flux和react是一种倒退。如果没有action对象，是不可能记录和重演用户会话，也不可能实行热重载。如果你宁愿选择直接修改数据，则不需要使用Redux。\n\n> Actions look like this: \n\n> { type: 'ADD_TODO', text: 'Use Redux' } \n\n> {type: 'REMOVE_TODO', id: 42 } \n\n> { type: 'LOAD_ARTICLE', response: { ...} }\n\n\nIt is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not Symbols for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.\n\n约定习俗，actions有一个type（是个常量），目的为了帮助reducers（或者Stores in Flux）识别他们。我们建议将type定义成string类型或者不是symbols类型，因为strings are serializable,并且使用symbols类型会让你记录或者重演的行为变得更困难\n\nIn Flux, it is traditionally thought that you would define every action type as a string constant:\n\n> const ADD_TODO = 'ADD_TODO' \nconst REMOVE_TODO = 'REMOVE_TODO'\nconst LOAD_ARTICLE = 'LOAD_ARTICLE'\n\n在Flux，一般都会把type定义成一个字符串常量\n\nWhy is this beneficial? It is often claimed that constants are unnecessary, and for small projects, this might be correct. For larger projects, there are some benefits to defining action types as constants:\n\n为什么好呢？在小项目中，常量声明不是必须的，但是在大项目中，type定义成常量的好处如下：\n\n - It helps keep the naming consistent because all action types are gathered in a single place.\n\n> 它有助于保持命名的一致性，因为所有操作类型都集中在一个地方。\n\n - Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know.\n   \n> 有时再添加新特性之前需要查看一下所有已存在的actions。也有可能你需要新增的action，你的队友已经添加但是你不知道\n\n- The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.\n   \n>   action的type列表，删除添加修改等操作很容易跟踪到\n\n- If you make a typo when importing an action constant, you will get undefined. Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner.\n\n> 当你引入一个action常量的时候出现书写错误，那么你会得到undefined。当dispatch这个action的时候，redux立即报出问题，你就会很快地发现问题。\n\nIt is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.\n\n这取决于你，在项目中使用约定习俗 。你可以使用inline strings, and later transition to constants 或者把他们都放入一个单独文件中。redux在这里没做任何要求。\n（把它们放入一个单独文件中使我们项目中使用方式，可见diwork的配图）\n\n 2-2 Action Creators\n\n\n----------\n\n\nIt is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.\n\n另外一个约定习俗是：不要在你要dispatch action的地方内联式地创建action，而是创建些生成他们的函数更好\n\nFor example, instead of calling dispatch with an object literal:\n\n比如不要dipatch一个字面量对象\n\n// somewhere in an event handler\n\n    dispatch({\n      type: 'ADD_TODO',\n      text: 'Use Redux'\n    })\n\nYou might write an action creator in a separate file, and import it into your component:\n你最好在一个独立文件中写个action creator，然后import进来\n\n    actionCreators.js\n    \n    export function addTodo(text) {\n      return {\n        type: 'ADD_TODO',\n        text\n      }\n    }\n\n    AddTodo.js\n    \n    import { addTodo } from './actionCreators'\n    \n    // somewhere in an event handler\n    dispatch(addTodo('Use Redux'))\n    \n> 其实action creators就是return 一个action(一个action表现形式是type+其他内容)。就是把action封装下，在action的周围可以加上其他逻辑，如下：\n\n\nAction creators have often been criticized as boilerplate. Well, you don't have to write them! You can use object literals if you feel this better suits your project. There are, however, some benefits for writing action creators you should know about.\n\nAction creator经常被批评为是模板文件。好吧，实际上你可以不写他们。如果你觉得合适，你可以使用字面量对象。但是关于action creator的好处你需要知道一下\n\nLet's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with redux-thunk middleware and adding an early exit:\n\n假设一个设计师在检查完原型之后回来告诉我们，我们需要允许最多三个任务。我们可以通过使用redux-thunk中间件将我们的action creator重写回调，并添加一个提前退出来实现这一点:\n\n    function addTodoWithoutCheck(text) {\n      return {\n        type: 'ADD_TODO',\n        text\n      }\n    }\n\n\n    export function addTodo(text) {\n      // This form is allowed by Redux Thunk middleware\n      // described below in “Async Action Creators” section.\n      return function (dispatch, getState) {\n        if (getState().todos.length === 3) {\n          // Exit early\n          return\n        }\n        dispatch(addTodoWithoutCheck(text))\n      }\n    }\n\nWe just modified how the addTodo action creator behaves, completely invisible to the calling code. We don't have to worry about looking at each place where todos are being added, to make sure they have this check. Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often.\n\n我们只需要修改addTodo这个action creator，完全可以忽略调用这个函数的任何地方（因此不用找到所有调用这个函数的地方添加任何额外操作）。action creator把dispatch an action周围的附加逻辑与发出这些动作的实际组件分离开来。\n在繁重的开发阶段以及需求经常变动的情况下，这样开发变得非常敏捷\n\n 2-3 Generating Action Creators\n\n\n----------\n\n\nSome frameworks like Flummox generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define ADD_TODO constant and addTodo() action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.\n\n一些框架像Flummox可以通过action creator函数来生成action的type常量。这种想法意味着你不需要同时定义ADD_TODO 常量和 addTodo()这个 action creator。但是实质上还是需要生成action type常量，并且这种隐式创建会导致混淆。我们建议显式地创建action type\n\nWriting simple action creators can be tiresome and often ends up generating redundant boilerplate code:\n编写简单的action creator是非常累人的，并且常常会生成冗余的样板代码:\n\n    export function addTodo(text) {\n      return {\n        type: 'ADD_TODO',\n        text\n      }\n    }\n    \n    export function editTodo(id, text) {\n      return {\n        type: 'EDIT_TODO',\n        id,\n        text\n      }\n    }\n    \n    export function removeTodo(id) {\n      return {\n        type: 'REMOVE_TODO',\n        id\n      }\n    }\n\nYou can always write a function that generates an action creator:\n\n    function makeActionCreator(type, ...argNames) {\n      return function (...args) {\n        const action = { type }\n        argNames.forEach((arg, index) => {\n          action[argNames[index]] = args[index]\n        })\n        return action\n      }\n    }\n\n    const ADD_TODO = 'ADD_TODO'\n    const EDIT_TODO = 'EDIT_TODO'\n    const REMOVE_TODO = 'REMOVE_TODO'\n    \n    export const addTodo = makeActionCreator(ADD_TODO, 'text')\n    export const editTodo = makeActionCreator(EDIT_TODO, 'id', 'text')\n    export const removeTodo = makeActionCreator(REMOVE_TODO, 'id')\n    //上面的这个函数会返回来\n    addTodo('hahah')\n    {type: \"ADD_TODO\", text: \"hahah\"}\n\n> 上面代码真的很不错，可以学习一下，闭包知识也有用到，type，argNames被保存了。注意返回的是一个函数\n\nThere are also utility libraries to aid in generating action creators, such as redux-act and redux-actions. These can help reduce boilerplate code and enforce adherence to standards such as Flux Standard Action (FSA).\n\n有一些公共库帮助生成action creators，比如redux-act 和redux-actions . 这样可以减少模板代码和强制遵循FSA规范\n\n\n 2-4 Async Action Creators\n\n\n----------\n\n\n异步的action creators\n\nMiddleware lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.\n\nMiddleware 允许您注入自定义逻辑在每个action对象中 before it is dispatched。异步操作是middleware最常见的用例。\n\nWithout any middleware, dispatch only accepts a plain object, so we have to perform AJAX calls inside our components:\n\n没有middleware，dispatch只接受普通对象，因此我们不得不在组件中执行AJAX调用:\n\n    actionCreators.js\n    \n    export function loadPostsSuccess(userId, response) {\n      return {\n        type: 'LOAD_POSTS_SUCCESS',\n        userId,\n        response\n      }\n    }\n    \n    export function loadPostsFailure(userId, error) {\n      return {\n        type: 'LOAD_POSTS_FAILURE',\n        userId,\n        error\n      }\n    }\n\n    export function loadPostsRequest(userId) {\n      return {\n        type: 'LOAD_POSTS_REQUEST',\n        userId\n      }\n    }\n\nUserInfo.js\n\n    import { Component } from 'react'\n    import { connect } from 'react-redux'\n    import {\n      loadPostsRequest,\n      loadPostsSuccess,\n      loadPostsFailure\n    } from './actionCreators'\n    \n    class Posts extends Component {\n      loadData(userId) {\n        // Injected into props by React Redux `connect()` call:\n        // 通过调用React Redux `connect()`注入了props\n        const { dispatch, posts } = this.props\n    \n        if (posts[userId]) {\n          // There is cached data! Don't do anything.\n          // 是否有缓存数据\n          return\n        }\n    \n        // Reducer can react to this action by setting\n        // `isFetching` and thus letting us show a spinner.\n        // 显示加载\n        dispatch(loadPostsRequest(userId))\n    \n        // Reducer can react to these actions by filling the\n        // `users`.\n        \n        fetch(`http://myapi.com/users/${userId}/posts`).then(\n          response => dispatch(loadPostsSuccess(userId, response)),\n          error => dispatch(loadPostsFailure(userId, error))\n        )\n      }\n    \n      componentDidMount() {\n        this.loadData(this.props.userId)\n      }\n    \n      componentWillReceiveProps(nextProps) {\n        if (nextProps.userId !== this.props.userId) {\n          this.loadData(nextProps.userId)\n        }\n      }\n    \n      render() {\n        if (this.props.isFetching) {\n          return <p>Loading...</p>\n        }\n    \n        const posts = this.props.posts.map(post =>\n          <Post post={post} key={post.id} />\n        )\n    \n        return <div>{posts}</div>\n      }\n    }\n    \n    export default connect(state => ({\n      posts: state.posts,\n      isFetching: state.isFetching\n    }))(Posts)\n\n\nHowever, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.\n\n然而这很快就会重复因为不同的组件使用相同api来请求数据，而且，我们希望重用许多组件中的一些逻辑（比如缓存数据存在的时候提前退出）\n（如果有多个组件，需要重写很多次fetch请求呢）\n\nMiddleware lets us write more expressive, potentially async action creators. It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.\n\nMiddleware使我们能够编写更有表现力的、潜在的异步action creator。它允许我们dispatch something 而不是普通对象，并interprets the values。例如，middleware可以“捕获”已发出的promise，并将它们转换为一对请求+成功/失败操作。\n\nThe simplest example of middleware is redux-thunk. “Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.\n\nmiddleware最简单的例子就是redux-thunk。thunk是允许你将action creators作为thunks，就是函数返回函数。这种反转控件，你可以将dispatch作为参数，因为写一个可以dispatch很多次的action creator\n\n> Note \n\n> Thunk middleware is just one example of middleware. Middleware is\n> not about “letting you dispatch functions”. It's about letting you\n> dispatch anything that the particular middleware you use knows how to\n> handle. Thunk middleware adds a specific behavior when you dispatch\n> functions, but it really depends on the middleware you use. Thunk\n\n> middleware只是一个简单例子，Middleware不是让你‘dispatch functions’。他是让你dispatch\n> 任何Middleware知道如何处理的事情。Thunk Middleware可以在你dispatch\n> functions之前添加一些特殊操作，不过这一切取决你你使用的Middleware\n\nConsider the code above rewritten with redux-thunk:\n\nactionCreators.js\n\n    export function loadPosts(userId) {\n      // Interpreted by the thunk middleware:\n      // 交给thunk Middleware 解释\n      return function (dispatch, getState) {\n        const { posts } = getState()\n        if (posts[userId]) {\n          // There is cached data! Don't do anything.\n          return\n        }\n    \n        dispatch({\n          type: 'LOAD_POSTS_REQUEST',\n          userId\n        })\n    \n        // Dispatch vanilla actions asynchronously\n        fetch(`http://myapi.com/users/${userId}/posts`).then(\n          response =>\n            dispatch({\n              type: 'LOAD_POSTS_SUCCESS',\n              userId,\n              response\n            }),\n          error =>\n            dispatch({\n              type: 'LOAD_POSTS_FAILURE',\n              userId,\n              error\n            })\n        )\n      }\n    }\n\nUserInfo.js\n\n    import { Component } from 'react'\n    import { connect } from 'react-redux'\n    import { loadPosts } from './actionCreators'\n    \n    class Posts extends Component {\n      componentDidMount() {\n        this.props.dispatch(loadPosts(this.props.userId))\n      }\n    \n      componentWillReceiveProps(nextProps) {\n        if (nextProps.userId !== this.props.userId) {\n          this.props.dispatch(loadPosts(nextProps.userId))\n        }\n      }\n    \n      render() {\n        if (this.props.isFetching) {\n          return <p>Loading...</p>\n        }\n    \n        const posts = this.props.posts.map(post =>\n          <Post post={post} key={post.id} />\n        )\n    \n        return <div>{posts}</div>\n      }\n    }\n    \n    export default connect(state => ({\n      posts: state.posts,\n      isFetching: state.isFetching\n    }))(Posts)\n\nThis is much less typing! If you'd like, you can still have “vanilla” action creators like loadPostsSuccess which you'd use from a container loadPosts action creator.\n\n更少的书写。如果你喜欢，你可以有vanilla action creators，如loadPostsSuccess\n（其实就是把第一个UserInfo.js中loadData提出来加工一下改为loadPosts）\n\nFinally, you can write your own middleware. Let's say you want to generalize the pattern above and describe your async action creators like this instead:\n最后你可以编写自己的Middleware。如果你想要推广上面的模式，可以这样的描述你的异步action creators\n\n    export function loadPosts(userId) {\n      return {\n      \n        // Types of actions to emit before and after定义Types\n        types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n        \n        // Check the cache (optional):检查缓存\n        shouldCallAPI: state => !state.posts[userId],\n       \n        // Perform the fetching:执行fetch\n        callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),\n        // Arguments to inject in begin/end actions 参数注入在开始或者结束的actions\n        payload: { userId }\n      }\n    }\n\n\nThe middleware that interprets such actions could look like this:\n\nMiddleware这样定义actions\n\n    function callAPIMiddleware({ dispatch, getState }) {\n      return next => action => {\n        const {\n          types,\n          callAPI,\n          shouldCallAPI = () => true,\n          payload = {}\n        } = action\n    \n        if (!types) {\n          // Normal action: pass it on\n          return next(action)\n        }\n    \n        if (\n          !Array.isArray(types) ||\n          types.length !== 3 ||\n          !types.every(type => typeof type === 'string')\n        ) {\n          throw new Error('Expected an array of three string types.')\n        }\n    \n        if (typeof callAPI !== 'function') {\n          throw new Error('Expected callAPI to be a function.')\n        }\n    \n        if (!shouldCallAPI(getState())) {\n          return\n        }\n    \n        const [requestType, successType, failureType] = types\n    \n        dispatch(\n          Object.assign({}, payload, {\n            type: requestType\n          })\n        )\n    \n        return callAPI().then(\n          response =>\n            dispatch(\n              Object.assign({}, payload, {\n                response,\n                type: successType\n              })\n            ),\n          error =>\n            dispatch(\n              Object.assign({}, payload, {\n                error,\n                type: failureType\n              })\n            )\n        )\n      }\n    }\n\nAfter passing it once to applyMiddleware(...middlewares), you can write all your API-calling action creators the same way:\n\n只要使用一次applyMiddleware(...middlewares), 您可以用同样的方式编写所有api调用的action creators\n\n\n    export function loadPosts(userId) {\n      return {\n        types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n        shouldCallAPI: state => !state.posts[userId],\n        callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),\n        payload: { userId }\n      }\n    }\n    \n    export function loadComments(postId) {\n      return {\n        types: [\n          'LOAD_COMMENTS_REQUEST',\n          'LOAD_COMMENTS_SUCCESS',\n          'LOAD_COMMENTS_FAILURE'\n        ],\n        shouldCallAPI: state => !state.comments[postId],\n        callAPI: () => fetch(`http://myapi.com/posts/${postId}/comments`),\n        payload: { postId }\n      }\n    }\n    \n    export function addComment(postId, message) {\n      return {\n        types: [\n          'ADD_COMMENT_REQUEST',\n          'ADD_COMMENT_SUCCESS',\n          'ADD_COMMENT_FAILURE'\n        ],\n        callAPI: () =>\n          fetch(`http://myapi.com/posts/${postId}/comments`, {\n            method: 'post',\n            headers: {\n              Accept: 'application/json',\n              'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({ message })\n          }),\n        payload: { postId, message }\n      }\n    }\n\n\n 2-5 Reducers\n\n\n----------\n\n\nRedux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.\n\nRedux通过将更新逻辑描述为函数，大大减少了Flux样板。函数比对象简单，比类简单得多。\n\nConsider this Flux store:\n\n    const _todos = []\n    \n    const TodoStore = Object.assign({}, EventEmitter.prototype, {\n      getAll() {\n        return _todos\n      }\n    })\n    \n    AppDispatcher.register(function (action) {\n      switch (action.type) {\n        case ActionTypes.ADD_TODO:\n          const text = action.text.trim()\n          _todos.push(text)\n          TodoStore.emitChange()\n      }\n    })\n\n    export default TodoStore\n\n\nWith Redux, the same update logic can be described as a reducing function:\n\n    export function todos(state = [], action) {\n      switch (action.type) {\n        case ActionTypes.ADD_TODO:\n          const text = action.text.trim()\n          return [...state, text]\n        default:\n          return state\n      }\n    }\n\nThe switch statement is not the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app)。\n\n这是对Flux的解析：\nSwitch语句不是真正冗余，Flux真正冗余的是概念：\n需要emit an update\n需要用一个dispatcher来注册store（就是store需要被注册在一个dispatcher上）\n需要store是个对象（当你想要一个通用app的时候这就会非常的复杂）\n\nIt's unfortunate that many still choose Flux framework based on whether it uses switch statements in the documentation. If you don't like switch, you can solve this with a single function, as we show below.\n愚蠢的是，许多人仍然根据文档中是否使用switch语句来选择Flux框架。如果您不喜欢switch，可以使用一个函数来解决这个问题，如下所示。\n\n 2-6 Generating Reducers\n\n\n----------\n\n\nLet's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our todos reducers to be defined like this:\n\n让我们编写一个函数，让我们将reducers表述为一个对象映射，映射关系是action type 映射到 handlers。例如，如果我们希望我们的todos是这样定义的:\n\n    export const todos = createReducer([], {\n      [ActionTypes.ADD_TODO]: (state, action) => {\n        const text = action.text.trim()\n        return [...state, text]\n      }\n    })\n\n越来越像我们项目中用到了\n这种映射关系去掉了switch\nWe can write the following helper to accomplish this:\n可以使用下面的帮助来完成\n\n    function createReducer(initialState, handlers) {\n      return function reducer(state = initialState, action) {\n        if (handlers.hasOwnProperty(action.type)) {\n          return handlers[action.type](state, action)\n        } else {\n          return state\n        }\n      }\n    }\n\n\nThis wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.\nThe Redux reducer API is (state, action) => newState, but how you create those reducers is up to you.\n\n这并不难，不是吗?\n\nRedux默认情况下不提供这样的帮助helper，因为有很多方法可以编写它。也许您希望它自动将普通JS对象转换为不可变对象，以适应服务器状态。也许您希望将返回的状态与当前状态合并。也有很多不同的方式来使用‘catch all’handler。所有这些都取决于您根据特定项目中选择的约定。\n\nRedux reducer API是(state, action) => newState，但是如何创建这些reducer取决于您。\n\n> action 、 action creators 、 reducer 的区别\n\n> action  = type + new value\n\n> action creators = logic + action\n\n> reducer = state +  action creators\n\n\n 3.diwork\ndiwork工作台的redux如下\n\n\n  [单页中完整redux分成四个文件]: https://raw.githubusercontent.com/XYooo/image/master/redux2@2x.png\n  [actions目录]: https://raw.githubusercontent.com/XYooo/image/master/redux3@2x.png\n  [reducer目录]: https://raw.githubusercontent.com/XYooo/image/master/redux4@2x.png\n\n\n\n\n\n","slug":"redux","published":1,"updated":"2018-08-24T05:55:46.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o50p0002vds67g44oqhg","content":"<h2 id=\"有一篇redux的吐槽写的甚好，翻译一下\"><a href=\"#有一篇redux的吐槽写的甚好，翻译一下\" class=\"headerlink\" title=\"有一篇redux的吐槽写的甚好，翻译一下\"></a>有一篇redux的吐槽写的甚好，翻译一下</h2><a id=\"more\"></a>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>mirror<br>A simple and powerful React framework with minimal API and zero boilerplate. (Inspired by dva and jumpstate)<br>一款简洁、高效、易上手的 React 框架。（Inspired by dva and jumpstate）</p>\n<blockquote>\n<p>Painless React and Redux.</p>\n<p>Why?</p>\n</blockquote>\n<p>We love React and Redux.<br>我们热爱 React 和 Redux。<br>A typical React/Redux app looks like the following:<br>一个<strong>典型的</strong> React/Redux 应用看起来像下面这样：</p>\n<ul>\n<li><p>An actions/ directory to manually create all action types (or action creators)</p>\n<blockquote>\n<p> 一个 actions/ 目录用来手动创建所有的 action type（或者 action creator）</p>\n</blockquote>\n</li>\n<li><p>A reducers/ directory and tons of switch clause to capture all action types</p>\n<blockquote>\n<p> 一个 reducers/ 目录和超级多的 switch语句 来捕获所有的 action type</p>\n</blockquote>\n</li>\n<li><p>Apply middlewares to handle async actions</p>\n<blockquote>\n<p> 必须要依赖 middleware 才能处理 异步 action；</p>\n</blockquote>\n</li>\n<li><p>Explicitly invoke dispatch method to dispatch all actions</p>\n<blockquote>\n<p>   显示调用 dispatch 方法来 dispatch 所有的 action；</p>\n</blockquote>\n</li>\n<li><p>Manually create history to router and/or sync with store</p>\n<blockquote>\n<p> 手动创建 history 对象关联路由组件，可能还需要与 store 同步；</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Invoke methods in history or dispatch actions to programmatically changing routes<br>调用 history 上的方法或者 dispatch action 来手动更新路由；</li>\n</ul>\n</blockquote>\n<p>The problem?  <a href=\"https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md\" target=\"_blank\" rel=\"noopener\">Too much boilerplates</a> and a little bit tedious.</p>\n<p>存在的问题？太多的  <a href=\"https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md\" target=\"_blank\" rel=\"noopener\">样板文件</a>以及繁琐甚至重复的劳动。</p>\n<p>In fact, most part of the above steps could be simplified. Like, create actions and reducers in a single method, or dispatch both sync and async actions by simply invoking a function without extra middleware, or define routes without caring about history, etc.<br>实际上，上述大部分操作都是可以简化的。比如，在单个 API 中创建所有的 action 和 reducer；比如，简单地调用一个函数来 dispatch 所有的同步和异步 action，且不需要额外引入 middleware；再比如，使用路由的时候只需要关心定义具体的路由，不用去关心 history 对象，等等。</p>\n<p>That’s exactly what Mirror does, encapsulates the tedious or repetitive work in very few APIs to offer a high level abstraction with efficiency and simplicity, and without breaking the pattern.<br>这正是 Mirror 的使命，用极少数的 API 封装所有繁琐甚至重复的工作，提供一种简洁高效的更高级抽象，同时保持原有的开发模式。<br> 2.超级重点，样板文件</p>\n<blockquote>\n<p>2-1 Actions</p>\n</blockquote>\n<blockquote>\n<p>2-2 Action Creators</p>\n</blockquote>\n<blockquote>\n<p>2-3 Generating Action Creators</p>\n</blockquote>\n<blockquote>\n<p>2-4 Async Action Creators</p>\n</blockquote>\n<blockquote>\n<p>2-5 Reducers</p>\n</blockquote>\n<blockquote>\n<p>2-6 Generating Reducers</p>\n</blockquote>\n<h3 id=\"Reducing-Boilerplate\"><a href=\"#Reducing-Boilerplate\" class=\"headerlink\" title=\"Reducing Boilerplate\"></a>Reducing Boilerplate</h3><hr>\n<p>Redux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we’d like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</p>\n<p>Redux的部分是受Flux启发的，关于Flux最常见的抱怨就是它让你写出很多样板文件的。在下面的介绍中，我们将意识到Redux是如何让我们选择使用这种超级冗长的代码，当然这种选择也取决于个人风格、团队偏好、长期可维护性等等。</p>\n<p> 2-1 Actions</p>\n<hr>\n<p>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It’s important that actions being objects you have to dispatch is not boilerplate, but one of the fundamental design choices of Redux.</p>\n<p>Actions是一个描述app中发生了什么的普通对象（变量），也是唯一一种方式来描述数据意图变化。<br>要意识到是你必须dispatch的action，并不是无用的模板，而是redux基本设计规则</p>\n<p>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement hot reloading with time travel. If you’d rather modify data directly, you don’t need Redux.</p>\n<p>有些框架声称类似Flux，但是没有action概念。就可预测而言，这些框架相比Flux和react是一种倒退。如果没有action对象，是不可能记录和重演用户会话，也不可能实行热重载。如果你宁愿选择直接修改数据，则不需要使用Redux。</p>\n<blockquote>\n<p>Actions look like this: </p>\n</blockquote>\n<blockquote>\n<p>{ type: ‘ADD_TODO’, text: ‘Use Redux’ } </p>\n</blockquote>\n<blockquote>\n<p>{type: ‘REMOVE_TODO’, id: 42 } </p>\n</blockquote>\n<blockquote>\n<p>{ type: ‘LOAD_ARTICLE’, response: { …} }</p>\n</blockquote>\n<p>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not Symbols for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</p>\n<p>约定习俗，actions有一个type（是个常量），目的为了帮助reducers（或者Stores in Flux）识别他们。我们建议将type定义成string类型或者不是symbols类型，因为strings are serializable,并且使用symbols类型会让你记录或者重演的行为变得更困难</p>\n<p>In Flux, it is traditionally thought that you would define every action type as a string constant:</p>\n<blockquote>\n<p>const ADD_TODO = ‘ADD_TODO’<br>const REMOVE_TODO = ‘REMOVE_TODO’<br>const LOAD_ARTICLE = ‘LOAD_ARTICLE’</p>\n</blockquote>\n<p>在Flux，一般都会把type定义成一个字符串常量</p>\n<p>Why is this beneficial? It is often claimed that constants are unnecessary, and for small projects, this might be correct. For larger projects, there are some benefits to defining action types as constants:</p>\n<p>为什么好呢？在小项目中，常量声明不是必须的，但是在大项目中，type定义成常量的好处如下：</p>\n<ul>\n<li>It helps keep the naming consistent because all action types are gathered in a single place.</li>\n</ul>\n<blockquote>\n<p>它有助于保持命名的一致性，因为所有操作类型都集中在一个地方。</p>\n</blockquote>\n<ul>\n<li>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn’t know.</li>\n</ul>\n<blockquote>\n<p>有时再添加新特性之前需要查看一下所有已存在的actions。也有可能你需要新增的action，你的队友已经添加但是你不知道</p>\n</blockquote>\n<ul>\n<li>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</li>\n</ul>\n<blockquote>\n<p>  action的type列表，删除添加修改等操作很容易跟踪到</p>\n</blockquote>\n<ul>\n<li>If you make a typo when importing an action constant, you will get undefined. Redux will immediately throw when dispatching such an action, and you’ll find the mistake sooner.</li>\n</ul>\n<blockquote>\n<p>当你引入一个action常量的时候出现书写错误，那么你会得到undefined。当dispatch这个action的时候，redux立即报出问题，你就会很快地发现问题。</p>\n</blockquote>\n<p>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</p>\n<p>这取决于你，在项目中使用约定习俗 。你可以使用inline strings, and later transition to constants 或者把他们都放入一个单独文件中。redux在这里没做任何要求。<br>（把它们放入一个单独文件中使我们项目中使用方式，可见diwork的配图）</p>\n<p> 2-2 Action Creators</p>\n<hr>\n<p>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</p>\n<p>另外一个约定习俗是：不要在你要dispatch action的地方内联式地创建action，而是创建些生成他们的函数更好</p>\n<p>For example, instead of calling dispatch with an object literal:</p>\n<p>比如不要dipatch一个字面量对象</p>\n<p>// somewhere in an event handler</p>\n<pre><code>dispatch({\n  type: &apos;ADD_TODO&apos;,\n  text: &apos;Use Redux&apos;\n})\n</code></pre><p>You might write an action creator in a separate file, and import it into your component:<br>你最好在一个独立文件中写个action creator，然后import进来</p>\n<pre><code>actionCreators.js\n\nexport function addTodo(text) {\n  return {\n    type: &apos;ADD_TODO&apos;,\n    text\n  }\n}\n\nAddTodo.js\n\nimport { addTodo } from &apos;./actionCreators&apos;\n\n// somewhere in an event handler\ndispatch(addTodo(&apos;Use Redux&apos;))\n</code></pre><blockquote>\n<p>其实action creators就是return 一个action(一个action表现形式是type+其他内容)。就是把action封装下，在action的周围可以加上其他逻辑，如下：</p>\n</blockquote>\n<p>Action creators have often been criticized as boilerplate. Well, you don’t have to write them! You can use object literals if you feel this better suits your project. There are, however, some benefits for writing action creators you should know about.</p>\n<p>Action creator经常被批评为是模板文件。好吧，实际上你可以不写他们。如果你觉得合适，你可以使用字面量对象。但是关于action creator的好处你需要知道一下</p>\n<p>Let’s say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with redux-thunk middleware and adding an early exit:</p>\n<p>假设一个设计师在检查完原型之后回来告诉我们，我们需要允许最多三个任务。我们可以通过使用redux-thunk中间件将我们的action creator重写回调，并添加一个提前退出来实现这一点:</p>\n<pre><code>function addTodoWithoutCheck(text) {\n  return {\n    type: &apos;ADD_TODO&apos;,\n    text\n  }\n}\n\n\nexport function addTodo(text) {\n  // This form is allowed by Redux Thunk middleware\n  // described below in “Async Action Creators” section.\n  return function (dispatch, getState) {\n    if (getState().todos.length === 3) {\n      // Exit early\n      return\n    }\n    dispatch(addTodoWithoutCheck(text))\n  }\n}\n</code></pre><p>We just modified how the addTodo action creator behaves, completely invisible to the calling code. We don’t have to worry about looking at each place where todos are being added, to make sure they have this check. Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It’s very handy when the application is under heavy development, and the requirements change often.</p>\n<p>我们只需要修改addTodo这个action creator，完全可以忽略调用这个函数的任何地方（因此不用找到所有调用这个函数的地方添加任何额外操作）。action creator把dispatch an action周围的附加逻辑与发出这些动作的实际组件分离开来。<br>在繁重的开发阶段以及需求经常变动的情况下，这样开发变得非常敏捷</p>\n<p> 2-3 Generating Action Creators</p>\n<hr>\n<p>Some frameworks like Flummox generate action type constants automatically from the action creator function definitions. The idea is that you don’t need to both define ADD_TODO constant and addTodo() action creator. Under the hood, such solutions still generate action type constants, but they’re created implicitly so it’s a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</p>\n<p>一些框架像Flummox可以通过action creator函数来生成action的type常量。这种想法意味着你不需要同时定义ADD_TODO 常量和 addTodo()这个 action creator。但是实质上还是需要生成action type常量，并且这种隐式创建会导致混淆。我们建议显式地创建action type</p>\n<p>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:<br>编写简单的action creator是非常累人的，并且常常会生成冗余的样板代码:</p>\n<pre><code>export function addTodo(text) {\n  return {\n    type: &apos;ADD_TODO&apos;,\n    text\n  }\n}\n\nexport function editTodo(id, text) {\n  return {\n    type: &apos;EDIT_TODO&apos;,\n    id,\n    text\n  }\n}\n\nexport function removeTodo(id) {\n  return {\n    type: &apos;REMOVE_TODO&apos;,\n    id\n  }\n}\n</code></pre><p>You can always write a function that generates an action creator:</p>\n<pre><code>function makeActionCreator(type, ...argNames) {\n  return function (...args) {\n    const action = { type }\n    argNames.forEach((arg, index) =&gt; {\n      action[argNames[index]] = args[index]\n    })\n    return action\n  }\n}\n\nconst ADD_TODO = &apos;ADD_TODO&apos;\nconst EDIT_TODO = &apos;EDIT_TODO&apos;\nconst REMOVE_TODO = &apos;REMOVE_TODO&apos;\n\nexport const addTodo = makeActionCreator(ADD_TODO, &apos;text&apos;)\nexport const editTodo = makeActionCreator(EDIT_TODO, &apos;id&apos;, &apos;text&apos;)\nexport const removeTodo = makeActionCreator(REMOVE_TODO, &apos;id&apos;)\n//上面的这个函数会返回来\naddTodo(&apos;hahah&apos;)\n{type: &quot;ADD_TODO&quot;, text: &quot;hahah&quot;}\n</code></pre><blockquote>\n<p>上面代码真的很不错，可以学习一下，闭包知识也有用到，type，argNames被保存了。注意返回的是一个函数</p>\n</blockquote>\n<p>There are also utility libraries to aid in generating action creators, such as redux-act and redux-actions. These can help reduce boilerplate code and enforce adherence to standards such as Flux Standard Action (FSA).</p>\n<p>有一些公共库帮助生成action creators，比如redux-act 和redux-actions . 这样可以减少模板代码和强制遵循FSA规范</p>\n<p> 2-4 Async Action Creators</p>\n<hr>\n<p>异步的action creators</p>\n<p>Middleware lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</p>\n<p>Middleware 允许您注入自定义逻辑在每个action对象中 before it is dispatched。异步操作是middleware最常见的用例。</p>\n<p>Without any middleware, dispatch only accepts a plain object, so we have to perform AJAX calls inside our components:</p>\n<p>没有middleware，dispatch只接受普通对象，因此我们不得不在组件中执行AJAX调用:</p>\n<pre><code>actionCreators.js\n\nexport function loadPostsSuccess(userId, response) {\n  return {\n    type: &apos;LOAD_POSTS_SUCCESS&apos;,\n    userId,\n    response\n  }\n}\n\nexport function loadPostsFailure(userId, error) {\n  return {\n    type: &apos;LOAD_POSTS_FAILURE&apos;,\n    userId,\n    error\n  }\n}\n\nexport function loadPostsRequest(userId) {\n  return {\n    type: &apos;LOAD_POSTS_REQUEST&apos;,\n    userId\n  }\n}\n</code></pre><p>UserInfo.js</p>\n<pre><code>import { Component } from &apos;react&apos;\nimport { connect } from &apos;react-redux&apos;\nimport {\n  loadPostsRequest,\n  loadPostsSuccess,\n  loadPostsFailure\n} from &apos;./actionCreators&apos;\n\nclass Posts extends Component {\n  loadData(userId) {\n    // Injected into props by React Redux `connect()` call:\n    // 通过调用React Redux `connect()`注入了props\n    const { dispatch, posts } = this.props\n\n    if (posts[userId]) {\n      // There is cached data! Don&apos;t do anything.\n      // 是否有缓存数据\n      return\n    }\n\n    // Reducer can react to this action by setting\n    // `isFetching` and thus letting us show a spinner.\n    // 显示加载\n    dispatch(loadPostsRequest(userId))\n\n    // Reducer can react to these actions by filling the\n    // `users`.\n\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =&gt; dispatch(loadPostsSuccess(userId, response)),\n      error =&gt; dispatch(loadPostsFailure(userId, error))\n    )\n  }\n\n  componentDidMount() {\n    this.loadData(this.props.userId)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.userId !== this.props.userId) {\n      this.loadData(nextProps.userId)\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return &lt;p&gt;Loading...&lt;/p&gt;\n    }\n\n    const posts = this.props.posts.map(post =&gt;\n      &lt;Post post={post} key={post.id} /&gt;\n    )\n\n    return &lt;div&gt;{posts}&lt;/div&gt;\n  }\n}\n\nexport default connect(state =&gt; ({\n  posts: state.posts,\n  isFetching: state.isFetching\n}))(Posts)\n</code></pre><p>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</p>\n<p>然而这很快就会重复因为不同的组件使用相同api来请求数据，而且，我们希望重用许多组件中的一些逻辑（比如缓存数据存在的时候提前退出）<br>（如果有多个组件，需要重写很多次fetch请求呢）</p>\n<p>Middleware lets us write more expressive, potentially async action creators. It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.</p>\n<p>Middleware使我们能够编写更有表现力的、潜在的异步action creator。它允许我们dispatch something 而不是普通对象，并interprets the values。例如，middleware可以“捕获”已发出的promise，并将它们转换为一对请求+成功/失败操作。</p>\n<p>The simplest example of middleware is redux-thunk. “Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.</p>\n<p>middleware最简单的例子就是redux-thunk。thunk是允许你将action creators作为thunks，就是函数返回函数。这种反转控件，你可以将dispatch作为参数，因为写一个可以dispatch很多次的action creator</p>\n<blockquote>\n<p>Note </p>\n</blockquote>\n<blockquote>\n<p>Thunk middleware is just one example of middleware. Middleware is<br>not about “letting you dispatch functions”. It’s about letting you<br>dispatch anything that the particular middleware you use knows how to<br>handle. Thunk middleware adds a specific behavior when you dispatch<br>functions, but it really depends on the middleware you use. Thunk</p>\n</blockquote>\n<blockquote>\n<p>middleware只是一个简单例子，Middleware不是让你‘dispatch functions’。他是让你dispatch<br>任何Middleware知道如何处理的事情。Thunk Middleware可以在你dispatch<br>functions之前添加一些特殊操作，不过这一切取决你你使用的Middleware</p>\n</blockquote>\n<p>Consider the code above rewritten with redux-thunk:</p>\n<p>actionCreators.js</p>\n<pre><code>export function loadPosts(userId) {\n  // Interpreted by the thunk middleware:\n  // 交给thunk Middleware 解释\n  return function (dispatch, getState) {\n    const { posts } = getState()\n    if (posts[userId]) {\n      // There is cached data! Don&apos;t do anything.\n      return\n    }\n\n    dispatch({\n      type: &apos;LOAD_POSTS_REQUEST&apos;,\n      userId\n    })\n\n    // Dispatch vanilla actions asynchronously\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =&gt;\n        dispatch({\n          type: &apos;LOAD_POSTS_SUCCESS&apos;,\n          userId,\n          response\n        }),\n      error =&gt;\n        dispatch({\n          type: &apos;LOAD_POSTS_FAILURE&apos;,\n          userId,\n          error\n        })\n    )\n  }\n}\n</code></pre><p>UserInfo.js</p>\n<pre><code>import { Component } from &apos;react&apos;\nimport { connect } from &apos;react-redux&apos;\nimport { loadPosts } from &apos;./actionCreators&apos;\n\nclass Posts extends Component {\n  componentDidMount() {\n    this.props.dispatch(loadPosts(this.props.userId))\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.userId !== this.props.userId) {\n      this.props.dispatch(loadPosts(nextProps.userId))\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return &lt;p&gt;Loading...&lt;/p&gt;\n    }\n\n    const posts = this.props.posts.map(post =&gt;\n      &lt;Post post={post} key={post.id} /&gt;\n    )\n\n    return &lt;div&gt;{posts}&lt;/div&gt;\n  }\n}\n\nexport default connect(state =&gt; ({\n  posts: state.posts,\n  isFetching: state.isFetching\n}))(Posts)\n</code></pre><p>This is much less typing! If you’d like, you can still have “vanilla” action creators like loadPostsSuccess which you’d use from a container loadPosts action creator.</p>\n<p>更少的书写。如果你喜欢，你可以有vanilla action creators，如loadPostsSuccess<br>（其实就是把第一个UserInfo.js中loadData提出来加工一下改为loadPosts）</p>\n<p>Finally, you can write your own middleware. Let’s say you want to generalize the pattern above and describe your async action creators like this instead:<br>最后你可以编写自己的Middleware。如果你想要推广上面的模式，可以这样的描述你的异步action creators</p>\n<pre><code>export function loadPosts(userId) {\n  return {\n\n    // Types of actions to emit before and after定义Types\n    types: [&apos;LOAD_POSTS_REQUEST&apos;, &apos;LOAD_POSTS_SUCCESS&apos;, &apos;LOAD_POSTS_FAILURE&apos;],\n\n    // Check the cache (optional):检查缓存\n    shouldCallAPI: state =&gt; !state.posts[userId],\n\n    // Perform the fetching:执行fetch\n    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),\n    // Arguments to inject in begin/end actions 参数注入在开始或者结束的actions\n    payload: { userId }\n  }\n}\n</code></pre><p>The middleware that interprets such actions could look like this:</p>\n<p>Middleware这样定义actions</p>\n<pre><code>function callAPIMiddleware({ dispatch, getState }) {\n  return next =&gt; action =&gt; {\n    const {\n      types,\n      callAPI,\n      shouldCallAPI = () =&gt; true,\n      payload = {}\n    } = action\n\n    if (!types) {\n      // Normal action: pass it on\n      return next(action)\n    }\n\n    if (\n      !Array.isArray(types) ||\n      types.length !== 3 ||\n      !types.every(type =&gt; typeof type === &apos;string&apos;)\n    ) {\n      throw new Error(&apos;Expected an array of three string types.&apos;)\n    }\n\n    if (typeof callAPI !== &apos;function&apos;) {\n      throw new Error(&apos;Expected callAPI to be a function.&apos;)\n    }\n\n    if (!shouldCallAPI(getState())) {\n      return\n    }\n\n    const [requestType, successType, failureType] = types\n\n    dispatch(\n      Object.assign({}, payload, {\n        type: requestType\n      })\n    )\n\n    return callAPI().then(\n      response =&gt;\n        dispatch(\n          Object.assign({}, payload, {\n            response,\n            type: successType\n          })\n        ),\n      error =&gt;\n        dispatch(\n          Object.assign({}, payload, {\n            error,\n            type: failureType\n          })\n        )\n    )\n  }\n}\n</code></pre><p>After passing it once to applyMiddleware(…middlewares), you can write all your API-calling action creators the same way:</p>\n<p>只要使用一次applyMiddleware(…middlewares), 您可以用同样的方式编写所有api调用的action creators</p>\n<pre><code>export function loadPosts(userId) {\n  return {\n    types: [&apos;LOAD_POSTS_REQUEST&apos;, &apos;LOAD_POSTS_SUCCESS&apos;, &apos;LOAD_POSTS_FAILURE&apos;],\n    shouldCallAPI: state =&gt; !state.posts[userId],\n    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),\n    payload: { userId }\n  }\n}\n\nexport function loadComments(postId) {\n  return {\n    types: [\n      &apos;LOAD_COMMENTS_REQUEST&apos;,\n      &apos;LOAD_COMMENTS_SUCCESS&apos;,\n      &apos;LOAD_COMMENTS_FAILURE&apos;\n    ],\n    shouldCallAPI: state =&gt; !state.comments[postId],\n    callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`),\n    payload: { postId }\n  }\n}\n\nexport function addComment(postId, message) {\n  return {\n    types: [\n      &apos;ADD_COMMENT_REQUEST&apos;,\n      &apos;ADD_COMMENT_SUCCESS&apos;,\n      &apos;ADD_COMMENT_FAILURE&apos;\n    ],\n    callAPI: () =&gt;\n      fetch(`http://myapi.com/posts/${postId}/comments`, {\n        method: &apos;post&apos;,\n        headers: {\n          Accept: &apos;application/json&apos;,\n          &apos;Content-Type&apos;: &apos;application/json&apos;\n        },\n        body: JSON.stringify({ message })\n      }),\n    payload: { postId, message }\n  }\n}\n</code></pre><p> 2-5 Reducers</p>\n<hr>\n<p>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</p>\n<p>Redux通过将更新逻辑描述为函数，大大减少了Flux样板。函数比对象简单，比类简单得多。</p>\n<p>Consider this Flux store:</p>\n<pre><code>const _todos = []\n\nconst TodoStore = Object.assign({}, EventEmitter.prototype, {\n  getAll() {\n    return _todos\n  }\n})\n\nAppDispatcher.register(function (action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      const text = action.text.trim()\n      _todos.push(text)\n      TodoStore.emitChange()\n  }\n})\n\nexport default TodoStore\n</code></pre><p>With Redux, the same update logic can be described as a reducing function:</p>\n<pre><code>export function todos(state = [], action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      const text = action.text.trim()\n      return [...state, text]\n    default:\n      return state\n  }\n}\n</code></pre><p>The switch statement is not the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app)。</p>\n<p>这是对Flux的解析：<br>Switch语句不是真正冗余，Flux真正冗余的是概念：<br>需要emit an update<br>需要用一个dispatcher来注册store（就是store需要被注册在一个dispatcher上）<br>需要store是个对象（当你想要一个通用app的时候这就会非常的复杂）</p>\n<p>It’s unfortunate that many still choose Flux framework based on whether it uses switch statements in the documentation. If you don’t like switch, you can solve this with a single function, as we show below.<br>愚蠢的是，许多人仍然根据文档中是否使用switch语句来选择Flux框架。如果您不喜欢switch，可以使用一个函数来解决这个问题，如下所示。</p>\n<p> 2-6 Generating Reducers</p>\n<hr>\n<p>Let’s write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our todos reducers to be defined like this:</p>\n<p>让我们编写一个函数，让我们将reducers表述为一个对象映射，映射关系是action type 映射到 handlers。例如，如果我们希望我们的todos是这样定义的:</p>\n<pre><code>export const todos = createReducer([], {\n  [ActionTypes.ADD_TODO]: (state, action) =&gt; {\n    const text = action.text.trim()\n    return [...state, text]\n  }\n})\n</code></pre><p>越来越像我们项目中用到了<br>这种映射关系去掉了switch<br>We can write the following helper to accomplish this:<br>可以使用下面的帮助来完成</p>\n<pre><code>function createReducer(initialState, handlers) {\n  return function reducer(state = initialState, action) {\n    if (handlers.hasOwnProperty(action.type)) {\n      return handlers[action.type](state, action)\n    } else {\n      return state\n    }\n  }\n}\n</code></pre><p>This wasn’t difficult, was it? Redux doesn’t provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.<br>The Redux reducer API is (state, action) =&gt; newState, but how you create those reducers is up to you.</p>\n<p>这并不难，不是吗?</p>\n<p>Redux默认情况下不提供这样的帮助helper，因为有很多方法可以编写它。也许您希望它自动将普通JS对象转换为不可变对象，以适应服务器状态。也许您希望将返回的状态与当前状态合并。也有很多不同的方式来使用‘catch all’handler。所有这些都取决于您根据特定项目中选择的约定。</p>\n<p>Redux reducer API是(state, action) =&gt; newState，但是如何创建这些reducer取决于您。</p>\n<blockquote>\n<p>action 、 action creators 、 reducer 的区别</p>\n</blockquote>\n<blockquote>\n<p>action  = type + new value</p>\n</blockquote>\n<blockquote>\n<p>action creators = logic + action</p>\n</blockquote>\n<blockquote>\n<p>reducer = state +  action creators</p>\n</blockquote>\n<p> 3.diwork<br>diwork工作台的redux如下</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"有一篇redux的吐槽写的甚好，翻译一下\"><a href=\"#有一篇redux的吐槽写的甚好，翻译一下\" class=\"headerlink\" title=\"有一篇redux的吐槽写的甚好，翻译一下\"></a>有一篇redux的吐槽写的甚好，翻译一下</h2>","more":"<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>mirror<br>A simple and powerful React framework with minimal API and zero boilerplate. (Inspired by dva and jumpstate)<br>一款简洁、高效、易上手的 React 框架。（Inspired by dva and jumpstate）</p>\n<blockquote>\n<p>Painless React and Redux.</p>\n<p>Why?</p>\n</blockquote>\n<p>We love React and Redux.<br>我们热爱 React 和 Redux。<br>A typical React/Redux app looks like the following:<br>一个<strong>典型的</strong> React/Redux 应用看起来像下面这样：</p>\n<ul>\n<li><p>An actions/ directory to manually create all action types (or action creators)</p>\n<blockquote>\n<p> 一个 actions/ 目录用来手动创建所有的 action type（或者 action creator）</p>\n</blockquote>\n</li>\n<li><p>A reducers/ directory and tons of switch clause to capture all action types</p>\n<blockquote>\n<p> 一个 reducers/ 目录和超级多的 switch语句 来捕获所有的 action type</p>\n</blockquote>\n</li>\n<li><p>Apply middlewares to handle async actions</p>\n<blockquote>\n<p> 必须要依赖 middleware 才能处理 异步 action；</p>\n</blockquote>\n</li>\n<li><p>Explicitly invoke dispatch method to dispatch all actions</p>\n<blockquote>\n<p>   显示调用 dispatch 方法来 dispatch 所有的 action；</p>\n</blockquote>\n</li>\n<li><p>Manually create history to router and/or sync with store</p>\n<blockquote>\n<p> 手动创建 history 对象关联路由组件，可能还需要与 store 同步；</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li>Invoke methods in history or dispatch actions to programmatically changing routes<br>调用 history 上的方法或者 dispatch action 来手动更新路由；</li>\n</ul>\n</blockquote>\n<p>The problem?  <a href=\"https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md\" target=\"_blank\" rel=\"noopener\">Too much boilerplates</a> and a little bit tedious.</p>\n<p>存在的问题？太多的  <a href=\"https://github.com/reduxjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md\" target=\"_blank\" rel=\"noopener\">样板文件</a>以及繁琐甚至重复的劳动。</p>\n<p>In fact, most part of the above steps could be simplified. Like, create actions and reducers in a single method, or dispatch both sync and async actions by simply invoking a function without extra middleware, or define routes without caring about history, etc.<br>实际上，上述大部分操作都是可以简化的。比如，在单个 API 中创建所有的 action 和 reducer；比如，简单地调用一个函数来 dispatch 所有的同步和异步 action，且不需要额外引入 middleware；再比如，使用路由的时候只需要关心定义具体的路由，不用去关心 history 对象，等等。</p>\n<p>That’s exactly what Mirror does, encapsulates the tedious or repetitive work in very few APIs to offer a high level abstraction with efficiency and simplicity, and without breaking the pattern.<br>这正是 Mirror 的使命，用极少数的 API 封装所有繁琐甚至重复的工作，提供一种简洁高效的更高级抽象，同时保持原有的开发模式。<br> 2.超级重点，样板文件</p>\n<blockquote>\n<p>2-1 Actions</p>\n</blockquote>\n<blockquote>\n<p>2-2 Action Creators</p>\n</blockquote>\n<blockquote>\n<p>2-3 Generating Action Creators</p>\n</blockquote>\n<blockquote>\n<p>2-4 Async Action Creators</p>\n</blockquote>\n<blockquote>\n<p>2-5 Reducers</p>\n</blockquote>\n<blockquote>\n<p>2-6 Generating Reducers</p>\n</blockquote>\n<h3 id=\"Reducing-Boilerplate\"><a href=\"#Reducing-Boilerplate\" class=\"headerlink\" title=\"Reducing Boilerplate\"></a>Reducing Boilerplate</h3><hr>\n<p>Redux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we’d like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.</p>\n<p>Redux的部分是受Flux启发的，关于Flux最常见的抱怨就是它让你写出很多样板文件的。在下面的介绍中，我们将意识到Redux是如何让我们选择使用这种超级冗长的代码，当然这种选择也取决于个人风格、团队偏好、长期可维护性等等。</p>\n<p> 2-1 Actions</p>\n<hr>\n<p>Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It’s important that actions being objects you have to dispatch is not boilerplate, but one of the fundamental design choices of Redux.</p>\n<p>Actions是一个描述app中发生了什么的普通对象（变量），也是唯一一种方式来描述数据意图变化。<br>要意识到是你必须dispatch的action，并不是无用的模板，而是redux基本设计规则</p>\n<p>There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement hot reloading with time travel. If you’d rather modify data directly, you don’t need Redux.</p>\n<p>有些框架声称类似Flux，但是没有action概念。就可预测而言，这些框架相比Flux和react是一种倒退。如果没有action对象，是不可能记录和重演用户会话，也不可能实行热重载。如果你宁愿选择直接修改数据，则不需要使用Redux。</p>\n<blockquote>\n<p>Actions look like this: </p>\n</blockquote>\n<blockquote>\n<p>{ type: ‘ADD_TODO’, text: ‘Use Redux’ } </p>\n</blockquote>\n<blockquote>\n<p>{type: ‘REMOVE_TODO’, id: 42 } </p>\n</blockquote>\n<blockquote>\n<p>{ type: ‘LOAD_ARTICLE’, response: { …} }</p>\n</blockquote>\n<p>It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not Symbols for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be.</p>\n<p>约定习俗，actions有一个type（是个常量），目的为了帮助reducers（或者Stores in Flux）识别他们。我们建议将type定义成string类型或者不是symbols类型，因为strings are serializable,并且使用symbols类型会让你记录或者重演的行为变得更困难</p>\n<p>In Flux, it is traditionally thought that you would define every action type as a string constant:</p>\n<blockquote>\n<p>const ADD_TODO = ‘ADD_TODO’<br>const REMOVE_TODO = ‘REMOVE_TODO’<br>const LOAD_ARTICLE = ‘LOAD_ARTICLE’</p>\n</blockquote>\n<p>在Flux，一般都会把type定义成一个字符串常量</p>\n<p>Why is this beneficial? It is often claimed that constants are unnecessary, and for small projects, this might be correct. For larger projects, there are some benefits to defining action types as constants:</p>\n<p>为什么好呢？在小项目中，常量声明不是必须的，但是在大项目中，type定义成常量的好处如下：</p>\n<ul>\n<li>It helps keep the naming consistent because all action types are gathered in a single place.</li>\n</ul>\n<blockquote>\n<p>它有助于保持命名的一致性，因为所有操作类型都集中在一个地方。</p>\n</blockquote>\n<ul>\n<li>Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn’t know.</li>\n</ul>\n<blockquote>\n<p>有时再添加新特性之前需要查看一下所有已存在的actions。也有可能你需要新增的action，你的队友已经添加但是你不知道</p>\n</blockquote>\n<ul>\n<li>The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features.</li>\n</ul>\n<blockquote>\n<p>  action的type列表，删除添加修改等操作很容易跟踪到</p>\n</blockquote>\n<ul>\n<li>If you make a typo when importing an action constant, you will get undefined. Redux will immediately throw when dispatching such an action, and you’ll find the mistake sooner.</li>\n</ul>\n<blockquote>\n<p>当你引入一个action常量的时候出现书写错误，那么你会得到undefined。当dispatch这个action的时候，redux立即报出问题，你就会很快地发现问题。</p>\n</blockquote>\n<p>It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment.</p>\n<p>这取决于你，在项目中使用约定习俗 。你可以使用inline strings, and later transition to constants 或者把他们都放入一个单独文件中。redux在这里没做任何要求。<br>（把它们放入一个单独文件中使我们项目中使用方式，可见diwork的配图）</p>\n<p> 2-2 Action Creators</p>\n<hr>\n<p>It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them.</p>\n<p>另外一个约定习俗是：不要在你要dispatch action的地方内联式地创建action，而是创建些生成他们的函数更好</p>\n<p>For example, instead of calling dispatch with an object literal:</p>\n<p>比如不要dipatch一个字面量对象</p>\n<p>// somewhere in an event handler</p>\n<pre><code>dispatch({\n  type: &apos;ADD_TODO&apos;,\n  text: &apos;Use Redux&apos;\n})\n</code></pre><p>You might write an action creator in a separate file, and import it into your component:<br>你最好在一个独立文件中写个action creator，然后import进来</p>\n<pre><code>actionCreators.js\n\nexport function addTodo(text) {\n  return {\n    type: &apos;ADD_TODO&apos;,\n    text\n  }\n}\n\nAddTodo.js\n\nimport { addTodo } from &apos;./actionCreators&apos;\n\n// somewhere in an event handler\ndispatch(addTodo(&apos;Use Redux&apos;))\n</code></pre><blockquote>\n<p>其实action creators就是return 一个action(一个action表现形式是type+其他内容)。就是把action封装下，在action的周围可以加上其他逻辑，如下：</p>\n</blockquote>\n<p>Action creators have often been criticized as boilerplate. Well, you don’t have to write them! You can use object literals if you feel this better suits your project. There are, however, some benefits for writing action creators you should know about.</p>\n<p>Action creator经常被批评为是模板文件。好吧，实际上你可以不写他们。如果你觉得合适，你可以使用字面量对象。但是关于action creator的好处你需要知道一下</p>\n<p>Let’s say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with redux-thunk middleware and adding an early exit:</p>\n<p>假设一个设计师在检查完原型之后回来告诉我们，我们需要允许最多三个任务。我们可以通过使用redux-thunk中间件将我们的action creator重写回调，并添加一个提前退出来实现这一点:</p>\n<pre><code>function addTodoWithoutCheck(text) {\n  return {\n    type: &apos;ADD_TODO&apos;,\n    text\n  }\n}\n\n\nexport function addTodo(text) {\n  // This form is allowed by Redux Thunk middleware\n  // described below in “Async Action Creators” section.\n  return function (dispatch, getState) {\n    if (getState().todos.length === 3) {\n      // Exit early\n      return\n    }\n    dispatch(addTodoWithoutCheck(text))\n  }\n}\n</code></pre><p>We just modified how the addTodo action creator behaves, completely invisible to the calling code. We don’t have to worry about looking at each place where todos are being added, to make sure they have this check. Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It’s very handy when the application is under heavy development, and the requirements change often.</p>\n<p>我们只需要修改addTodo这个action creator，完全可以忽略调用这个函数的任何地方（因此不用找到所有调用这个函数的地方添加任何额外操作）。action creator把dispatch an action周围的附加逻辑与发出这些动作的实际组件分离开来。<br>在繁重的开发阶段以及需求经常变动的情况下，这样开发变得非常敏捷</p>\n<p> 2-3 Generating Action Creators</p>\n<hr>\n<p>Some frameworks like Flummox generate action type constants automatically from the action creator function definitions. The idea is that you don’t need to both define ADD_TODO constant and addTodo() action creator. Under the hood, such solutions still generate action type constants, but they’re created implicitly so it’s a level of indirection and can cause confusion. We recommend creating your action type constants explicitly.</p>\n<p>一些框架像Flummox可以通过action creator函数来生成action的type常量。这种想法意味着你不需要同时定义ADD_TODO 常量和 addTodo()这个 action creator。但是实质上还是需要生成action type常量，并且这种隐式创建会导致混淆。我们建议显式地创建action type</p>\n<p>Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:<br>编写简单的action creator是非常累人的，并且常常会生成冗余的样板代码:</p>\n<pre><code>export function addTodo(text) {\n  return {\n    type: &apos;ADD_TODO&apos;,\n    text\n  }\n}\n\nexport function editTodo(id, text) {\n  return {\n    type: &apos;EDIT_TODO&apos;,\n    id,\n    text\n  }\n}\n\nexport function removeTodo(id) {\n  return {\n    type: &apos;REMOVE_TODO&apos;,\n    id\n  }\n}\n</code></pre><p>You can always write a function that generates an action creator:</p>\n<pre><code>function makeActionCreator(type, ...argNames) {\n  return function (...args) {\n    const action = { type }\n    argNames.forEach((arg, index) =&gt; {\n      action[argNames[index]] = args[index]\n    })\n    return action\n  }\n}\n\nconst ADD_TODO = &apos;ADD_TODO&apos;\nconst EDIT_TODO = &apos;EDIT_TODO&apos;\nconst REMOVE_TODO = &apos;REMOVE_TODO&apos;\n\nexport const addTodo = makeActionCreator(ADD_TODO, &apos;text&apos;)\nexport const editTodo = makeActionCreator(EDIT_TODO, &apos;id&apos;, &apos;text&apos;)\nexport const removeTodo = makeActionCreator(REMOVE_TODO, &apos;id&apos;)\n//上面的这个函数会返回来\naddTodo(&apos;hahah&apos;)\n{type: &quot;ADD_TODO&quot;, text: &quot;hahah&quot;}\n</code></pre><blockquote>\n<p>上面代码真的很不错，可以学习一下，闭包知识也有用到，type，argNames被保存了。注意返回的是一个函数</p>\n</blockquote>\n<p>There are also utility libraries to aid in generating action creators, such as redux-act and redux-actions. These can help reduce boilerplate code and enforce adherence to standards such as Flux Standard Action (FSA).</p>\n<p>有一些公共库帮助生成action creators，比如redux-act 和redux-actions . 这样可以减少模板代码和强制遵循FSA规范</p>\n<p> 2-4 Async Action Creators</p>\n<hr>\n<p>异步的action creators</p>\n<p>Middleware lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware.</p>\n<p>Middleware 允许您注入自定义逻辑在每个action对象中 before it is dispatched。异步操作是middleware最常见的用例。</p>\n<p>Without any middleware, dispatch only accepts a plain object, so we have to perform AJAX calls inside our components:</p>\n<p>没有middleware，dispatch只接受普通对象，因此我们不得不在组件中执行AJAX调用:</p>\n<pre><code>actionCreators.js\n\nexport function loadPostsSuccess(userId, response) {\n  return {\n    type: &apos;LOAD_POSTS_SUCCESS&apos;,\n    userId,\n    response\n  }\n}\n\nexport function loadPostsFailure(userId, error) {\n  return {\n    type: &apos;LOAD_POSTS_FAILURE&apos;,\n    userId,\n    error\n  }\n}\n\nexport function loadPostsRequest(userId) {\n  return {\n    type: &apos;LOAD_POSTS_REQUEST&apos;,\n    userId\n  }\n}\n</code></pre><p>UserInfo.js</p>\n<pre><code>import { Component } from &apos;react&apos;\nimport { connect } from &apos;react-redux&apos;\nimport {\n  loadPostsRequest,\n  loadPostsSuccess,\n  loadPostsFailure\n} from &apos;./actionCreators&apos;\n\nclass Posts extends Component {\n  loadData(userId) {\n    // Injected into props by React Redux `connect()` call:\n    // 通过调用React Redux `connect()`注入了props\n    const { dispatch, posts } = this.props\n\n    if (posts[userId]) {\n      // There is cached data! Don&apos;t do anything.\n      // 是否有缓存数据\n      return\n    }\n\n    // Reducer can react to this action by setting\n    // `isFetching` and thus letting us show a spinner.\n    // 显示加载\n    dispatch(loadPostsRequest(userId))\n\n    // Reducer can react to these actions by filling the\n    // `users`.\n\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =&gt; dispatch(loadPostsSuccess(userId, response)),\n      error =&gt; dispatch(loadPostsFailure(userId, error))\n    )\n  }\n\n  componentDidMount() {\n    this.loadData(this.props.userId)\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.userId !== this.props.userId) {\n      this.loadData(nextProps.userId)\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return &lt;p&gt;Loading...&lt;/p&gt;\n    }\n\n    const posts = this.props.posts.map(post =&gt;\n      &lt;Post post={post} key={post.id} /&gt;\n    )\n\n    return &lt;div&gt;{posts}&lt;/div&gt;\n  }\n}\n\nexport default connect(state =&gt; ({\n  posts: state.posts,\n  isFetching: state.isFetching\n}))(Posts)\n</code></pre><p>However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components.</p>\n<p>然而这很快就会重复因为不同的组件使用相同api来请求数据，而且，我们希望重用许多组件中的一些逻辑（比如缓存数据存在的时候提前退出）<br>（如果有多个组件，需要重写很多次fetch请求呢）</p>\n<p>Middleware lets us write more expressive, potentially async action creators. It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can “catch” dispatched Promises and turn them into a pair of request and success/failure actions.</p>\n<p>Middleware使我们能够编写更有表现力的、潜在的异步action creator。它允许我们dispatch something 而不是普通对象，并interprets the values。例如，middleware可以“捕获”已发出的promise，并将它们转换为一对请求+成功/失败操作。</p>\n<p>The simplest example of middleware is redux-thunk. “Thunk” middleware lets you write action creators as “thunks”, that is, functions returning functions. This inverts the control: you will get dispatch as an argument, so you can write an action creator that dispatches many times.</p>\n<p>middleware最简单的例子就是redux-thunk。thunk是允许你将action creators作为thunks，就是函数返回函数。这种反转控件，你可以将dispatch作为参数，因为写一个可以dispatch很多次的action creator</p>\n<blockquote>\n<p>Note </p>\n</blockquote>\n<blockquote>\n<p>Thunk middleware is just one example of middleware. Middleware is<br>not about “letting you dispatch functions”. It’s about letting you<br>dispatch anything that the particular middleware you use knows how to<br>handle. Thunk middleware adds a specific behavior when you dispatch<br>functions, but it really depends on the middleware you use. Thunk</p>\n</blockquote>\n<blockquote>\n<p>middleware只是一个简单例子，Middleware不是让你‘dispatch functions’。他是让你dispatch<br>任何Middleware知道如何处理的事情。Thunk Middleware可以在你dispatch<br>functions之前添加一些特殊操作，不过这一切取决你你使用的Middleware</p>\n</blockquote>\n<p>Consider the code above rewritten with redux-thunk:</p>\n<p>actionCreators.js</p>\n<pre><code>export function loadPosts(userId) {\n  // Interpreted by the thunk middleware:\n  // 交给thunk Middleware 解释\n  return function (dispatch, getState) {\n    const { posts } = getState()\n    if (posts[userId]) {\n      // There is cached data! Don&apos;t do anything.\n      return\n    }\n\n    dispatch({\n      type: &apos;LOAD_POSTS_REQUEST&apos;,\n      userId\n    })\n\n    // Dispatch vanilla actions asynchronously\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =&gt;\n        dispatch({\n          type: &apos;LOAD_POSTS_SUCCESS&apos;,\n          userId,\n          response\n        }),\n      error =&gt;\n        dispatch({\n          type: &apos;LOAD_POSTS_FAILURE&apos;,\n          userId,\n          error\n        })\n    )\n  }\n}\n</code></pre><p>UserInfo.js</p>\n<pre><code>import { Component } from &apos;react&apos;\nimport { connect } from &apos;react-redux&apos;\nimport { loadPosts } from &apos;./actionCreators&apos;\n\nclass Posts extends Component {\n  componentDidMount() {\n    this.props.dispatch(loadPosts(this.props.userId))\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.userId !== this.props.userId) {\n      this.props.dispatch(loadPosts(nextProps.userId))\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return &lt;p&gt;Loading...&lt;/p&gt;\n    }\n\n    const posts = this.props.posts.map(post =&gt;\n      &lt;Post post={post} key={post.id} /&gt;\n    )\n\n    return &lt;div&gt;{posts}&lt;/div&gt;\n  }\n}\n\nexport default connect(state =&gt; ({\n  posts: state.posts,\n  isFetching: state.isFetching\n}))(Posts)\n</code></pre><p>This is much less typing! If you’d like, you can still have “vanilla” action creators like loadPostsSuccess which you’d use from a container loadPosts action creator.</p>\n<p>更少的书写。如果你喜欢，你可以有vanilla action creators，如loadPostsSuccess<br>（其实就是把第一个UserInfo.js中loadData提出来加工一下改为loadPosts）</p>\n<p>Finally, you can write your own middleware. Let’s say you want to generalize the pattern above and describe your async action creators like this instead:<br>最后你可以编写自己的Middleware。如果你想要推广上面的模式，可以这样的描述你的异步action creators</p>\n<pre><code>export function loadPosts(userId) {\n  return {\n\n    // Types of actions to emit before and after定义Types\n    types: [&apos;LOAD_POSTS_REQUEST&apos;, &apos;LOAD_POSTS_SUCCESS&apos;, &apos;LOAD_POSTS_FAILURE&apos;],\n\n    // Check the cache (optional):检查缓存\n    shouldCallAPI: state =&gt; !state.posts[userId],\n\n    // Perform the fetching:执行fetch\n    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),\n    // Arguments to inject in begin/end actions 参数注入在开始或者结束的actions\n    payload: { userId }\n  }\n}\n</code></pre><p>The middleware that interprets such actions could look like this:</p>\n<p>Middleware这样定义actions</p>\n<pre><code>function callAPIMiddleware({ dispatch, getState }) {\n  return next =&gt; action =&gt; {\n    const {\n      types,\n      callAPI,\n      shouldCallAPI = () =&gt; true,\n      payload = {}\n    } = action\n\n    if (!types) {\n      // Normal action: pass it on\n      return next(action)\n    }\n\n    if (\n      !Array.isArray(types) ||\n      types.length !== 3 ||\n      !types.every(type =&gt; typeof type === &apos;string&apos;)\n    ) {\n      throw new Error(&apos;Expected an array of three string types.&apos;)\n    }\n\n    if (typeof callAPI !== &apos;function&apos;) {\n      throw new Error(&apos;Expected callAPI to be a function.&apos;)\n    }\n\n    if (!shouldCallAPI(getState())) {\n      return\n    }\n\n    const [requestType, successType, failureType] = types\n\n    dispatch(\n      Object.assign({}, payload, {\n        type: requestType\n      })\n    )\n\n    return callAPI().then(\n      response =&gt;\n        dispatch(\n          Object.assign({}, payload, {\n            response,\n            type: successType\n          })\n        ),\n      error =&gt;\n        dispatch(\n          Object.assign({}, payload, {\n            error,\n            type: failureType\n          })\n        )\n    )\n  }\n}\n</code></pre><p>After passing it once to applyMiddleware(…middlewares), you can write all your API-calling action creators the same way:</p>\n<p>只要使用一次applyMiddleware(…middlewares), 您可以用同样的方式编写所有api调用的action creators</p>\n<pre><code>export function loadPosts(userId) {\n  return {\n    types: [&apos;LOAD_POSTS_REQUEST&apos;, &apos;LOAD_POSTS_SUCCESS&apos;, &apos;LOAD_POSTS_FAILURE&apos;],\n    shouldCallAPI: state =&gt; !state.posts[userId],\n    callAPI: () =&gt; fetch(`http://myapi.com/users/${userId}/posts`),\n    payload: { userId }\n  }\n}\n\nexport function loadComments(postId) {\n  return {\n    types: [\n      &apos;LOAD_COMMENTS_REQUEST&apos;,\n      &apos;LOAD_COMMENTS_SUCCESS&apos;,\n      &apos;LOAD_COMMENTS_FAILURE&apos;\n    ],\n    shouldCallAPI: state =&gt; !state.comments[postId],\n    callAPI: () =&gt; fetch(`http://myapi.com/posts/${postId}/comments`),\n    payload: { postId }\n  }\n}\n\nexport function addComment(postId, message) {\n  return {\n    types: [\n      &apos;ADD_COMMENT_REQUEST&apos;,\n      &apos;ADD_COMMENT_SUCCESS&apos;,\n      &apos;ADD_COMMENT_FAILURE&apos;\n    ],\n    callAPI: () =&gt;\n      fetch(`http://myapi.com/posts/${postId}/comments`, {\n        method: &apos;post&apos;,\n        headers: {\n          Accept: &apos;application/json&apos;,\n          &apos;Content-Type&apos;: &apos;application/json&apos;\n        },\n        body: JSON.stringify({ message })\n      }),\n    payload: { postId, message }\n  }\n}\n</code></pre><p> 2-5 Reducers</p>\n<hr>\n<p>Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class.</p>\n<p>Redux通过将更新逻辑描述为函数，大大减少了Flux样板。函数比对象简单，比类简单得多。</p>\n<p>Consider this Flux store:</p>\n<pre><code>const _todos = []\n\nconst TodoStore = Object.assign({}, EventEmitter.prototype, {\n  getAll() {\n    return _todos\n  }\n})\n\nAppDispatcher.register(function (action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      const text = action.text.trim()\n      _todos.push(text)\n      TodoStore.emitChange()\n  }\n})\n\nexport default TodoStore\n</code></pre><p>With Redux, the same update logic can be described as a reducing function:</p>\n<pre><code>export function todos(state = [], action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      const text = action.text.trim()\n      return [...state, text]\n    default:\n      return state\n  }\n}\n</code></pre><p>The switch statement is not the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app)。</p>\n<p>这是对Flux的解析：<br>Switch语句不是真正冗余，Flux真正冗余的是概念：<br>需要emit an update<br>需要用一个dispatcher来注册store（就是store需要被注册在一个dispatcher上）<br>需要store是个对象（当你想要一个通用app的时候这就会非常的复杂）</p>\n<p>It’s unfortunate that many still choose Flux framework based on whether it uses switch statements in the documentation. If you don’t like switch, you can solve this with a single function, as we show below.<br>愚蠢的是，许多人仍然根据文档中是否使用switch语句来选择Flux框架。如果您不喜欢switch，可以使用一个函数来解决这个问题，如下所示。</p>\n<p> 2-6 Generating Reducers</p>\n<hr>\n<p>Let’s write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our todos reducers to be defined like this:</p>\n<p>让我们编写一个函数，让我们将reducers表述为一个对象映射，映射关系是action type 映射到 handlers。例如，如果我们希望我们的todos是这样定义的:</p>\n<pre><code>export const todos = createReducer([], {\n  [ActionTypes.ADD_TODO]: (state, action) =&gt; {\n    const text = action.text.trim()\n    return [...state, text]\n  }\n})\n</code></pre><p>越来越像我们项目中用到了<br>这种映射关系去掉了switch<br>We can write the following helper to accomplish this:<br>可以使用下面的帮助来完成</p>\n<pre><code>function createReducer(initialState, handlers) {\n  return function reducer(state = initialState, action) {\n    if (handlers.hasOwnProperty(action.type)) {\n      return handlers[action.type](state, action)\n    } else {\n      return state\n    }\n  }\n}\n</code></pre><p>This wasn’t difficult, was it? Redux doesn’t provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a “catch all” handler. All of this depends on the conventions you choose for your team on a specific project.<br>The Redux reducer API is (state, action) =&gt; newState, but how you create those reducers is up to you.</p>\n<p>这并不难，不是吗?</p>\n<p>Redux默认情况下不提供这样的帮助helper，因为有很多方法可以编写它。也许您希望它自动将普通JS对象转换为不可变对象，以适应服务器状态。也许您希望将返回的状态与当前状态合并。也有很多不同的方式来使用‘catch all’handler。所有这些都取决于您根据特定项目中选择的约定。</p>\n<p>Redux reducer API是(state, action) =&gt; newState，但是如何创建这些reducer取决于您。</p>\n<blockquote>\n<p>action 、 action creators 、 reducer 的区别</p>\n</blockquote>\n<blockquote>\n<p>action  = type + new value</p>\n</blockquote>\n<blockquote>\n<p>action creators = logic + action</p>\n</blockquote>\n<blockquote>\n<p>reducer = state +  action creators</p>\n</blockquote>\n<p> 3.diwork<br>diwork工作台的redux如下</p>"},{"title":"高阶组件入门（2)","_content":"\n（一）前篇回顾\n-------\n\n上篇文章[React高阶组件操作入门（一）](https://github.com/iuap-design/blog/issues/241)介绍了高阶组件的实现方式之一：PP（属性代理）。\n\n其实在第一篇提到，高阶组件的使用就是涉及到两个问题：\n\n1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？\n2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？\n\n<!-- more -->\n在第一篇文章就是解答了第一个问题，答案是能！！HOC将HOCd的props,state,function,当作props传给WrappedComponent组件，WrappedComponent通过this.props取到这些内容，如下图：\n\n                          图1-1 EnhacedComponent组件传值\n\n![这里写图片描述](http://img.blog.csdn.net/20171107205438033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n                         图1-2 WrappedComponent组件接收\n![这里写图片描述](http://img.blog.csdn.net/20171107205535216?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n（二）Inheritance Inversion（反向继承）\n------------------------------\n\n**反向继承可以解决上述的第二个疑问：**\n组件wrappedComponent能否将props,state,function传递给EnhancedComponent？\n\n这里是指EnhacedComponent继承了WrappedComponent组件的生命周期、state和function。按照上篇文章提到的两点用途出发来深入理解II。\n\n - 渲染劫持（Render Highjacking） \n - 操作 state\n\n\n （2.1）渲染劫持\n\n\n> 本质就是EnhacedComponent继承了WrappedComponent组件的生命周期函数，尤其是render()函数\n\n\n```\n//Wrappedcomponent\nimport React, { Component } from 'react';\nclass Usual extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      usual: 'usual',\n    }\n  }\n\n  componentDidMount() {\n    console.log('didMount')\n  }\n \n  render() {\n    console.log(this.props);\n\n    return (\n      <div>\n        Usual\n      </div>\n    )\n  }\n}\n\nexport default Usual;\n\n```\n\n\n```\n//下面是HOC\nimport React, { Component } from 'react';\nconst iiHoc = WrappedComponent => class extends WrappedComponent {\n\t  constructor(props){\n\t  \tsuper(props);\n\t  \tthis.state = {\n\t  \t\t...this.state,\n\t  \t}\n\t  }\n\t\n\t  alertFunc = () =>{\n\t  \talert(\"HOC\");\n\t  }\n\n    render() {\n      \n      return <div>{super.render()}</div>\n     \n    }\n}\nexport default iiHoc;\n```\n这样会正常的渲染出来 Usual\n\n（2.2）操作 state\n\n\n> 本质就是EnhacedComponent继承了WrappedComponent组件的state\n\n\n\n             如图2-2-1通过this.state获取到WrappedComponent的state\n![这里写图片描述](http://img.blog.csdn.net/20171107211149475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n> 但是，关键是在EnhacedComponent的constructor中没有定义自己的state！！\n\n若是定义就会出现的问题如下图2-2-2所示\n\n     图2-2-2 EnhancedComponent的constructor中定义state,那么this.state的取值\n![这里写图片描述](http://img.blog.csdn.net/20171107211424840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nEnhacedComponent的state覆盖了Wrapped Component的state。这时候的怎么让两者并存呢？如下图2-2-3所示\n\n          图2-2-3 EnhacedComponent的state与WrappedComponent的state并存\n![这里写图片描述](http://img.blog.csdn.net/20171107211543953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n（2.3）function的继承\n这里就不多说，通过this.functionName()就可以调用到WrappedComponent中的方法。**但是有一个注意的：若是EnhancedComponent中的方法与WrappedComponent的方法重名，那么EnhacedComponent函数覆盖Wrapped Component函数。**\n\n（三）此处看一下父组件与高阶组件对比\n------------------\n\n有些同学可能会觉得高阶组件有些类似父组件的使用。例如，我们完全可以把高阶组件中的逻辑放到一个父组件中去执行，执行完成的结果再传递给子组件。从逻辑的执行流程上来看，高阶组件确实和父组件比较相像，但是高阶组件强调的是逻辑的抽象。高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI/DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。\n\n（四）使用高阶组件遇到的问题\n--------------\n（4.1）静态方法丢失\n无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。因为高阶组件返回的新组件，是不包含被包装组件的静态方法。\n具体的解决方案如下\n\n> [静态方法解决方式](https://segmentfault.com/a/1190000010845410)\n\n（4.2）refs不会传递。 \n意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。\n\n（4.3）不要在render方法内部使用高阶组件。\n简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。。因为高阶组件每次都会返回一个新的组件，在render中使用会导致每次渲染出来的组件都不相等（===），于是每次render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了。\n\n（4.4）最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。\n高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数\n\n（4.5）要给hoc添加class名，便于debugger。\n当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。\n\n```\nconst getDisplayName = component => component.displayName || component.name\nfunction hoc(WrappedComponent){\n    return class HOC extends Component {\n        static displayName = `HOC(${getDisplayName(WrappedComponent)})`\n        constructor(props) {\n        }\n        \n        componentWillMount() { \n\n        render() {\n          return ()\n        }\n    }\n}\nexport default hoc;\n```\n\n> [refs不会传递解决方法](https://segmentfault.com/a/1190000010845410)\n\n\n（五）依然存留的疑问\n----------\n\n1.上述两个问题中的第二个问题：.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？中没有解答是wrappedComponent能否将props传递给EnhancedComponent，这个没有找到资料，也许这是没有必要的操作。根据后续的深入开发以及学习中，也许会解答这个问题。\n2.属性的校验\n我们知道PropsTypes有着属性校验，那么EnhacedComponent与WrappedComponent之间的传值可以走属性校验吗？\n\n\n\n","source":"_posts/react_hoc_2.md","raw":"\n---\ntitle: \"高阶组件入门（2)\"\ntags: \n\t- \"react\"\n\t- \"hoc-react\"\n---\n\n（一）前篇回顾\n-------\n\n上篇文章[React高阶组件操作入门（一）](https://github.com/iuap-design/blog/issues/241)介绍了高阶组件的实现方式之一：PP（属性代理）。\n\n其实在第一篇提到，高阶组件的使用就是涉及到两个问题：\n\n1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？\n2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？\n\n<!-- more -->\n在第一篇文章就是解答了第一个问题，答案是能！！HOC将HOCd的props,state,function,当作props传给WrappedComponent组件，WrappedComponent通过this.props取到这些内容，如下图：\n\n                          图1-1 EnhacedComponent组件传值\n\n![这里写图片描述](http://img.blog.csdn.net/20171107205438033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n                         图1-2 WrappedComponent组件接收\n![这里写图片描述](http://img.blog.csdn.net/20171107205535216?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n（二）Inheritance Inversion（反向继承）\n------------------------------\n\n**反向继承可以解决上述的第二个疑问：**\n组件wrappedComponent能否将props,state,function传递给EnhancedComponent？\n\n这里是指EnhacedComponent继承了WrappedComponent组件的生命周期、state和function。按照上篇文章提到的两点用途出发来深入理解II。\n\n - 渲染劫持（Render Highjacking） \n - 操作 state\n\n\n （2.1）渲染劫持\n\n\n> 本质就是EnhacedComponent继承了WrappedComponent组件的生命周期函数，尤其是render()函数\n\n\n```\n//Wrappedcomponent\nimport React, { Component } from 'react';\nclass Usual extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      usual: 'usual',\n    }\n  }\n\n  componentDidMount() {\n    console.log('didMount')\n  }\n \n  render() {\n    console.log(this.props);\n\n    return (\n      <div>\n        Usual\n      </div>\n    )\n  }\n}\n\nexport default Usual;\n\n```\n\n\n```\n//下面是HOC\nimport React, { Component } from 'react';\nconst iiHoc = WrappedComponent => class extends WrappedComponent {\n\t  constructor(props){\n\t  \tsuper(props);\n\t  \tthis.state = {\n\t  \t\t...this.state,\n\t  \t}\n\t  }\n\t\n\t  alertFunc = () =>{\n\t  \talert(\"HOC\");\n\t  }\n\n    render() {\n      \n      return <div>{super.render()}</div>\n     \n    }\n}\nexport default iiHoc;\n```\n这样会正常的渲染出来 Usual\n\n（2.2）操作 state\n\n\n> 本质就是EnhacedComponent继承了WrappedComponent组件的state\n\n\n\n             如图2-2-1通过this.state获取到WrappedComponent的state\n![这里写图片描述](http://img.blog.csdn.net/20171107211149475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n\n\n> 但是，关键是在EnhacedComponent的constructor中没有定义自己的state！！\n\n若是定义就会出现的问题如下图2-2-2所示\n\n     图2-2-2 EnhancedComponent的constructor中定义state,那么this.state的取值\n![这里写图片描述](http://img.blog.csdn.net/20171107211424840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\nEnhacedComponent的state覆盖了Wrapped Component的state。这时候的怎么让两者并存呢？如下图2-2-3所示\n\n          图2-2-3 EnhacedComponent的state与WrappedComponent的state并存\n![这里写图片描述](http://img.blog.csdn.net/20171107211543953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n（2.3）function的继承\n这里就不多说，通过this.functionName()就可以调用到WrappedComponent中的方法。**但是有一个注意的：若是EnhancedComponent中的方法与WrappedComponent的方法重名，那么EnhacedComponent函数覆盖Wrapped Component函数。**\n\n（三）此处看一下父组件与高阶组件对比\n------------------\n\n有些同学可能会觉得高阶组件有些类似父组件的使用。例如，我们完全可以把高阶组件中的逻辑放到一个父组件中去执行，执行完成的结果再传递给子组件。从逻辑的执行流程上来看，高阶组件确实和父组件比较相像，但是高阶组件强调的是逻辑的抽象。高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI/DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。\n\n（四）使用高阶组件遇到的问题\n--------------\n（4.1）静态方法丢失\n无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。因为高阶组件返回的新组件，是不包含被包装组件的静态方法。\n具体的解决方案如下\n\n> [静态方法解决方式](https://segmentfault.com/a/1190000010845410)\n\n（4.2）refs不会传递。 \n意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。\n\n（4.3）不要在render方法内部使用高阶组件。\n简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。。因为高阶组件每次都会返回一个新的组件，在render中使用会导致每次渲染出来的组件都不相等（===），于是每次render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了。\n\n（4.4）最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。\n高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数\n\n（4.5）要给hoc添加class名，便于debugger。\n当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。\n\n```\nconst getDisplayName = component => component.displayName || component.name\nfunction hoc(WrappedComponent){\n    return class HOC extends Component {\n        static displayName = `HOC(${getDisplayName(WrappedComponent)})`\n        constructor(props) {\n        }\n        \n        componentWillMount() { \n\n        render() {\n          return ()\n        }\n    }\n}\nexport default hoc;\n```\n\n> [refs不会传递解决方法](https://segmentfault.com/a/1190000010845410)\n\n\n（五）依然存留的疑问\n----------\n\n1.上述两个问题中的第二个问题：.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？中没有解答是wrappedComponent能否将props传递给EnhancedComponent，这个没有找到资料，也许这是没有必要的操作。根据后续的深入开发以及学习中，也许会解答这个问题。\n2.属性的校验\n我们知道PropsTypes有着属性校验，那么EnhacedComponent与WrappedComponent之间的传值可以走属性校验吗？\n\n\n\n","slug":"react_hoc_2","published":1,"date":"2018-06-25T12:44:11.109Z","updated":"2018-07-14T10:33:43.407Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o50v0005vds6z8zny9u5","content":"<h2 id=\"（一）前篇回顾\"><a href=\"#（一）前篇回顾\" class=\"headerlink\" title=\"（一）前篇回顾\"></a>（一）前篇回顾</h2><p>上篇文章<a href=\"https://github.com/iuap-design/blog/issues/241\" target=\"_blank\" rel=\"noopener\">React高阶组件操作入门（一）</a>介绍了高阶组件的实现方式之一：PP（属性代理）。</p>\n<p>其实在第一篇提到，高阶组件的使用就是涉及到两个问题：</p>\n<p>1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？<br>2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？</p>\n<a id=\"more\"></a>\n<p>在第一篇文章就是解答了第一个问题，答案是能！！HOC将HOCd的props,state,function,当作props传给WrappedComponent组件，WrappedComponent通过this.props取到这些内容，如下图：</p>\n<pre><code>图1-1 EnhacedComponent组件传值\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107205438033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<pre><code>图1-2 WrappedComponent组件接收\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107205535216?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"（二）Inheritance-Inversion（反向继承）\"><a href=\"#（二）Inheritance-Inversion（反向继承）\" class=\"headerlink\" title=\"（二）Inheritance Inversion（反向继承）\"></a>（二）Inheritance Inversion（反向继承）</h2><p><strong>反向继承可以解决上述的第二个疑问：</strong><br>组件wrappedComponent能否将props,state,function传递给EnhancedComponent？</p>\n<p>这里是指EnhacedComponent继承了WrappedComponent组件的生命周期、state和function。按照上篇文章提到的两点用途出发来深入理解II。</p>\n<ul>\n<li>渲染劫持（Render Highjacking） </li>\n<li>操作 state</li>\n</ul>\n<p> （2.1）渲染劫持</p>\n<blockquote>\n<p>本质就是EnhacedComponent继承了WrappedComponent组件的生命周期函数，尤其是render()函数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Wrappedcomponent</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class Usual extends Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      usual: &apos;usual&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    console.log(&apos;didMount&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(this.props);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        Usual</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Usual;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面是HOC</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">const iiHoc = WrappedComponent =&gt; class extends WrappedComponent &#123;</span><br><span class=\"line\">\t  constructor(props)&#123;</span><br><span class=\"line\">\t  \tsuper(props);</span><br><span class=\"line\">\t  \tthis.state = &#123;</span><br><span class=\"line\">\t  \t\t...this.state,</span><br><span class=\"line\">\t  \t&#125;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t  alertFunc = () =&gt;&#123;</span><br><span class=\"line\">\t  \talert(&quot;HOC&quot;);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      return &lt;div&gt;&#123;super.render()&#125;&lt;/div&gt;</span><br><span class=\"line\">     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default iiHoc;</span><br></pre></td></tr></table></figure>\n<p>这样会正常的渲染出来 Usual</p>\n<p>（2.2）操作 state</p>\n<blockquote>\n<p>本质就是EnhacedComponent继承了WrappedComponent组件的state</p>\n</blockquote>\n<pre><code>如图2-2-1通过this.state获取到WrappedComponent的state\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107211149475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>但是，关键是在EnhacedComponent的constructor中没有定义自己的state！！</p>\n</blockquote>\n<p>若是定义就会出现的问题如下图2-2-2所示</p>\n<pre><code>图2-2-2 EnhancedComponent的constructor中定义state,那么this.state的取值\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107211424840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>EnhacedComponent的state覆盖了Wrapped Component的state。这时候的怎么让两者并存呢？如下图2-2-3所示</p>\n<pre><code>图2-2-3 EnhacedComponent的state与WrappedComponent的state并存\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107211543953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>（2.3）function的继承<br>这里就不多说，通过this.functionName()就可以调用到WrappedComponent中的方法。<strong>但是有一个注意的：若是EnhancedComponent中的方法与WrappedComponent的方法重名，那么EnhacedComponent函数覆盖Wrapped Component函数。</strong></p>\n<h2 id=\"（三）此处看一下父组件与高阶组件对比\"><a href=\"#（三）此处看一下父组件与高阶组件对比\" class=\"headerlink\" title=\"（三）此处看一下父组件与高阶组件对比\"></a>（三）此处看一下父组件与高阶组件对比</h2><p>有些同学可能会觉得高阶组件有些类似父组件的使用。例如，我们完全可以把高阶组件中的逻辑放到一个父组件中去执行，执行完成的结果再传递给子组件。从逻辑的执行流程上来看，高阶组件确实和父组件比较相像，但是高阶组件强调的是逻辑的抽象。高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI/DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。</p>\n<h2 id=\"（四）使用高阶组件遇到的问题\"><a href=\"#（四）使用高阶组件遇到的问题\" class=\"headerlink\" title=\"（四）使用高阶组件遇到的问题\"></a>（四）使用高阶组件遇到的问题</h2><p>（4.1）静态方法丢失<br>无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。因为高阶组件返回的新组件，是不包含被包装组件的静态方法。<br>具体的解决方案如下</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000010845410\" target=\"_blank\" rel=\"noopener\">静态方法解决方式</a></p>\n</blockquote>\n<p>（4.2）refs不会传递。<br>意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。</p>\n<p>（4.3）不要在render方法内部使用高阶组件。<br>简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。。因为高阶组件每次都会返回一个新的组件，在render中使用会导致每次渲染出来的组件都不相等（===），于是每次render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了。</p>\n<p>（4.4）最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。<br>高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数</p>\n<p>（4.5）要给hoc添加class名，便于debugger。<br>当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const getDisplayName = component =&gt; component.displayName || component.name</span><br><span class=\"line\">function hoc(WrappedComponent)&#123;</span><br><span class=\"line\">    return class HOC extends Component &#123;</span><br><span class=\"line\">        static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`</span><br><span class=\"line\">        constructor(props) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        componentWillMount() &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">          return ()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default hoc;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000010845410\" target=\"_blank\" rel=\"noopener\">refs不会传递解决方法</a></p>\n</blockquote>\n<h2 id=\"（五）依然存留的疑问\"><a href=\"#（五）依然存留的疑问\" class=\"headerlink\" title=\"（五）依然存留的疑问\"></a>（五）依然存留的疑问</h2><p>1.上述两个问题中的第二个问题：.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？中没有解答是wrappedComponent能否将props传递给EnhancedComponent，这个没有找到资料，也许这是没有必要的操作。根据后续的深入开发以及学习中，也许会解答这个问题。<br>2.属性的校验<br>我们知道PropsTypes有着属性校验，那么EnhacedComponent与WrappedComponent之间的传值可以走属性校验吗？</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"（一）前篇回顾\"><a href=\"#（一）前篇回顾\" class=\"headerlink\" title=\"（一）前篇回顾\"></a>（一）前篇回顾</h2><p>上篇文章<a href=\"https://github.com/iuap-design/blog/issues/241\" target=\"_blank\" rel=\"noopener\">React高阶组件操作入门（一）</a>介绍了高阶组件的实现方式之一：PP（属性代理）。</p>\n<p>其实在第一篇提到，高阶组件的使用就是涉及到两个问题：</p>\n<p>1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？<br>2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？</p>","more":"<p>在第一篇文章就是解答了第一个问题，答案是能！！HOC将HOCd的props,state,function,当作props传给WrappedComponent组件，WrappedComponent通过this.props取到这些内容，如下图：</p>\n<pre><code>图1-1 EnhacedComponent组件传值\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107205438033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<pre><code>图1-2 WrappedComponent组件接收\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107205535216?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<h2 id=\"（二）Inheritance-Inversion（反向继承）\"><a href=\"#（二）Inheritance-Inversion（反向继承）\" class=\"headerlink\" title=\"（二）Inheritance Inversion（反向继承）\"></a>（二）Inheritance Inversion（反向继承）</h2><p><strong>反向继承可以解决上述的第二个疑问：</strong><br>组件wrappedComponent能否将props,state,function传递给EnhancedComponent？</p>\n<p>这里是指EnhacedComponent继承了WrappedComponent组件的生命周期、state和function。按照上篇文章提到的两点用途出发来深入理解II。</p>\n<ul>\n<li>渲染劫持（Render Highjacking） </li>\n<li>操作 state</li>\n</ul>\n<p> （2.1）渲染劫持</p>\n<blockquote>\n<p>本质就是EnhacedComponent继承了WrappedComponent组件的生命周期函数，尤其是render()函数</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//Wrappedcomponent</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">class Usual extends Component &#123;</span><br><span class=\"line\">  constructor(props) &#123;</span><br><span class=\"line\">    super(props);</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      usual: &apos;usual&apos;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    console.log(&apos;didMount&apos;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    console.log(this.props);</span><br><span class=\"line\"></span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        Usual</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default Usual;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//下面是HOC</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">const iiHoc = WrappedComponent =&gt; class extends WrappedComponent &#123;</span><br><span class=\"line\">\t  constructor(props)&#123;</span><br><span class=\"line\">\t  \tsuper(props);</span><br><span class=\"line\">\t  \tthis.state = &#123;</span><br><span class=\"line\">\t  \t\t...this.state,</span><br><span class=\"line\">\t  \t&#125;</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t  alertFunc = () =&gt;&#123;</span><br><span class=\"line\">\t  \talert(&quot;HOC&quot;);</span><br><span class=\"line\">\t  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    render() &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      return &lt;div&gt;&#123;super.render()&#125;&lt;/div&gt;</span><br><span class=\"line\">     </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default iiHoc;</span><br></pre></td></tr></table></figure>\n<p>这样会正常的渲染出来 Usual</p>\n<p>（2.2）操作 state</p>\n<blockquote>\n<p>本质就是EnhacedComponent继承了WrappedComponent组件的state</p>\n</blockquote>\n<pre><code>如图2-2-1通过this.state获取到WrappedComponent的state\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107211149475?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<blockquote>\n<p>但是，关键是在EnhacedComponent的constructor中没有定义自己的state！！</p>\n</blockquote>\n<p>若是定义就会出现的问题如下图2-2-2所示</p>\n<pre><code>图2-2-2 EnhancedComponent的constructor中定义state,那么this.state的取值\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107211424840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>EnhacedComponent的state覆盖了Wrapped Component的state。这时候的怎么让两者并存呢？如下图2-2-3所示</p>\n<pre><code>图2-2-3 EnhacedComponent的state与WrappedComponent的state并存\n</code></pre><p><img src=\"http://img.blog.csdn.net/20171107211543953?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>（2.3）function的继承<br>这里就不多说，通过this.functionName()就可以调用到WrappedComponent中的方法。<strong>但是有一个注意的：若是EnhancedComponent中的方法与WrappedComponent的方法重名，那么EnhacedComponent函数覆盖Wrapped Component函数。</strong></p>\n<h2 id=\"（三）此处看一下父组件与高阶组件对比\"><a href=\"#（三）此处看一下父组件与高阶组件对比\" class=\"headerlink\" title=\"（三）此处看一下父组件与高阶组件对比\"></a>（三）此处看一下父组件与高阶组件对比</h2><p>有些同学可能会觉得高阶组件有些类似父组件的使用。例如，我们完全可以把高阶组件中的逻辑放到一个父组件中去执行，执行完成的结果再传递给子组件。从逻辑的执行流程上来看，高阶组件确实和父组件比较相像，但是高阶组件强调的是逻辑的抽象。高阶组件是一个函数，函数关注的是逻辑；父组件是一个组件，组件主要关注的是UI/DOM。如果逻辑是与DOM直接相关的，那么这部分逻辑适合放到父组件中实现；如果逻辑是与DOM不直接相关的，那么这部分逻辑适合使用高阶组件抽象，如数据校验、请求发送等。</p>\n<h2 id=\"（四）使用高阶组件遇到的问题\"><a href=\"#（四）使用高阶组件遇到的问题\" class=\"headerlink\" title=\"（四）使用高阶组件遇到的问题\"></a>（四）使用高阶组件遇到的问题</h2><p>（4.1）静态方法丢失<br>无论PP还是II的方式，WrappedComponent的静态方法都不会复制，如果要用需要我们单独复制。因为高阶组件返回的新组件，是不包含被包装组件的静态方法。<br>具体的解决方案如下</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000010845410\" target=\"_blank\" rel=\"noopener\">静态方法解决方式</a></p>\n</blockquote>\n<p>（4.2）refs不会传递。<br>意思就是HOC里指定的ref，并不会传递到子组件，如果你要使用最好写回调函数通过props传下去。</p>\n<p>（4.3）不要在render方法内部使用高阶组件。<br>简单来说react的差分算法会去比较 NowElement === OldElement, 来决定要不要替换这个elementTree。。因为高阶组件每次都会返回一个新的组件，在render中使用会导致每次渲染出来的组件都不相等（===），于是每次render，组件都会卸载（unmount），然后重新挂载（mount），既影响了效率，又丢失了组件及其子组件的状态。高阶组件最适合使用的地方是在组件定义的外部，这样就不会受到组件生命周期的影响了。</p>\n<p>（4.4）最重要的原则就是，注意高阶组件不会修改子组件，也不拷贝子组件的行为。<br>高阶组件只是通过组合的方式将子组件包装在容器组件中，是一个无副作用的纯函数</p>\n<p>（4.5）要给hoc添加class名，便于debugger。<br>当我们在chrome里应用React-Developer-Tools的时候，组件结构可以一目了然，所以DisplayName最好还是加上。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const getDisplayName = component =&gt; component.displayName || component.name</span><br><span class=\"line\">function hoc(WrappedComponent)&#123;</span><br><span class=\"line\">    return class HOC extends Component &#123;</span><br><span class=\"line\">        static displayName = `HOC($&#123;getDisplayName(WrappedComponent)&#125;)`</span><br><span class=\"line\">        constructor(props) &#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        componentWillMount() &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">        render() &#123;</span><br><span class=\"line\">          return ()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default hoc;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000010845410\" target=\"_blank\" rel=\"noopener\">refs不会传递解决方法</a></p>\n</blockquote>\n<h2 id=\"（五）依然存留的疑问\"><a href=\"#（五）依然存留的疑问\" class=\"headerlink\" title=\"（五）依然存留的疑问\"></a>（五）依然存留的疑问</h2><p>1.上述两个问题中的第二个问题：.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？中没有解答是wrappedComponent能否将props传递给EnhancedComponent，这个没有找到资料，也许这是没有必要的操作。根据后续的深入开发以及学习中，也许会解答这个问题。<br>2.属性的校验<br>我们知道PropsTypes有着属性校验，那么EnhacedComponent与WrappedComponent之间的传值可以走属性校验吗？</p>"},{"title":"高阶组件入门（1)","_content":"\n高阶组件最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。\n之前看过几篇文章介绍高阶组件，这篇文章就是动手操作一番，有时候还不得不吐槽，说好能获得到的属性跟方法为什么没有获取到？\n\n<!-- more -->\n\n一、高阶组件定义\n\n> a higher-order component is a function that takes a component and returns a new component.\n> 翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n\n还有一种写法就是：\n\n> hocFactory:: W: React.Component => E: React.Component\n> 其中 W (WrappedComponent) 是指被包裹的 React.Component，\n> E (EnhancedComponent) 指返回类型为 React.Component 的新的 HOC。\n\n二、常见的HOC 实现方式（两种）\n\n> （1）Props Proxy（属性代理）： HOC 控制传给WrappedComponent W 的 props\n> \n> 下面是用途：\n\n - 更改 props \n - 抽象 state \n - 通过 refs 获取组件实例 \n - 把 WrappedComponent 与其它 elements包装在一起\n\n> （2）Inheritance Inversion（反向继承）： HOC 继承WrappedComponent W 的生命周期、state、各种function\n> \n> 下面是用途：\n\n - 渲染劫持（Render Highjacking）\n -  操作 state\n\n\n看到上面的这些官方介绍也许会有点懵，但是总言而之：高阶组件就是牵扯到两个组件的事情，那么就有下面的两个问题：\n1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？(看完本篇就会得到答案：能，必须能啊。全部当成props传给WrappedComponent了)\n2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？\n\n下面介绍开始...\n三、Props Proxy （属性代理）— **操作props**\n（3.1）更改props\n主要是高阶组件HOC控制传入wrappedComponent的props，来修改wrappedComponent内的props。\n如下图所示:\n\n图3.1.1\nHOC将{...this.props}，{...newProps}传递给WrappedComponent\n\n![这里写图片描述](http://img.blog.csdn.net/20171102212149019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n图3.1.2\nWrappedComponent中的参数，这里不仅仅有从HOC传来的参数，还有WrappedComponent(即Base)中自带的参数。\n\n![这里写图片描述](http://img.blog.csdn.net/20171102212305710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**注意，若是props中有重名的字段，那么HOC的props将会覆盖WrappedComponent中的props.**\n**总言而之：你可以『读取，添加，修改，删除』将要传递给 WrappedComponent 的 props。**\n\n（3.2）抽象 state \n这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（[官方文档](https://reactjs.org/docs/forms.html#controlled-components)），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。*当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较（这点我也没有弄明白呢）*。看一下代码就知道怎么回事了：\n\n```\n// 普通组件Login，这里充当WrappedComponent\nimport React, { Component } from 'react';\nimport formCreate from './form-create';\n\n@formCreate  //这个用法是es7语法，下面有文章链接\nexport default class Login extends Component {\n  render() {\n    return (\n      <div>\n        <div>\n          <label id=\"username\">\n            账户\n          </label>\n          <input name=\"username\" {...this.props.getField('username')}/>\n        </div>\n        <div>\n          <label id=\"password\">\n            密码\n          </label>\n          <input name=\"password\" {...this.props.getField('password')}/>\n        </div>\n        <div onClick={this.props.handleSubmit}>提交</div>\n        <div>other content</div>\n      </div>\n    )\n  }\n}\n\n//HOC，高阶组件从这里开始\nimport React, { Component } from 'react';\n\nconst formCreate = WrappedComponent => class extends Component {\n\n  constructor() {\n    super();\n    this.state = {\n      fields: {},\n    }\n  }\n  //是下面方法 getField()用到的\n  onChange = key => e => {\n    const { fields } = this.state;\n    fields[key] = e.target.value;\n    this.setState({\n      fields,\n    })\n  }\n  \n  handleSubmit = () => {\n    console.log(this.state.fields);\n  }\n  \n  getField = fieldName => {\n    return {\n      onChange: this.onChange(fieldName),\n    }\n  }\n  \n  render() {\n    const props = {\n      ...this.props,\n      handleSubmit: this.handleSubmit,\n      getField: this.getField,\n    }\n    return (<WrappedComponent\n      {...props}\n    />);\n  }\n};\nexport default formCreate;\n```\n**关键：这里我们把state，onChange等方法都放到HOC里**，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。\n\n（3.3）通过 refs 获取组件实例\n当我们包装WrappedComponent的时候，想获取到它的实例怎么办，可以通过引用(ref),在WrappedComponent组件挂载的时候，会执行ref的回调函数，在HOC中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。\n\n```\nimport React, { Component } from 'react';\n\nconst refHoc = WrappedComponent => class extends Component {\n\n  componentDidMount() {\n    console.log(this.instanceComponent, 'instanceComponent');\n  }\n\n  render() {\n    return (<WrappedComponent\n      {...this.props}\n      ref={instanceComponent => this.instanceComponent = instanceComponent}\n    />);\n  }\n};\n\nexport default refHoc;\n```\n（3.4）把 WrappedComponent 与其它 elements包装在一起\n这一点就是很简单且容易理解：出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。*一些基本的用法也可以使用正常的父组件来实现*。\n\n> 此处看一下父组件能做和不能做的事情（与高阶组件对比）：\n>1.操作 props\n>2.抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。\n>3.与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。\n>4.Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。\n>5.父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。\n\n通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。\n下一篇会继续介绍一下II\n\n[高阶组件的es7语法@装饰器](https://github.com/iuap-design/blog/issues/128)\n","source":"_posts/react_hoc_1.md","raw":"\n---\ntitle: \"高阶组件入门（1)\"\ntags: \n\t- \"react\"\n\t- \"hoc-react\"\n---\n\n高阶组件最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。\n之前看过几篇文章介绍高阶组件，这篇文章就是动手操作一番，有时候还不得不吐槽，说好能获得到的属性跟方法为什么没有获取到？\n\n<!-- more -->\n\n一、高阶组件定义\n\n> a higher-order component is a function that takes a component and returns a new component.\n> 翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。\n\n还有一种写法就是：\n\n> hocFactory:: W: React.Component => E: React.Component\n> 其中 W (WrappedComponent) 是指被包裹的 React.Component，\n> E (EnhancedComponent) 指返回类型为 React.Component 的新的 HOC。\n\n二、常见的HOC 实现方式（两种）\n\n> （1）Props Proxy（属性代理）： HOC 控制传给WrappedComponent W 的 props\n> \n> 下面是用途：\n\n - 更改 props \n - 抽象 state \n - 通过 refs 获取组件实例 \n - 把 WrappedComponent 与其它 elements包装在一起\n\n> （2）Inheritance Inversion（反向继承）： HOC 继承WrappedComponent W 的生命周期、state、各种function\n> \n> 下面是用途：\n\n - 渲染劫持（Render Highjacking）\n -  操作 state\n\n\n看到上面的这些官方介绍也许会有点懵，但是总言而之：高阶组件就是牵扯到两个组件的事情，那么就有下面的两个问题：\n1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？(看完本篇就会得到答案：能，必须能啊。全部当成props传给WrappedComponent了)\n2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？\n\n下面介绍开始...\n三、Props Proxy （属性代理）— **操作props**\n（3.1）更改props\n主要是高阶组件HOC控制传入wrappedComponent的props，来修改wrappedComponent内的props。\n如下图所示:\n\n图3.1.1\nHOC将{...this.props}，{...newProps}传递给WrappedComponent\n\n![这里写图片描述](http://img.blog.csdn.net/20171102212149019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n图3.1.2\nWrappedComponent中的参数，这里不仅仅有从HOC传来的参数，还有WrappedComponent(即Base)中自带的参数。\n\n![这里写图片描述](http://img.blog.csdn.net/20171102212305710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n\n**注意，若是props中有重名的字段，那么HOC的props将会覆盖WrappedComponent中的props.**\n**总言而之：你可以『读取，添加，修改，删除』将要传递给 WrappedComponent 的 props。**\n\n（3.2）抽象 state \n这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（[官方文档](https://reactjs.org/docs/forms.html#controlled-components)），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。*当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较（这点我也没有弄明白呢）*。看一下代码就知道怎么回事了：\n\n```\n// 普通组件Login，这里充当WrappedComponent\nimport React, { Component } from 'react';\nimport formCreate from './form-create';\n\n@formCreate  //这个用法是es7语法，下面有文章链接\nexport default class Login extends Component {\n  render() {\n    return (\n      <div>\n        <div>\n          <label id=\"username\">\n            账户\n          </label>\n          <input name=\"username\" {...this.props.getField('username')}/>\n        </div>\n        <div>\n          <label id=\"password\">\n            密码\n          </label>\n          <input name=\"password\" {...this.props.getField('password')}/>\n        </div>\n        <div onClick={this.props.handleSubmit}>提交</div>\n        <div>other content</div>\n      </div>\n    )\n  }\n}\n\n//HOC，高阶组件从这里开始\nimport React, { Component } from 'react';\n\nconst formCreate = WrappedComponent => class extends Component {\n\n  constructor() {\n    super();\n    this.state = {\n      fields: {},\n    }\n  }\n  //是下面方法 getField()用到的\n  onChange = key => e => {\n    const { fields } = this.state;\n    fields[key] = e.target.value;\n    this.setState({\n      fields,\n    })\n  }\n  \n  handleSubmit = () => {\n    console.log(this.state.fields);\n  }\n  \n  getField = fieldName => {\n    return {\n      onChange: this.onChange(fieldName),\n    }\n  }\n  \n  render() {\n    const props = {\n      ...this.props,\n      handleSubmit: this.handleSubmit,\n      getField: this.getField,\n    }\n    return (<WrappedComponent\n      {...props}\n    />);\n  }\n};\nexport default formCreate;\n```\n**关键：这里我们把state，onChange等方法都放到HOC里**，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。\n\n（3.3）通过 refs 获取组件实例\n当我们包装WrappedComponent的时候，想获取到它的实例怎么办，可以通过引用(ref),在WrappedComponent组件挂载的时候，会执行ref的回调函数，在HOC中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。\n\n```\nimport React, { Component } from 'react';\n\nconst refHoc = WrappedComponent => class extends Component {\n\n  componentDidMount() {\n    console.log(this.instanceComponent, 'instanceComponent');\n  }\n\n  render() {\n    return (<WrappedComponent\n      {...this.props}\n      ref={instanceComponent => this.instanceComponent = instanceComponent}\n    />);\n  }\n};\n\nexport default refHoc;\n```\n（3.4）把 WrappedComponent 与其它 elements包装在一起\n这一点就是很简单且容易理解：出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。*一些基本的用法也可以使用正常的父组件来实现*。\n\n> 此处看一下父组件能做和不能做的事情（与高阶组件对比）：\n>1.操作 props\n>2.抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。\n>3.与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。\n>4.Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。\n>5.父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。\n\n通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。\n下一篇会继续介绍一下II\n\n[高阶组件的es7语法@装饰器](https://github.com/iuap-design/blog/issues/128)\n","slug":"react_hoc_1","published":1,"date":"2018-06-25T12:44:11.108Z","updated":"2018-07-14T10:32:38.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o50x0007vds6ekwdzxj9","content":"<p>高阶组件最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。<br>之前看过几篇文章介绍高阶组件，这篇文章就是动手操作一番，有时候还不得不吐槽，说好能获得到的属性跟方法为什么没有获取到？</p>\n<a id=\"more\"></a>\n<p>一、高阶组件定义</p>\n<blockquote>\n<p>a higher-order component is a function that takes a component and returns a new component.<br>翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</p>\n</blockquote>\n<p>还有一种写法就是：</p>\n<blockquote>\n<p>hocFactory:: W: React.Component =&gt; E: React.Component<br>其中 W (WrappedComponent) 是指被包裹的 React.Component，<br>E (EnhancedComponent) 指返回类型为 React.Component 的新的 HOC。</p>\n</blockquote>\n<p>二、常见的HOC 实现方式（两种）</p>\n<blockquote>\n<p>（1）Props Proxy（属性代理）： HOC 控制传给WrappedComponent W 的 props</p>\n<p>下面是用途：</p>\n</blockquote>\n<ul>\n<li>更改 props </li>\n<li>抽象 state </li>\n<li>通过 refs 获取组件实例 </li>\n<li>把 WrappedComponent 与其它 elements包装在一起</li>\n</ul>\n<blockquote>\n<p>（2）Inheritance Inversion（反向继承）： HOC 继承WrappedComponent W 的生命周期、state、各种function</p>\n<p>下面是用途：</p>\n</blockquote>\n<ul>\n<li>渲染劫持（Render Highjacking）</li>\n<li>操作 state</li>\n</ul>\n<p>看到上面的这些官方介绍也许会有点懵，但是总言而之：高阶组件就是牵扯到两个组件的事情，那么就有下面的两个问题：<br>1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？(看完本篇就会得到答案：能，必须能啊。全部当成props传给WrappedComponent了)<br>2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？</p>\n<p>下面介绍开始…<br>三、Props Proxy （属性代理）— <strong>操作props</strong><br>（3.1）更改props<br>主要是高阶组件HOC控制传入wrappedComponent的props，来修改wrappedComponent内的props。<br>如下图所示:</p>\n<p>图3.1.1<br>HOC将{…this.props}，{…newProps}传递给WrappedComponent</p>\n<p><img src=\"http://img.blog.csdn.net/20171102212149019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>图3.1.2<br>WrappedComponent中的参数，这里不仅仅有从HOC传来的参数，还有WrappedComponent(即Base)中自带的参数。</p>\n<p><img src=\"http://img.blog.csdn.net/20171102212305710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><strong>注意，若是props中有重名的字段，那么HOC的props将会覆盖WrappedComponent中的props.</strong><br><strong>总言而之：你可以『读取，添加，修改，删除』将要传递给 WrappedComponent 的 props。</strong></p>\n<p>（3.2）抽象 state<br>这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（<a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">官方文档</a>），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。<em>当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较（这点我也没有弄明白呢）</em>。看一下代码就知道怎么回事了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通组件Login，这里充当WrappedComponent</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">import formCreate from &apos;./form-create&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">@formCreate  //这个用法是es7语法，下面有文章链接</span><br><span class=\"line\">export default class Login extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;label id=&quot;username&quot;&gt;</span><br><span class=\"line\">            账户</span><br><span class=\"line\">          &lt;/label&gt;</span><br><span class=\"line\">          &lt;input name=&quot;username&quot; &#123;...this.props.getField(&apos;username&apos;)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;label id=&quot;password&quot;&gt;</span><br><span class=\"line\">            密码</span><br><span class=\"line\">          &lt;/label&gt;</span><br><span class=\"line\">          &lt;input name=&quot;password&quot; &#123;...this.props.getField(&apos;password&apos;)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;this.props.handleSubmit&#125;&gt;提交&lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;other content&lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//HOC，高阶组件从这里开始</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const formCreate = WrappedComponent =&gt; class extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      fields: &#123;&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //是下面方法 getField()用到的</span><br><span class=\"line\">  onChange = key =&gt; e =&gt; &#123;</span><br><span class=\"line\">    const &#123; fields &#125; = this.state;</span><br><span class=\"line\">    fields[key] = e.target.value;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      fields,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  handleSubmit = () =&gt; &#123;</span><br><span class=\"line\">    console.log(this.state.fields);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  getField = fieldName =&gt; &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      onChange: this.onChange(fieldName),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const props = &#123;</span><br><span class=\"line\">      ...this.props,</span><br><span class=\"line\">      handleSubmit: this.handleSubmit,</span><br><span class=\"line\">      getField: this.getField,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (&lt;WrappedComponent</span><br><span class=\"line\">      &#123;...props&#125;</span><br><span class=\"line\">    /&gt;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default formCreate;</span><br></pre></td></tr></table></figure>\n<p><strong>关键：这里我们把state，onChange等方法都放到HOC里</strong>，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。</p>\n<p>（3.3）通过 refs 获取组件实例<br>当我们包装WrappedComponent的时候，想获取到它的实例怎么办，可以通过引用(ref),在WrappedComponent组件挂载的时候，会执行ref的回调函数，在HOC中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const refHoc = WrappedComponent =&gt; class extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    console.log(this.instanceComponent, &apos;instanceComponent&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (&lt;WrappedComponent</span><br><span class=\"line\">      &#123;...this.props&#125;</span><br><span class=\"line\">      ref=&#123;instanceComponent =&gt; this.instanceComponent = instanceComponent&#125;</span><br><span class=\"line\">    /&gt;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default refHoc;</span><br></pre></td></tr></table></figure>\n<p>（3.4）把 WrappedComponent 与其它 elements包装在一起<br>这一点就是很简单且容易理解：出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。<em>一些基本的用法也可以使用正常的父组件来实现</em>。</p>\n<blockquote>\n<p>此处看一下父组件能做和不能做的事情（与高阶组件对比）：<br>1.操作 props<br>2.抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。<br>3.与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。<br>4.Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。<br>5.父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。</p>\n</blockquote>\n<p>通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。<br>下一篇会继续介绍一下II</p>\n<p><a href=\"https://github.com/iuap-design/blog/issues/128\" target=\"_blank\" rel=\"noopener\">高阶组件的es7语法@装饰器</a></p>\n","site":{"data":{}},"excerpt":"<p>高阶组件最大的特点就是重用组件逻辑。它并不是由React API定义出来的功能，而是由React的组合特性衍生出来的一种设计模式。<br>之前看过几篇文章介绍高阶组件，这篇文章就是动手操作一番，有时候还不得不吐槽，说好能获得到的属性跟方法为什么没有获取到？</p>","more":"<p>一、高阶组件定义</p>\n<blockquote>\n<p>a higher-order component is a function that takes a component and returns a new component.<br>翻译：高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件。</p>\n</blockquote>\n<p>还有一种写法就是：</p>\n<blockquote>\n<p>hocFactory:: W: React.Component =&gt; E: React.Component<br>其中 W (WrappedComponent) 是指被包裹的 React.Component，<br>E (EnhancedComponent) 指返回类型为 React.Component 的新的 HOC。</p>\n</blockquote>\n<p>二、常见的HOC 实现方式（两种）</p>\n<blockquote>\n<p>（1）Props Proxy（属性代理）： HOC 控制传给WrappedComponent W 的 props</p>\n<p>下面是用途：</p>\n</blockquote>\n<ul>\n<li>更改 props </li>\n<li>抽象 state </li>\n<li>通过 refs 获取组件实例 </li>\n<li>把 WrappedComponent 与其它 elements包装在一起</li>\n</ul>\n<blockquote>\n<p>（2）Inheritance Inversion（反向继承）： HOC 继承WrappedComponent W 的生命周期、state、各种function</p>\n<p>下面是用途：</p>\n</blockquote>\n<ul>\n<li>渲染劫持（Render Highjacking）</li>\n<li>操作 state</li>\n</ul>\n<p>看到上面的这些官方介绍也许会有点懵，但是总言而之：高阶组件就是牵扯到两个组件的事情，那么就有下面的两个问题：<br>1.高阶组件EnhanceComponent能否将props,state,function传递给wrappedComponent？(看完本篇就会得到答案：能，必须能啊。全部当成props传给WrappedComponent了)<br>2.组件wrappedComponent能否将props,state,function传递给EnhancedComponent？</p>\n<p>下面介绍开始…<br>三、Props Proxy （属性代理）— <strong>操作props</strong><br>（3.1）更改props<br>主要是高阶组件HOC控制传入wrappedComponent的props，来修改wrappedComponent内的props。<br>如下图所示:</p>\n<p>图3.1.1<br>HOC将{…this.props}，{…newProps}传递给WrappedComponent</p>\n<p><img src=\"http://img.blog.csdn.net/20171102212149019?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>图3.1.2<br>WrappedComponent中的参数，这里不仅仅有从HOC传来的参数，还有WrappedComponent(即Base)中自带的参数。</p>\n<p><img src=\"http://img.blog.csdn.net/20171102212305710?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZGVyX3Bvb2w=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p><strong>注意，若是props中有重名的字段，那么HOC的props将会覆盖WrappedComponent中的props.</strong><br><strong>总言而之：你可以『读取，添加，修改，删除』将要传递给 WrappedComponent 的 props。</strong></p>\n<p>（3.2）抽象 state<br>这里不是通过ref获取state， 而是通过 { props, 回调函数 } 传递给wrappedComponent组件，通过回调函数获取state。这里用的比较多的就是react处理表单的时候。通常react在处理表单的时候，一般使用的是受控组件（<a href=\"https://reactjs.org/docs/forms.html#controlled-components\" target=\"_blank\" rel=\"noopener\">官方文档</a>），即把input都做成受控的，改变value的时候，用onChange事件同步到state中。<em>当然这种操作通过Container组件也可以做到，具体的区别放到后面去比较（这点我也没有弄明白呢）</em>。看一下代码就知道怎么回事了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 普通组件Login，这里充当WrappedComponent</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\">import formCreate from &apos;./form-create&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">@formCreate  //这个用法是es7语法，下面有文章链接</span><br><span class=\"line\">export default class Login extends Component &#123;</span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (</span><br><span class=\"line\">      &lt;div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;label id=&quot;username&quot;&gt;</span><br><span class=\"line\">            账户</span><br><span class=\"line\">          &lt;/label&gt;</span><br><span class=\"line\">          &lt;input name=&quot;username&quot; &#123;...this.props.getField(&apos;username&apos;)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">          &lt;label id=&quot;password&quot;&gt;</span><br><span class=\"line\">            密码</span><br><span class=\"line\">          &lt;/label&gt;</span><br><span class=\"line\">          &lt;input name=&quot;password&quot; &#123;...this.props.getField(&apos;password&apos;)&#125;/&gt;</span><br><span class=\"line\">        &lt;/div&gt;</span><br><span class=\"line\">        &lt;div onClick=&#123;this.props.handleSubmit&#125;&gt;提交&lt;/div&gt;</span><br><span class=\"line\">        &lt;div&gt;other content&lt;/div&gt;</span><br><span class=\"line\">      &lt;/div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//HOC，高阶组件从这里开始</span><br><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const formCreate = WrappedComponent =&gt; class extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor() &#123;</span><br><span class=\"line\">    super();</span><br><span class=\"line\">    this.state = &#123;</span><br><span class=\"line\">      fields: &#123;&#125;,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  //是下面方法 getField()用到的</span><br><span class=\"line\">  onChange = key =&gt; e =&gt; &#123;</span><br><span class=\"line\">    const &#123; fields &#125; = this.state;</span><br><span class=\"line\">    fields[key] = e.target.value;</span><br><span class=\"line\">    this.setState(&#123;</span><br><span class=\"line\">      fields,</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  handleSubmit = () =&gt; &#123;</span><br><span class=\"line\">    console.log(this.state.fields);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  getField = fieldName =&gt; &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      onChange: this.onChange(fieldName),</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    const props = &#123;</span><br><span class=\"line\">      ...this.props,</span><br><span class=\"line\">      handleSubmit: this.handleSubmit,</span><br><span class=\"line\">      getField: this.getField,</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (&lt;WrappedComponent</span><br><span class=\"line\">      &#123;...props&#125;</span><br><span class=\"line\">    /&gt;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">export default formCreate;</span><br></pre></td></tr></table></figure>\n<p><strong>关键：这里我们把state，onChange等方法都放到HOC里</strong>，其实是遵从的react组件的一种规范，子组件简单，傻瓜，负责展示，逻辑与操作放到Container。比如说我们在HOC获取到用户名密码之后，再去做其他操作，就方便多了，而state，处理函数放到Form组件里，只会让Form更加笨重，承担了本不属于它的工作，这样我们可能其他地方也需要用到这个组件，但是处理方式稍微不同，就很麻烦了。</p>\n<p>（3.3）通过 refs 获取组件实例<br>当我们包装WrappedComponent的时候，想获取到它的实例怎么办，可以通过引用(ref),在WrappedComponent组件挂载的时候，会执行ref的回调函数，在HOC中取到组件的实例。通过打印，可以看到它的props， state，都是可以取到的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">const refHoc = WrappedComponent =&gt; class extends Component &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  componentDidMount() &#123;</span><br><span class=\"line\">    console.log(this.instanceComponent, &apos;instanceComponent&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return (&lt;WrappedComponent</span><br><span class=\"line\">      &#123;...this.props&#125;</span><br><span class=\"line\">      ref=&#123;instanceComponent =&gt; this.instanceComponent = instanceComponent&#125;</span><br><span class=\"line\">    /&gt;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">export default refHoc;</span><br></pre></td></tr></table></figure>\n<p>（3.4）把 WrappedComponent 与其它 elements包装在一起<br>这一点就是很简单且容易理解：出于操作样式、布局或其它目的，你可以将 WrappedComponent 与其它组件包装在一起。<em>一些基本的用法也可以使用正常的父组件来实现</em>。</p>\n<blockquote>\n<p>此处看一下父组件能做和不能做的事情（与高阶组件对比）：<br>1.操作 props<br>2.抽象 state。但是有缺点，不能再父组件外获取到它的 state，除非明确地实现了钩子。<br>3.与新的 React Element 包装。这似乎是唯一一点，使用父组件要比高阶组件强，但高阶组件也同样可以实现。<br>4.Children 的操控。如果 children 不是单一 root，则需要多添加一层来包括所有 children，可能会使你的 markup 变得有点笨重。使用高阶组件可以保证单一 root。<br>5.父组件可以在元素树立随意使用，它们不像高阶组件一样限制于一个组件。</p>\n</blockquote>\n<p>通常来讲，能使用父组件达到的效果，尽量不要用高阶组件，因为高阶组件是一种更 hack 的方法，但同时也有更高的灵活性。<br>下一篇会继续介绍一下II</p>\n<p><a href=\"https://github.com/iuap-design/blog/issues/128\" target=\"_blank\" rel=\"noopener\">高阶组件的es7语法@装饰器</a></p>"},{"title":"webpack单页多页初试水","date":"2018-08-27T08:05:40.000Z","_content":"","source":"_posts/webpack单页多页初试水.md","raw":"---\ntitle: webpack单页多页初试水\ndate: 2018-08-27 16:05:40\ntags:\n---\n","slug":"webpack单页多页初试水","published":1,"updated":"2018-08-27T08:05:40.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o50z0009vds6tjm94nc8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"前端模块化（一）","date":"2018-08-27T06:08:43.000Z","_content":"综述：\n    在互联网应用越来越复杂，不可避免的需要工具来管理我们的前端代码。以前是一个巨大的脚本文件，如今希望可以将文件写入不同的文件模块，并且希望代码可以重用，可以简单地引用和添加各种各样的依赖到我们的项目。\n<!-- more -->\n1.简述前端为什么需要模块化开发\n\n  如果按照以往的以页面为单位的开发，会导致很多问题，类似依赖管理、命名冲突等等问题。\n\n**命名冲突是最常见的问题，描述如下**：\n\n  //在util.js中\n\n```\n   function log(message){\n   }\n```\n\n   //在logger.js中\n\n```\n  function log(message){\n   }\n```\n\n   因此如果在页面的script标签同时依赖这两个文件的时候就会产生冲突，导致后面的函数会被覆盖。从而可能产生一些预料之外的结果。\n\n**传统的解决方案是使用命名空间：**\n\n   //在util.js中\n\n```\n   function util.log(message){\n   }\n```\n\n   //在logger.js中\n\n```\n  function logger.log(message){\n   }\n```\n\n这样带来的显而易见的问题是：**所有的代码会变得冗余并且编写困难**\n\n如果使用模块化编写方案，如使用**CMD（Common Module Definition）**，代码依赖就会变得格外简单。\n\n> 先简单介绍一下CMD，**一个模块用define关键词来定义**，即define（factory)\n> \n> factory可以是一个函数也可以是其他的变量；如果factory是一个函数的话，那它三个参数分别是：require，exports，module即可以用来定义一个模块的内容：\n> \n>    define(function(require, exports, module) {  \n> \n> ```\n>   // The module code goes here  \n> \n> });\n> ```\n> \n> 引用模块用require关键词，接受一个模块名作为参数，返回模块暴漏的API作为返回结果。若不成功则返回null。示例如下：\n\n紧接上面继续：\n\n```\n// util.js \nvar log = function(message) { \n\n} \n\nmodule.exports = log \n\n// logger.js \nvar log = function(message) { \n\n} \nmodule.exports = log \n```\n\n   **// app.js using util.js log for logging**\n\n```\nvar log =require(\"util.js\") \n\nlog(\"Hello Module Definition\")\n```\n\n此时，util.js与logger.js不会相互冲突，它们会被工具包装为CMD下的定义方式。然后通过依赖的方式来解决冲突。\n\n2.细说前端模块化\n\n 在Javascript发展初期就是为了实现简单的页面交互逻辑，寥寥数句即可；如今，很多页面的逻辑迁移到客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛的应用，Jquery等前端库层出不穷，前端代码日益膨胀。\n\n 而**javascript**，**甚至没有类的概念，更不用说模块(module)了**。\n\n 2.1 模块(Java)\n\n这里首先借鉴一下其他语言是如何处理大规模程序设计的，在Java中有一个重要的概念——`package`即：`逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，`在外面直接使用`import`对应的package即可，如：\n\n```\nimport java.uti.ArrayList\n```\n\n 2.2 模块（Javascript）\n\n Javascript在设计时定位的原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的Javascript代码，我们称为模块化。\n\n 有了模块，我们就可以更方便的使用别人的代码。\n\n 模块开发需要遵循一定的规范，各行其是就都乱套了。规范形成的过程是痛苦的，发展到现在初具规模。\n\n 2.2.1 函数封装\n\nJavaScript的**作用域就是基于函数的**，所以把**函数作为模块化**的第一步是很自然的事情，在一个文件里面编写几个相关函数就是**最开始的模块**了\n\n```\nfunction fn1(){\nstatement\n}\n\nfunction fn2(){\nstatement\n}\n```\n\n缺点：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。\n\n2.2.2对象\n为了解决上面的问题，对象的写法应运而生，可以把**所有的模块成员****封装在一个对象**中\n\n```\nvar myModule = {\nvar1: 1,\n\nvar2: 2,\n\nfn1: function(){\n\n},\n\nfn2: function(){\n\n}\n}\n```\n\n这样我们在希望调用模块的时候引用对应文件，然后\n\n```\nmyModule.fn2();\n```\n\n这样避免了变量污染，只要**保证模块名唯一**即可，同时同一模块内的成员也有了关系\n\n看似不错的解决方案，但是也有**缺陷**，外部可以随意修改内部成员\n\nmyModel.var1 = 100;\n这样就会产生意外的**安全问题**\n\n2.2.3立即执行函数\n\n可以通过立即执行函数，来达到隐藏细节的目的\n\n```\nvar myModule = (function(){\nvar var1 = 1;\nvar var2 = 2;\n\nfunction fn1(){\n\n}\n\nfunction fn2(){\n\n}\n\nreturn {\nfn1: fn1,\nfn2: fn2\n};\n})();\n```\n\n这样在模块外部无法修改我们没有暴露出来的变量、函数\n\n上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD\n\n3.Javascript的模块规范（CommonJS、AMD、CMD）\n\n_3.1CommonJS_\n\n我们先从CommonJS谈起，因为在网页端没有模块化编程（虽然页面JavaScript逻辑复杂，但也可以工作下去），在**服务器端**却一定要有模块，所以第一个流行的模块化规范由服务器端的JavaScript应用带来，**CommonJS规范**是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。\n\n**（1）定义模块：**\n\n根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性\n\n**（2）模块输出：**\n\n**模块只有一个出口，module.exports对象**，我们需要把模块希望输出的内容放入该对象\n\n**（3）加载模块：**\n\n**加载模块使用require方法**，该方法读取一个文件并执行，返回文件内部的module.exports对象\n\n看个例子\n\n   //模块定义 myModel.js\n\n```\nvar name = 'Byron';\n\nfunction printName(){\nconsole.log(name);\n}\n\nfunction printFullName(firstName){\nconsole.log(firstName + name);\n}\n\nmodule.exports = {\nprintName: printName,\nprintFullName: printFullName\n}\n```\n\n   //加载模块\n\n```\nvar nameModule = require('./myModel.js');\n\nnameModule.printName();\n```\n\n不同的实现对require时的路径有不同要求，一般情况可以省略`js`拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）\n\n  （4）尴尬的浏览器\n\n上面的代码，`require`是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块的接口，但是这在**浏览器端**实现却会遇到很多问题。\n\n  浏览器端，加载JavaScript最佳、最容易的方式是在document中插入`script`标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。\n\n  解决思路之一是，开发一个**服务器端组件**，对模块代码作静态分析，将模块与它的依赖列表**一起返回给**浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。\n\n  另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧。\n\n  3.2AMD\n  AMD即`Asynchromous Module Defination`，中文是异步模块定义的意思，他就是**浏览器端模块化**开发的规范。\n\n   由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上现有RequireJS再有的AMD。\n\n  requireJS主要解决两个问题\n\n  （1）多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\n （2）**js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长**\n\n看一个使用requireJS的例子\n\n// 定义模块 myModule.js\n\n```\ndefine(['dependency'], function(){\nvar name = 'Byron';\nfunction printName(){\nconsole.log(name);\n}\n\nreturn {\nprintName: printName\n};\n});\n```\n\n // 加载模块\n\n```\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n3.2.1语法\nrequireJS定义了一个函数 define，它是全局变量，用来定义模块。\n\n（1）**define**，它是全局变量，用来**定义模块**\n\n```\ndefine(id?, dependencies?, factory);\n```\n\n1）id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\n2）dependencies：是一个当前模块依赖的模块名称数组\n\n3）factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n\n（2）在页面上使用**require**函数**加载模块**\n\n```\nrequire([dependencies], function(){});\n```\n\nrequire()函数接受两个参数\n\n1）第一个参数是一个数组，表示所依赖的模块\n\n2）第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\nrequire()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n\n3.3CMD\n\nCMD即`Common Module Definition`，通过模块定义。AMD有个RequireJS，CMD有个浏览器实现的SeaJS，SeaJS要解决的问题和RequireJS一样，只不过在**模块定义**方式和**模块加载**（可以说运行、解析）时机上有所不同。\n\n3.3.1语法\n\nSea.js 推崇一个模块一个文件，遵循统一的写法\n\n**（1）define**\n\n```\ndefine(id?, deps?, factory)\n```\n\nCMD推崇\n\n1）一个文件一个模块，所以经常就用文件名作为模块id\n\n2）CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。\n\n（2）factory有三个参数\n\n```\nfunction(require, exports, module)\n```\n\n**1）require**\n\nrequire是factory函数的第一个参数\n\n```\nrequire（id）\n```\n\nrequire是一个方法，接受**模块标识**作为唯一的参数，用来获取其他模块提供的接口\n\n**2）exports**\n\nexports是一个对象，用来向外提供模块的接口\n\n**3）module**\n\nmodule是一个对象，上面存储了与当前模块相关联的属性和方法\n\n看一个使用CMD的例子\n\n// 定义模块  myModule.js\n\n```\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n```\n\n// 加载模块\n    seajs.use(['myModule.js'], function(my){\n\n```\n});\n```\n\n4.AMD与CMD区别\n\n关于这两个的区别网上可以搜出一堆文章，简单总结一下\n\n最明显的区别就是在模块定义时对**依赖的处理不同**\n\n（1）AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块\n\n（2）CMD推崇就近依赖，只有在用到某个模块的时候再去require\n\n这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法\n\nAMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同\n\n很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是**不准确的**，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略\n\n为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是**依赖模块的执行顺序和书写顺序不一定一致**，**看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行**\n\nCMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，**这样模块的执行顺序和书写顺序是完全一致的**\n\n这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因\n\n> 参考\n> http://www.cnblogs.com/dolphinX/p/4381855.html\n","source":"_posts/前端模块化（一）.md","raw":"---\ntitle: 前端模块化（一）\ndate: 2018-08-27 14:08:43\ntags: 模块化\n---\n综述：\n    在互联网应用越来越复杂，不可避免的需要工具来管理我们的前端代码。以前是一个巨大的脚本文件，如今希望可以将文件写入不同的文件模块，并且希望代码可以重用，可以简单地引用和添加各种各样的依赖到我们的项目。\n<!-- more -->\n1.简述前端为什么需要模块化开发\n\n  如果按照以往的以页面为单位的开发，会导致很多问题，类似依赖管理、命名冲突等等问题。\n\n**命名冲突是最常见的问题，描述如下**：\n\n  //在util.js中\n\n```\n   function log(message){\n   }\n```\n\n   //在logger.js中\n\n```\n  function log(message){\n   }\n```\n\n   因此如果在页面的script标签同时依赖这两个文件的时候就会产生冲突，导致后面的函数会被覆盖。从而可能产生一些预料之外的结果。\n\n**传统的解决方案是使用命名空间：**\n\n   //在util.js中\n\n```\n   function util.log(message){\n   }\n```\n\n   //在logger.js中\n\n```\n  function logger.log(message){\n   }\n```\n\n这样带来的显而易见的问题是：**所有的代码会变得冗余并且编写困难**\n\n如果使用模块化编写方案，如使用**CMD（Common Module Definition）**，代码依赖就会变得格外简单。\n\n> 先简单介绍一下CMD，**一个模块用define关键词来定义**，即define（factory)\n> \n> factory可以是一个函数也可以是其他的变量；如果factory是一个函数的话，那它三个参数分别是：require，exports，module即可以用来定义一个模块的内容：\n> \n>    define(function(require, exports, module) {  \n> \n> ```\n>   // The module code goes here  \n> \n> });\n> ```\n> \n> 引用模块用require关键词，接受一个模块名作为参数，返回模块暴漏的API作为返回结果。若不成功则返回null。示例如下：\n\n紧接上面继续：\n\n```\n// util.js \nvar log = function(message) { \n\n} \n\nmodule.exports = log \n\n// logger.js \nvar log = function(message) { \n\n} \nmodule.exports = log \n```\n\n   **// app.js using util.js log for logging**\n\n```\nvar log =require(\"util.js\") \n\nlog(\"Hello Module Definition\")\n```\n\n此时，util.js与logger.js不会相互冲突，它们会被工具包装为CMD下的定义方式。然后通过依赖的方式来解决冲突。\n\n2.细说前端模块化\n\n 在Javascript发展初期就是为了实现简单的页面交互逻辑，寥寥数句即可；如今，很多页面的逻辑迁移到客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛的应用，Jquery等前端库层出不穷，前端代码日益膨胀。\n\n 而**javascript**，**甚至没有类的概念，更不用说模块(module)了**。\n\n 2.1 模块(Java)\n\n这里首先借鉴一下其他语言是如何处理大规模程序设计的，在Java中有一个重要的概念——`package`即：`逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，`在外面直接使用`import`对应的package即可，如：\n\n```\nimport java.uti.ArrayList\n```\n\n 2.2 模块（Javascript）\n\n Javascript在设计时定位的原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的Javascript代码，我们称为模块化。\n\n 有了模块，我们就可以更方便的使用别人的代码。\n\n 模块开发需要遵循一定的规范，各行其是就都乱套了。规范形成的过程是痛苦的，发展到现在初具规模。\n\n 2.2.1 函数封装\n\nJavaScript的**作用域就是基于函数的**，所以把**函数作为模块化**的第一步是很自然的事情，在一个文件里面编写几个相关函数就是**最开始的模块**了\n\n```\nfunction fn1(){\nstatement\n}\n\nfunction fn2(){\nstatement\n}\n```\n\n缺点：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。\n\n2.2.2对象\n为了解决上面的问题，对象的写法应运而生，可以把**所有的模块成员****封装在一个对象**中\n\n```\nvar myModule = {\nvar1: 1,\n\nvar2: 2,\n\nfn1: function(){\n\n},\n\nfn2: function(){\n\n}\n}\n```\n\n这样我们在希望调用模块的时候引用对应文件，然后\n\n```\nmyModule.fn2();\n```\n\n这样避免了变量污染，只要**保证模块名唯一**即可，同时同一模块内的成员也有了关系\n\n看似不错的解决方案，但是也有**缺陷**，外部可以随意修改内部成员\n\nmyModel.var1 = 100;\n这样就会产生意外的**安全问题**\n\n2.2.3立即执行函数\n\n可以通过立即执行函数，来达到隐藏细节的目的\n\n```\nvar myModule = (function(){\nvar var1 = 1;\nvar var2 = 2;\n\nfunction fn1(){\n\n}\n\nfunction fn2(){\n\n}\n\nreturn {\nfn1: fn1,\nfn2: fn2\n};\n})();\n```\n\n这样在模块外部无法修改我们没有暴露出来的变量、函数\n\n上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD\n\n3.Javascript的模块规范（CommonJS、AMD、CMD）\n\n_3.1CommonJS_\n\n我们先从CommonJS谈起，因为在网页端没有模块化编程（虽然页面JavaScript逻辑复杂，但也可以工作下去），在**服务器端**却一定要有模块，所以第一个流行的模块化规范由服务器端的JavaScript应用带来，**CommonJS规范**是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。\n\n**（1）定义模块：**\n\n根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性\n\n**（2）模块输出：**\n\n**模块只有一个出口，module.exports对象**，我们需要把模块希望输出的内容放入该对象\n\n**（3）加载模块：**\n\n**加载模块使用require方法**，该方法读取一个文件并执行，返回文件内部的module.exports对象\n\n看个例子\n\n   //模块定义 myModel.js\n\n```\nvar name = 'Byron';\n\nfunction printName(){\nconsole.log(name);\n}\n\nfunction printFullName(firstName){\nconsole.log(firstName + name);\n}\n\nmodule.exports = {\nprintName: printName,\nprintFullName: printFullName\n}\n```\n\n   //加载模块\n\n```\nvar nameModule = require('./myModel.js');\n\nnameModule.printName();\n```\n\n不同的实现对require时的路径有不同要求，一般情况可以省略`js`拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）\n\n  （4）尴尬的浏览器\n\n上面的代码，`require`是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块的接口，但是这在**浏览器端**实现却会遇到很多问题。\n\n  浏览器端，加载JavaScript最佳、最容易的方式是在document中插入`script`标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。\n\n  解决思路之一是，开发一个**服务器端组件**，对模块代码作静态分析，将模块与它的依赖列表**一起返回给**浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。\n\n  另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧。\n\n  3.2AMD\n  AMD即`Asynchromous Module Defination`，中文是异步模块定义的意思，他就是**浏览器端模块化**开发的规范。\n\n   由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上现有RequireJS再有的AMD。\n\n  requireJS主要解决两个问题\n\n  （1）多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器\n\n （2）**js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长**\n\n看一个使用requireJS的例子\n\n// 定义模块 myModule.js\n\n```\ndefine(['dependency'], function(){\nvar name = 'Byron';\nfunction printName(){\nconsole.log(name);\n}\n\nreturn {\nprintName: printName\n};\n});\n```\n\n // 加载模块\n\n```\nrequire(['myModule'], function (my){\n　 my.printName();\n});\n```\n\n3.2.1语法\nrequireJS定义了一个函数 define，它是全局变量，用来定义模块。\n\n（1）**define**，它是全局变量，用来**定义模块**\n\n```\ndefine(id?, dependencies?, factory);\n```\n\n1）id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）\n\n2）dependencies：是一个当前模块依赖的模块名称数组\n\n3）factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值\n\n（2）在页面上使用**require**函数**加载模块**\n\n```\nrequire([dependencies], function(){});\n```\n\nrequire()函数接受两个参数\n\n1）第一个参数是一个数组，表示所依赖的模块\n\n2）第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n\nrequire()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。\n\n3.3CMD\n\nCMD即`Common Module Definition`，通过模块定义。AMD有个RequireJS，CMD有个浏览器实现的SeaJS，SeaJS要解决的问题和RequireJS一样，只不过在**模块定义**方式和**模块加载**（可以说运行、解析）时机上有所不同。\n\n3.3.1语法\n\nSea.js 推崇一个模块一个文件，遵循统一的写法\n\n**（1）define**\n\n```\ndefine(id?, deps?, factory)\n```\n\nCMD推崇\n\n1）一个文件一个模块，所以经常就用文件名作为模块id\n\n2）CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。\n\n（2）factory有三个参数\n\n```\nfunction(require, exports, module)\n```\n\n**1）require**\n\nrequire是factory函数的第一个参数\n\n```\nrequire（id）\n```\n\nrequire是一个方法，接受**模块标识**作为唯一的参数，用来获取其他模块提供的接口\n\n**2）exports**\n\nexports是一个对象，用来向外提供模块的接口\n\n**3）module**\n\nmodule是一个对象，上面存储了与当前模块相关联的属性和方法\n\n看一个使用CMD的例子\n\n// 定义模块  myModule.js\n\n```\ndefine(function(require, exports, module) {\n  var $ = require('jquery.js')\n  $('div').addClass('active');\n});\n```\n\n// 加载模块\n    seajs.use(['myModule.js'], function(my){\n\n```\n});\n```\n\n4.AMD与CMD区别\n\n关于这两个的区别网上可以搜出一堆文章，简单总结一下\n\n最明显的区别就是在模块定义时对**依赖的处理不同**\n\n（1）AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块\n\n（2）CMD推崇就近依赖，只有在用到某个模块的时候再去require\n\n这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法\n\nAMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同\n\n很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是**不准确的**，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略\n\n为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是**依赖模块的执行顺序和书写顺序不一定一致**，**看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行**\n\nCMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，**这样模块的执行顺序和书写顺序是完全一致的**\n\n这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因\n\n> 参考\n> http://www.cnblogs.com/dolphinX/p/4381855.html\n","slug":"前端模块化（一）","published":1,"updated":"2018-08-27T06:15:43.127Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o515000cvds6l0lfav67","content":"<p>综述：<br>    在互联网应用越来越复杂，不可避免的需要工具来管理我们的前端代码。以前是一个巨大的脚本文件，如今希望可以将文件写入不同的文件模块，并且希望代码可以重用，可以简单地引用和添加各种各样的依赖到我们的项目。<br><a id=\"more\"></a><br>1.简述前端为什么需要模块化开发</p>\n<p>  如果按照以往的以页面为单位的开发，会导致很多问题，类似依赖管理、命名冲突等等问题。</p>\n<p><strong>命名冲突是最常见的问题，描述如下</strong>：</p>\n<p>  //在util.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(message)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   //在logger.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(message)&#123;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>   因此如果在页面的script标签同时依赖这两个文件的时候就会产生冲突，导致后面的函数会被覆盖。从而可能产生一些预料之外的结果。</p>\n<p><strong>传统的解决方案是使用命名空间：</strong></p>\n<p>   //在util.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function util.log(message)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   //在logger.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logger.log(message)&#123;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这样带来的显而易见的问题是：<strong>所有的代码会变得冗余并且编写困难</strong></p>\n<p>如果使用模块化编写方案，如使用<strong>CMD（Common Module Definition）</strong>，代码依赖就会变得格外简单。</p>\n<blockquote>\n<p>先简单介绍一下CMD，<strong>一个模块用define关键词来定义</strong>，即define（factory)</p>\n<p>factory可以是一个函数也可以是其他的变量；如果factory是一个函数的话，那它三个参数分别是：require，exports，module即可以用来定义一个模块的内容：</p>\n<p>   define(function(require, exports, module) {  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   // The module code goes here  </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; &#125;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>引用模块用require关键词，接受一个模块名作为参数，返回模块暴漏的API作为返回结果。若不成功则返回null。示例如下：</p>\n</blockquote>\n<p>紧接上面继续：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// util.js </span><br><span class=\"line\">var log = function(message) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = log </span><br><span class=\"line\"></span><br><span class=\"line\">// logger.js </span><br><span class=\"line\">var log = function(message) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">module.exports = log</span><br></pre></td></tr></table></figure>\n<p>   <strong>// app.js using util.js log for logging</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var log =require(&quot;util.js&quot;) </span><br><span class=\"line\"></span><br><span class=\"line\">log(&quot;Hello Module Definition&quot;)</span><br></pre></td></tr></table></figure>\n<p>此时，util.js与logger.js不会相互冲突，它们会被工具包装为CMD下的定义方式。然后通过依赖的方式来解决冲突。</p>\n<p>2.细说前端模块化</p>\n<p> 在Javascript发展初期就是为了实现简单的页面交互逻辑，寥寥数句即可；如今，很多页面的逻辑迁移到客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛的应用，Jquery等前端库层出不穷，前端代码日益膨胀。</p>\n<p> 而<strong>javascript</strong>，<strong>甚至没有类的概念，更不用说模块(module)了</strong>。</p>\n<p> 2.1 模块(Java)</p>\n<p>这里首先借鉴一下其他语言是如何处理大规模程序设计的，在Java中有一个重要的概念——<code>package</code>即：<code>逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，</code>在外面直接使用<code>import</code>对应的package即可，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.uti.ArrayList</span><br></pre></td></tr></table></figure>\n<p> 2.2 模块（Javascript）</p>\n<p> Javascript在设计时定位的原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的Javascript代码，我们称为模块化。</p>\n<p> 有了模块，我们就可以更方便的使用别人的代码。</p>\n<p> 模块开发需要遵循一定的规范，各行其是就都乱套了。规范形成的过程是痛苦的，发展到现在初具规模。</p>\n<p> 2.2.1 函数封装</p>\n<p>JavaScript的<strong>作用域就是基于函数的</strong>，所以把<strong>函数作为模块化</strong>的第一步是很自然的事情，在一个文件里面编写几个相关函数就是<strong>最开始的模块</strong>了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\">statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\">statement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</p>\n<p>2.2.2对象<br>为了解决上面的问题，对象的写法应运而生，可以把<strong>所有的模块成员**</strong>封装在一个对象**中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myModule = &#123;</span><br><span class=\"line\">var1: 1,</span><br><span class=\"line\"></span><br><span class=\"line\">var2: 2,</span><br><span class=\"line\"></span><br><span class=\"line\">fn1: function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">fn2: function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们在希望调用模块的时候引用对应文件，然后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myModule.fn2();</span><br></pre></td></tr></table></figure>\n<p>这样避免了变量污染，只要<strong>保证模块名唯一</strong>即可，同时同一模块内的成员也有了关系</p>\n<p>看似不错的解决方案，但是也有<strong>缺陷</strong>，外部可以随意修改内部成员</p>\n<p>myModel.var1 = 100;<br>这样就会产生意外的<strong>安全问题</strong></p>\n<p>2.2.3立即执行函数</p>\n<p>可以通过立即执行函数，来达到隐藏细节的目的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myModule = (function()&#123;</span><br><span class=\"line\">var var1 = 1;</span><br><span class=\"line\">var var2 = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123;</span><br><span class=\"line\">fn1: fn1,</span><br><span class=\"line\">fn2: fn2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这样在模块外部无法修改我们没有暴露出来的变量、函数</p>\n<p>上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD</p>\n<p>3.Javascript的模块规范（CommonJS、AMD、CMD）</p>\n<p><em>3.1CommonJS</em></p>\n<p>我们先从CommonJS谈起，因为在网页端没有模块化编程（虽然页面JavaScript逻辑复杂，但也可以工作下去），在<strong>服务器端</strong>却一定要有模块，所以第一个流行的模块化规范由服务器端的JavaScript应用带来，<strong>CommonJS规范</strong>是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p>\n<p><strong>（1）定义模块：</strong></p>\n<p>根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性</p>\n<p><strong>（2）模块输出：</strong></p>\n<p><strong>模块只有一个出口，module.exports对象</strong>，我们需要把模块希望输出的内容放入该对象</p>\n<p><strong>（3）加载模块：</strong></p>\n<p><strong>加载模块使用require方法</strong>，该方法读取一个文件并执行，返回文件内部的module.exports对象</p>\n<p>看个例子</p>\n<p>   //模块定义 myModel.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;Byron&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function printName()&#123;</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function printFullName(firstName)&#123;</span><br><span class=\"line\">console.log(firstName + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">printName: printName,</span><br><span class=\"line\">printFullName: printFullName</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   //加载模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nameModule = require(&apos;./myModel.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">nameModule.printName();</span><br></pre></td></tr></table></figure>\n<p>不同的实现对require时的路径有不同要求，一般情况可以省略<code>js</code>拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）</p>\n<p>  （4）尴尬的浏览器</p>\n<p>上面的代码，<code>require</code>是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块的接口，但是这在<strong>浏览器端</strong>实现却会遇到很多问题。</p>\n<p>  浏览器端，加载JavaScript最佳、最容易的方式是在document中插入<code>script</code>标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。</p>\n<p>  解决思路之一是，开发一个<strong>服务器端组件</strong>，对模块代码作静态分析，将模块与它的依赖列表<strong>一起返回给</strong>浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</p>\n<p>  另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧。</p>\n<p>  3.2AMD<br>  AMD即<code>Asynchromous Module Defination</code>，中文是异步模块定义的意思，他就是<strong>浏览器端模块化</strong>开发的规范。</p>\n<p>   由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上现有RequireJS再有的AMD。</p>\n<p>  requireJS主要解决两个问题</p>\n<p>  （1）多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</p>\n<p> （2）<strong>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</strong></p>\n<p>看一个使用requireJS的例子</p>\n<p>// 定义模块 myModule.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&apos;dependency&apos;], function()&#123;</span><br><span class=\"line\">var name = &apos;Byron&apos;;</span><br><span class=\"line\">function printName()&#123;</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123;</span><br><span class=\"line\">printName: printName</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p> // 加载模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require([&apos;myModule&apos;], function (my)&#123;</span><br><span class=\"line\">　 my.printName();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>3.2.1语法<br>requireJS定义了一个函数 define，它是全局变量，用来定义模块。</p>\n<p>（1）<strong>define</strong>，它是全局变量，用来<strong>定义模块</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure>\n<p>1）id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</p>\n<p>2）dependencies：是一个当前模块依赖的模块名称数组</p>\n<p>3）factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</p>\n<p>（2）在页面上使用<strong>require</strong>函数<strong>加载模块</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require([dependencies], function()&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p>require()函数接受两个参数</p>\n<p>1）第一个参数是一个数组，表示所依赖的模块</p>\n<p>2）第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</p>\n<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>\n<p>3.3CMD</p>\n<p>CMD即<code>Common Module Definition</code>，通过模块定义。AMD有个RequireJS，CMD有个浏览器实现的SeaJS，SeaJS要解决的问题和RequireJS一样，只不过在<strong>模块定义</strong>方式和<strong>模块加载</strong>（可以说运行、解析）时机上有所不同。</p>\n<p>3.3.1语法</p>\n<p>Sea.js 推崇一个模块一个文件，遵循统一的写法</p>\n<p><strong>（1）define</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(id?, deps?, factory)</span><br></pre></td></tr></table></figure>\n<p>CMD推崇</p>\n<p>1）一个文件一个模块，所以经常就用文件名作为模块id</p>\n<p>2）CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。</p>\n<p>（2）factory有三个参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(require, exports, module)</span><br></pre></td></tr></table></figure>\n<p><strong>1）require</strong></p>\n<p>require是factory函数的第一个参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require（id）</span><br></pre></td></tr></table></figure>\n<p>require是一个方法，接受<strong>模块标识</strong>作为唯一的参数，用来获取其他模块提供的接口</p>\n<p><strong>2）exports</strong></p>\n<p>exports是一个对象，用来向外提供模块的接口</p>\n<p><strong>3）module</strong></p>\n<p>module是一个对象，上面存储了与当前模块相关联的属性和方法</p>\n<p>看一个使用CMD的例子</p>\n<p>// 定义模块  myModule.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var $ = require(&apos;jquery.js&apos;)</span><br><span class=\"line\">  $(&apos;div&apos;).addClass(&apos;active&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>// 加载模块<br>    seajs.use([‘myModule.js’], function(my){</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4.AMD与CMD区别</p>\n<p>关于这两个的区别网上可以搜出一堆文章，简单总结一下</p>\n<p>最明显的区别就是在模块定义时对<strong>依赖的处理不同</strong></p>\n<p>（1）AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</p>\n<p>（2）CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>\n<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p>\n<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是<strong>不准确的</strong>，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p>\n<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是<strong>依赖模块的执行顺序和书写顺序不一定一致</strong>，<strong>看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</strong></p>\n<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，<strong>这样模块的执行顺序和书写顺序是完全一致的</strong></p>\n<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>\n<blockquote>\n<p>参考<br><a href=\"http://www.cnblogs.com/dolphinX/p/4381855.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/dolphinX/p/4381855.html</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>综述：<br>    在互联网应用越来越复杂，不可避免的需要工具来管理我们的前端代码。以前是一个巨大的脚本文件，如今希望可以将文件写入不同的文件模块，并且希望代码可以重用，可以简单地引用和添加各种各样的依赖到我们的项目。<br>","more":"<br>1.简述前端为什么需要模块化开发</p>\n<p>  如果按照以往的以页面为单位的开发，会导致很多问题，类似依赖管理、命名冲突等等问题。</p>\n<p><strong>命名冲突是最常见的问题，描述如下</strong>：</p>\n<p>  //在util.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(message)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   //在logger.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function log(message)&#123;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>   因此如果在页面的script标签同时依赖这两个文件的时候就会产生冲突，导致后面的函数会被覆盖。从而可能产生一些预料之外的结果。</p>\n<p><strong>传统的解决方案是使用命名空间：</strong></p>\n<p>   //在util.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function util.log(message)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   //在logger.js中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function logger.log(message)&#123;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>这样带来的显而易见的问题是：<strong>所有的代码会变得冗余并且编写困难</strong></p>\n<p>如果使用模块化编写方案，如使用<strong>CMD（Common Module Definition）</strong>，代码依赖就会变得格外简单。</p>\n<blockquote>\n<p>先简单介绍一下CMD，<strong>一个模块用define关键词来定义</strong>，即define（factory)</p>\n<p>factory可以是一个函数也可以是其他的变量；如果factory是一个函数的话，那它三个参数分别是：require，exports，module即可以用来定义一个模块的内容：</p>\n<p>   define(function(require, exports, module) {  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;   // The module code goes here  </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">&gt; &#125;);</span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure>\n</blockquote>\n<blockquote>\n<p>引用模块用require关键词，接受一个模块名作为参数，返回模块暴漏的API作为返回结果。若不成功则返回null。示例如下：</p>\n</blockquote>\n<p>紧接上面继续：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// util.js </span><br><span class=\"line\">var log = function(message) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = log </span><br><span class=\"line\"></span><br><span class=\"line\">// logger.js </span><br><span class=\"line\">var log = function(message) &#123; </span><br><span class=\"line\"></span><br><span class=\"line\">&#125; </span><br><span class=\"line\">module.exports = log</span><br></pre></td></tr></table></figure>\n<p>   <strong>// app.js using util.js log for logging</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var log =require(&quot;util.js&quot;) </span><br><span class=\"line\"></span><br><span class=\"line\">log(&quot;Hello Module Definition&quot;)</span><br></pre></td></tr></table></figure>\n<p>此时，util.js与logger.js不会相互冲突，它们会被工具包装为CMD下的定义方式。然后通过依赖的方式来解决冲突。</p>\n<p>2.细说前端模块化</p>\n<p> 在Javascript发展初期就是为了实现简单的页面交互逻辑，寥寥数句即可；如今，很多页面的逻辑迁移到客户端（表单验证等），随着web2.0时代的到来，Ajax技术得到广泛的应用，Jquery等前端库层出不穷，前端代码日益膨胀。</p>\n<p> 而<strong>javascript</strong>，<strong>甚至没有类的概念，更不用说模块(module)了</strong>。</p>\n<p> 2.1 模块(Java)</p>\n<p>这里首先借鉴一下其他语言是如何处理大规模程序设计的，在Java中有一个重要的概念——<code>package</code>即：<code>逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的，</code>在外面直接使用<code>import</code>对应的package即可，如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.uti.ArrayList</span><br></pre></td></tr></table></figure>\n<p> 2.2 模块（Javascript）</p>\n<p> Javascript在设计时定位的原因，没有提供类似的功能，开发者需要模拟出类似的功能，来隔离、组织复杂的Javascript代码，我们称为模块化。</p>\n<p> 有了模块，我们就可以更方便的使用别人的代码。</p>\n<p> 模块开发需要遵循一定的规范，各行其是就都乱套了。规范形成的过程是痛苦的，发展到现在初具规模。</p>\n<p> 2.2.1 函数封装</p>\n<p>JavaScript的<strong>作用域就是基于函数的</strong>，所以把<strong>函数作为模块化</strong>的第一步是很自然的事情，在一个文件里面编写几个相关函数就是<strong>最开始的模块</strong>了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\">statement</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\">statement</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>缺点：污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。</p>\n<p>2.2.2对象<br>为了解决上面的问题，对象的写法应运而生，可以把<strong>所有的模块成员**</strong>封装在一个对象**中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myModule = &#123;</span><br><span class=\"line\">var1: 1,</span><br><span class=\"line\"></span><br><span class=\"line\">var2: 2,</span><br><span class=\"line\"></span><br><span class=\"line\">fn1: function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">fn2: function()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们在希望调用模块的时候引用对应文件，然后</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myModule.fn2();</span><br></pre></td></tr></table></figure>\n<p>这样避免了变量污染，只要<strong>保证模块名唯一</strong>即可，同时同一模块内的成员也有了关系</p>\n<p>看似不错的解决方案，但是也有<strong>缺陷</strong>，外部可以随意修改内部成员</p>\n<p>myModel.var1 = 100;<br>这样就会产生意外的<strong>安全问题</strong></p>\n<p>2.2.3立即执行函数</p>\n<p>可以通过立即执行函数，来达到隐藏细节的目的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myModule = (function()&#123;</span><br><span class=\"line\">var var1 = 1;</span><br><span class=\"line\">var var2 = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn1()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function fn2()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123;</span><br><span class=\"line\">fn1: fn1,</span><br><span class=\"line\">fn2: fn2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>这样在模块外部无法修改我们没有暴露出来的变量、函数</p>\n<p>上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD</p>\n<p>3.Javascript的模块规范（CommonJS、AMD、CMD）</p>\n<p><em>3.1CommonJS</em></p>\n<p>我们先从CommonJS谈起，因为在网页端没有模块化编程（虽然页面JavaScript逻辑复杂，但也可以工作下去），在<strong>服务器端</strong>却一定要有模块，所以第一个流行的模块化规范由服务器端的JavaScript应用带来，<strong>CommonJS规范</strong>是由NodeJS发扬光大，这标志着JavaScript模块化编程正式登上舞台。</p>\n<p><strong>（1）定义模块：</strong></p>\n<p>根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性</p>\n<p><strong>（2）模块输出：</strong></p>\n<p><strong>模块只有一个出口，module.exports对象</strong>，我们需要把模块希望输出的内容放入该对象</p>\n<p><strong>（3）加载模块：</strong></p>\n<p><strong>加载模块使用require方法</strong>，该方法读取一个文件并执行，返回文件内部的module.exports对象</p>\n<p>看个例子</p>\n<p>   //模块定义 myModel.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &apos;Byron&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">function printName()&#123;</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function printFullName(firstName)&#123;</span><br><span class=\"line\">console.log(firstName + name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">printName: printName,</span><br><span class=\"line\">printFullName: printFullName</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>   //加载模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var nameModule = require(&apos;./myModel.js&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">nameModule.printName();</span><br></pre></td></tr></table></figure>\n<p>不同的实现对require时的路径有不同要求，一般情况可以省略<code>js</code>拓展名，可以使用相对路径，也可以使用绝对路径，甚至可以省略路径直接使用模块名（前提是该模块是系统内置模块）</p>\n<p>  （4）尴尬的浏览器</p>\n<p>上面的代码，<code>require</code>是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块的接口，但是这在<strong>浏览器端</strong>实现却会遇到很多问题。</p>\n<p>  浏览器端，加载JavaScript最佳、最容易的方式是在document中插入<code>script</code>标签。但脚本标签天生异步，传统CommonJS模块在浏览器环境中无法正常加载。</p>\n<p>  解决思路之一是，开发一个<strong>服务器端组件</strong>，对模块代码作静态分析，将模块与它的依赖列表<strong>一起返回给</strong>浏览器端。 这很好使，但需要服务器安装额外的组件，并因此要调整一系列底层架构。</p>\n<p>  另一种解决思路是，用一套标准模板来封装模块定义，但是对于模块应该怎么定义和怎么加载，又产生的分歧。</p>\n<p>  3.2AMD<br>  AMD即<code>Asynchromous Module Defination</code>，中文是异步模块定义的意思，他就是<strong>浏览器端模块化</strong>开发的规范。</p>\n<p>   由于不是JavaScript原生支持，使用AMD规范进行页面开发需要用到对应的库函数，也就是大名鼎鼎RequireJS，实际上现有RequireJS再有的AMD。</p>\n<p>  requireJS主要解决两个问题</p>\n<p>  （1）多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</p>\n<p> （2）<strong>js加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</strong></p>\n<p>看一个使用requireJS的例子</p>\n<p>// 定义模块 myModule.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&apos;dependency&apos;], function()&#123;</span><br><span class=\"line\">var name = &apos;Byron&apos;;</span><br><span class=\"line\">function printName()&#123;</span><br><span class=\"line\">console.log(name);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">return &#123;</span><br><span class=\"line\">printName: printName</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p> // 加载模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require([&apos;myModule&apos;], function (my)&#123;</span><br><span class=\"line\">　 my.printName();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>3.2.1语法<br>requireJS定义了一个函数 define，它是全局变量，用来定义模块。</p>\n<p>（1）<strong>define</strong>，它是全局变量，用来<strong>定义模块</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure>\n<p>1）id：可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名）</p>\n<p>2）dependencies：是一个当前模块依赖的模块名称数组</p>\n<p>3）factory：工厂方法，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值</p>\n<p>（2）在页面上使用<strong>require</strong>函数<strong>加载模块</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require([dependencies], function()&#123;&#125;);</span><br></pre></td></tr></table></figure>\n<p>require()函数接受两个参数</p>\n<p>1）第一个参数是一个数组，表示所依赖的模块</p>\n<p>2）第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</p>\n<p>require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>\n<p>3.3CMD</p>\n<p>CMD即<code>Common Module Definition</code>，通过模块定义。AMD有个RequireJS，CMD有个浏览器实现的SeaJS，SeaJS要解决的问题和RequireJS一样，只不过在<strong>模块定义</strong>方式和<strong>模块加载</strong>（可以说运行、解析）时机上有所不同。</p>\n<p>3.3.1语法</p>\n<p>Sea.js 推崇一个模块一个文件，遵循统一的写法</p>\n<p><strong>（1）define</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(id?, deps?, factory)</span><br></pre></td></tr></table></figure>\n<p>CMD推崇</p>\n<p>1）一个文件一个模块，所以经常就用文件名作为模块id</p>\n<p>2）CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写。</p>\n<p>（2）factory有三个参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(require, exports, module)</span><br></pre></td></tr></table></figure>\n<p><strong>1）require</strong></p>\n<p>require是factory函数的第一个参数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require（id）</span><br></pre></td></tr></table></figure>\n<p>require是一个方法，接受<strong>模块标识</strong>作为唯一的参数，用来获取其他模块提供的接口</p>\n<p><strong>2）exports</strong></p>\n<p>exports是一个对象，用来向外提供模块的接口</p>\n<p><strong>3）module</strong></p>\n<p>module是一个对象，上面存储了与当前模块相关联的属性和方法</p>\n<p>看一个使用CMD的例子</p>\n<p>// 定义模块  myModule.js</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function(require, exports, module) &#123;</span><br><span class=\"line\">  var $ = require(&apos;jquery.js&apos;)</span><br><span class=\"line\">  $(&apos;div&apos;).addClass(&apos;active&apos;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>// 加载模块<br>    seajs.use([‘myModule.js’], function(my){</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4.AMD与CMD区别</p>\n<p>关于这两个的区别网上可以搜出一堆文章，简单总结一下</p>\n<p>最明显的区别就是在模块定义时对<strong>依赖的处理不同</strong></p>\n<p>（1）AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</p>\n<p>（2）CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>\n<p>AMD和CMD最大的区别是对依赖模块的执行时机处理不同，注意不是加载的时机或者方式不同</p>\n<p>很多人说requireJS是异步加载模块，SeaJS是同步加载模块，这么理解实际上是<strong>不准确的</strong>，其实加载模块都是异步的，只不过AMD依赖前置，js可以方便知道依赖模块是谁，立即加载，而CMD就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块，这也是很多人诟病CMD的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略</p>\n<p>为什么我们说两个的区别是依赖模块执行时机不同，为什么很多人认为ADM是异步的，CMD是同步的（除了名字的原因。。。）</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入require的回调函数，执行主逻辑，这样的效果就是<strong>依赖模块的执行顺序和书写顺序不一定一致</strong>，<strong>看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行</strong></p>\n<p>CMD加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，<strong>这样模块的执行顺序和书写顺序是完全一致的</strong></p>\n<p>这也是很多人说AMD用户体验好，因为没有延迟，依赖模块提前执行了，CMD性能好，因为只有用户需要的时候才执行的原因</p>\n<blockquote>\n<p>参考<br><a href=\"http://www.cnblogs.com/dolphinX/p/4381855.html\" target=\"_blank\" rel=\"noopener\">http://www.cnblogs.com/dolphinX/p/4381855.html</a></p>\n</blockquote>"},{"title":"前端模块化（二）","date":"2018-08-27T06:11:00.000Z","_content":"综述：\n    Commonjs,AMD,CMD,ES6的模块化总结\n<!-- more -->\n\n## 前端的四种模块化方案(webpack/require.js/seajs/browserify）\n\nJS不具备原生的模块化技能，因此需要采用第三方开发的模块依赖处理库来实现模块化：CommonJS、AMD、CMD、ES6\n\n这四种方案的实现对比：\n\n> CommonJS:  exports + require \n\n> AMD: define + require \n\n> CMD：define+require+exports/exports \n\nPs. CommonJS 和AMD上下的require也不是一样的,cmd与amd的文字一样内容差了好多参数） \n\n> ES6: export + import\n\n由于ES6本身是原生语言支持实现的模块化，但是现代浏览器大多都还未支持，因此必须使用相应的transpiler工具转换成ES5的AMD,CMD模块，再借助于systemjs/requirejs等模块加载工具才能使用。其中ES6的transpiler（代码转换器）一般是用babel，他的作用是将ES6\n\n\n### 1.CommonJS\n适合服务器端\n\ncommonJS由nodeJS发扬光大，这标志着js模块化正式登场。\n\n1.1定义模块\n根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。\n \n2.2 模块输出 \n模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。** 或者是exports，这些全都是因为commonjs规范一和规范二 **\n\n2.3加载模块\n加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象或者是exports。\n\n> 注意  \n> (1). exports 与module.exports 的区别：exports 是对 module.exports 的引用，不能直接给exports 赋值，直接赋值无效，结果是一个空对象,module.exports 可以直接赋值：如示例\n\n\n     module.exports = 123; //123\n    \n     module.exports = function () { //[Function]\n         console.log(123)\n     }\n    \n      exports = 123; //{}\n      exports = function(){ //{}\n         console.log(123)\n     }\n\n\n> （2)一个文件不能写多个module.exports如果写多个，对外暴露的接口是最后一个module.exports \n>（3）模块如果没有指定使用module.exports 或者exports 对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象{}\n\n仔细看上面的代码，您会注意到 require 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。\n然而， 这在浏览器端问题多多。\n浏览器端，加载 JavaScript 最佳、最容易的方式是在 document中插入``<script>``标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载。\n\n解决思路是，用一套标准模板来封装模块定义：\n\n### 2.AMD\n\nAsynchronous Module Definition，称为异步模块。\n由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。\nrequireJS主要解决两个问题：\n1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。\n2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。\n\n> 语法： requireJS定义了一个函数define，它是全局变量，用来定义模块。\n\n> define(id,dependencies,factory) \n\n> id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） \n\n> 依赖dependencies是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。有默认值，长度是三个 \n\n>factory工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。\n\n \n在页面上使用require函数加载模块；\n\nrequire([dependencies], function(){}); 与上面的commonjs的require差别很大，上面是找文件这里的呢，是id+回调\n\nrequire()函数接受两个参数：\n\n——第一个参数是一个数组，表示所依赖的模块；\n\n——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n \n\nAMD推崇的是依赖前置，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块\n\n### 3.CMD\n即common module definition，就像AMD有个requireJS,CMD有个浏览器实现的sea.js，sj要解决的问题和rj一样，只不过在模块定义方式和模块加载时机上有所不同。\n\n\n> 1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 \n> \n> 2、CMD推崇就近依赖，只有在用到某个模块的时候再去require\n\n这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法\n\nAMD和CMD最大的区别：依赖模块执行时机不同\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行该模块**（这里执行的被加载的模块而不是用户写的主逻辑模块），所有模块都加载执行完后会进入require的回调函数**，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行\n上面加载的模块需要：加载+执行\n下面加载的模块：加载\nCMD加载完某个依赖模块后并不执行**，只是下载而已**，在所有依赖模块加载完成后进入主逻辑，**遇到require语句的时候才执行对应的模块**，这样模块的执行顺序和书写顺序是完全一致的\n\n\n\n\n## 一.模块化\n\n\n模块化开发，一个实现特定功能的文件就是一个模块，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。\n模块化开发的4点好处：\n　　\n\n - 1 避免变量污染，命名冲突 　　\n - 2  提高代码复用率 　　\n - 3 提高维护性 　　\n - 4 依赖关系的管理\n\n前端模块化规范从原始野蛮阶段现在慢慢进入“文艺复兴”时代，实现的过程如下：\n### 1. 函数封装\n我们在讲到函数逻辑的时候提到过，函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了\n\n>  详情见模块化（一）\n\n缺点：污染了全局变量，并且不能保证和其他模块起冲突，模块成员看起来似乎没啥关系\n\n### 2. 对象\n为了解决这个问题，有了新方法，将所有模块成员封装在一个对象中\n\n>  详情见模块化（一）\n\n这样 两个函数就被包在这个对象中， 嘿嘿 看起来没毛病是吗 继续往下：\n当我们要使用的时候，就是调用这个对象的属性\nmodule.m1()\n诶嘿 那么问题来了 这样写法会暴露全部的成员，内部状态可以被外部改变，比如外部代码可直接改变计数器的值\n\n    //坏人的操作\n    \n    module._count = 10;\n\n \n### 3. 立即执行函数\n\n这样就可以达到不暴露私有成员的目的\n外部无法访问内部私有变量\n>  详情见模块化（一）\n\n\n","source":"_posts/前端模块化（二）.md","raw":"---\ntitle: 前端模块化（二）\ndate: 2018-08-27 14:11:00\ntags: 模块化\n---\n综述：\n    Commonjs,AMD,CMD,ES6的模块化总结\n<!-- more -->\n\n## 前端的四种模块化方案(webpack/require.js/seajs/browserify）\n\nJS不具备原生的模块化技能，因此需要采用第三方开发的模块依赖处理库来实现模块化：CommonJS、AMD、CMD、ES6\n\n这四种方案的实现对比：\n\n> CommonJS:  exports + require \n\n> AMD: define + require \n\n> CMD：define+require+exports/exports \n\nPs. CommonJS 和AMD上下的require也不是一样的,cmd与amd的文字一样内容差了好多参数） \n\n> ES6: export + import\n\n由于ES6本身是原生语言支持实现的模块化，但是现代浏览器大多都还未支持，因此必须使用相应的transpiler工具转换成ES5的AMD,CMD模块，再借助于systemjs/requirejs等模块加载工具才能使用。其中ES6的transpiler（代码转换器）一般是用babel，他的作用是将ES6\n\n\n### 1.CommonJS\n适合服务器端\n\ncommonJS由nodeJS发扬光大，这标志着js模块化正式登场。\n\n1.1定义模块\n根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。\n \n2.2 模块输出 \n模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。** 或者是exports，这些全都是因为commonjs规范一和规范二 **\n\n2.3加载模块\n加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象或者是exports。\n\n> 注意  \n> (1). exports 与module.exports 的区别：exports 是对 module.exports 的引用，不能直接给exports 赋值，直接赋值无效，结果是一个空对象,module.exports 可以直接赋值：如示例\n\n\n     module.exports = 123; //123\n    \n     module.exports = function () { //[Function]\n         console.log(123)\n     }\n    \n      exports = 123; //{}\n      exports = function(){ //{}\n         console.log(123)\n     }\n\n\n> （2)一个文件不能写多个module.exports如果写多个，对外暴露的接口是最后一个module.exports \n>（3）模块如果没有指定使用module.exports 或者exports 对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象{}\n\n仔细看上面的代码，您会注意到 require 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。\n然而， 这在浏览器端问题多多。\n浏览器端，加载 JavaScript 最佳、最容易的方式是在 document中插入``<script>``标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载。\n\n解决思路是，用一套标准模板来封装模块定义：\n\n### 2.AMD\n\nAsynchronous Module Definition，称为异步模块。\n由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。\nrequireJS主要解决两个问题：\n1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。\n2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。\n\n> 语法： requireJS定义了一个函数define，它是全局变量，用来定义模块。\n\n> define(id,dependencies,factory) \n\n> id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） \n\n> 依赖dependencies是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。有默认值，长度是三个 \n\n>factory工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。\n\n \n在页面上使用require函数加载模块；\n\nrequire([dependencies], function(){}); 与上面的commonjs的require差别很大，上面是找文件这里的呢，是id+回调\n\nrequire()函数接受两个参数：\n\n——第一个参数是一个数组，表示所依赖的模块；\n\n——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块\n \n\nAMD推崇的是依赖前置，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块\n\n### 3.CMD\n即common module definition，就像AMD有个requireJS,CMD有个浏览器实现的sea.js，sj要解决的问题和rj一样，只不过在模块定义方式和模块加载时机上有所不同。\n\n\n> 1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 \n> \n> 2、CMD推崇就近依赖，只有在用到某个模块的时候再去require\n\n这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法\n\nAMD和CMD最大的区别：依赖模块执行时机不同\n\n同样都是异步加载模块，AMD在加载模块完成后就会执行该模块**（这里执行的被加载的模块而不是用户写的主逻辑模块），所有模块都加载执行完后会进入require的回调函数**，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行\n上面加载的模块需要：加载+执行\n下面加载的模块：加载\nCMD加载完某个依赖模块后并不执行**，只是下载而已**，在所有依赖模块加载完成后进入主逻辑，**遇到require语句的时候才执行对应的模块**，这样模块的执行顺序和书写顺序是完全一致的\n\n\n\n\n## 一.模块化\n\n\n模块化开发，一个实现特定功能的文件就是一个模块，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。\n模块化开发的4点好处：\n　　\n\n - 1 避免变量污染，命名冲突 　　\n - 2  提高代码复用率 　　\n - 3 提高维护性 　　\n - 4 依赖关系的管理\n\n前端模块化规范从原始野蛮阶段现在慢慢进入“文艺复兴”时代，实现的过程如下：\n### 1. 函数封装\n我们在讲到函数逻辑的时候提到过，函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了\n\n>  详情见模块化（一）\n\n缺点：污染了全局变量，并且不能保证和其他模块起冲突，模块成员看起来似乎没啥关系\n\n### 2. 对象\n为了解决这个问题，有了新方法，将所有模块成员封装在一个对象中\n\n>  详情见模块化（一）\n\n这样 两个函数就被包在这个对象中， 嘿嘿 看起来没毛病是吗 继续往下：\n当我们要使用的时候，就是调用这个对象的属性\nmodule.m1()\n诶嘿 那么问题来了 这样写法会暴露全部的成员，内部状态可以被外部改变，比如外部代码可直接改变计数器的值\n\n    //坏人的操作\n    \n    module._count = 10;\n\n \n### 3. 立即执行函数\n\n这样就可以达到不暴露私有成员的目的\n外部无法访问内部私有变量\n>  详情见模块化（一）\n\n\n","slug":"前端模块化（二）","published":1,"updated":"2018-08-27T07:04:37.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjlc3o517000dvds6x8qi2ypa","content":"<p>综述：<br>    Commonjs,AMD,CMD,ES6的模块化总结<br><a id=\"more\"></a></p>\n<h2 id=\"前端的四种模块化方案-webpack-require-js-seajs-browserify）\"><a href=\"#前端的四种模块化方案-webpack-require-js-seajs-browserify）\" class=\"headerlink\" title=\"前端的四种模块化方案(webpack/require.js/seajs/browserify）\"></a>前端的四种模块化方案(webpack/require.js/seajs/browserify）</h2><p>JS不具备原生的模块化技能，因此需要采用第三方开发的模块依赖处理库来实现模块化：CommonJS、AMD、CMD、ES6</p>\n<p>这四种方案的实现对比：</p>\n<blockquote>\n<p>CommonJS:  exports + require </p>\n</blockquote>\n<blockquote>\n<p>AMD: define + require </p>\n</blockquote>\n<blockquote>\n<p>CMD：define+require+exports/exports </p>\n</blockquote>\n<p>Ps. CommonJS 和AMD上下的require也不是一样的,cmd与amd的文字一样内容差了好多参数） </p>\n<blockquote>\n<p>ES6: export + import</p>\n</blockquote>\n<p>由于ES6本身是原生语言支持实现的模块化，但是现代浏览器大多都还未支持，因此必须使用相应的transpiler工具转换成ES5的AMD,CMD模块，再借助于systemjs/requirejs等模块加载工具才能使用。其中ES6的transpiler（代码转换器）一般是用babel，他的作用是将ES6</p>\n<h3 id=\"1-CommonJS\"><a href=\"#1-CommonJS\" class=\"headerlink\" title=\"1.CommonJS\"></a>1.CommonJS</h3><p>适合服务器端</p>\n<p>commonJS由nodeJS发扬光大，这标志着js模块化正式登场。</p>\n<p>1.1定义模块<br>根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。</p>\n<p>2.2 模块输出<br>模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。<strong> 或者是exports，这些全都是因为commonjs规范一和规范二 </strong></p>\n<p>2.3加载模块<br>加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象或者是exports。</p>\n<blockquote>\n<p>注意<br>(1). exports 与module.exports 的区别：exports 是对 module.exports 的引用，不能直接给exports 赋值，直接赋值无效，结果是一个空对象,module.exports 可以直接赋值：如示例</p>\n</blockquote>\n<pre><code>module.exports = 123; //123\n\nmodule.exports = function () { //[Function]\n    console.log(123)\n}\n\n exports = 123; //{}\n exports = function(){ //{}\n    console.log(123)\n}\n</code></pre><blockquote>\n<p>（2)一个文件不能写多个module.exports如果写多个，对外暴露的接口是最后一个module.exports<br>（3）模块如果没有指定使用module.exports 或者exports 对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象{}</p>\n</blockquote>\n<p>仔细看上面的代码，您会注意到 require 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。<br>然而， 这在浏览器端问题多多。<br>浏览器端，加载 JavaScript 最佳、最容易的方式是在 document中插入<code>&lt;script&gt;</code>标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载。</p>\n<p>解决思路是，用一套标准模板来封装模块定义：</p>\n<h3 id=\"2-AMD\"><a href=\"#2-AMD\" class=\"headerlink\" title=\"2.AMD\"></a>2.AMD</h3><p>Asynchronous Module Definition，称为异步模块。<br>由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。<br>requireJS主要解决两个问题：<br>1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。<br>2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。</p>\n<blockquote>\n<p>语法： requireJS定义了一个函数define，它是全局变量，用来定义模块。</p>\n</blockquote>\n<blockquote>\n<p>define(id,dependencies,factory) </p>\n</blockquote>\n<blockquote>\n<p>id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） </p>\n</blockquote>\n<blockquote>\n<p>依赖dependencies是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。有默认值，长度是三个 </p>\n</blockquote>\n<blockquote>\n<p>factory工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。</p>\n</blockquote>\n<p>在页面上使用require函数加载模块；</p>\n<p>require([dependencies], function(){}); 与上面的commonjs的require差别很大，上面是找文件这里的呢，是id+回调</p>\n<p>require()函数接受两个参数：</p>\n<p>——第一个参数是一个数组，表示所依赖的模块；</p>\n<p>——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</p>\n<p>AMD推崇的是依赖前置，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块</p>\n<h3 id=\"3-CMD\"><a href=\"#3-CMD\" class=\"headerlink\" title=\"3.CMD\"></a>3.CMD</h3><p>即common module definition，就像AMD有个requireJS,CMD有个浏览器实现的sea.js，sj要解决的问题和rj一样，只不过在模块定义方式和模块加载时机上有所不同。</p>\n<blockquote>\n<p>1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 </p>\n<p>2、CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>\n<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>\n<p>AMD和CMD最大的区别：依赖模块执行时机不同</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行该模块<strong>（这里执行的被加载的模块而不是用户写的主逻辑模块），所有模块都加载执行完后会进入require的回调函数</strong>，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行<br>上面加载的模块需要：加载+执行<br>下面加载的模块：加载<br>CMD加载完某个依赖模块后并不执行<strong>，只是下载而已</strong>，在所有依赖模块加载完成后进入主逻辑，<strong>遇到require语句的时候才执行对应的模块</strong>，这样模块的执行顺序和书写顺序是完全一致的</p>\n<h2 id=\"一-模块化\"><a href=\"#一-模块化\" class=\"headerlink\" title=\"一.模块化\"></a>一.模块化</h2><p>模块化开发，一个实现特定功能的文件就是一个模块，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。<br>模块化开发的4点好处：\n　　</p>\n<ul>\n<li>1 避免变量污染，命名冲突 　　</li>\n<li>2  提高代码复用率 　　</li>\n<li>3 提高维护性 　　</li>\n<li>4 依赖关系的管理</li>\n</ul>\n<p>前端模块化规范从原始野蛮阶段现在慢慢进入“文艺复兴”时代，实现的过程如下：</p>\n<h3 id=\"1-函数封装\"><a href=\"#1-函数封装\" class=\"headerlink\" title=\"1. 函数封装\"></a>1. 函数封装</h3><p>我们在讲到函数逻辑的时候提到过，函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了</p>\n<blockquote>\n<p> 详情见模块化（一）</p>\n</blockquote>\n<p>缺点：污染了全局变量，并且不能保证和其他模块起冲突，模块成员看起来似乎没啥关系</p>\n<h3 id=\"2-对象\"><a href=\"#2-对象\" class=\"headerlink\" title=\"2. 对象\"></a>2. 对象</h3><p>为了解决这个问题，有了新方法，将所有模块成员封装在一个对象中</p>\n<blockquote>\n<p> 详情见模块化（一）</p>\n</blockquote>\n<p>这样 两个函数就被包在这个对象中， 嘿嘿 看起来没毛病是吗 继续往下：<br>当我们要使用的时候，就是调用这个对象的属性<br>module.m1()<br>诶嘿 那么问题来了 这样写法会暴露全部的成员，内部状态可以被外部改变，比如外部代码可直接改变计数器的值</p>\n<pre><code>//坏人的操作\n\nmodule._count = 10;\n</code></pre><h3 id=\"3-立即执行函数\"><a href=\"#3-立即执行函数\" class=\"headerlink\" title=\"3. 立即执行函数\"></a>3. 立即执行函数</h3><p>这样就可以达到不暴露私有成员的目的<br>外部无法访问内部私有变量</p>\n<blockquote>\n<p> 详情见模块化（一）</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>综述：<br>    Commonjs,AMD,CMD,ES6的模块化总结<br>","more":"</p>\n<h2 id=\"前端的四种模块化方案-webpack-require-js-seajs-browserify）\"><a href=\"#前端的四种模块化方案-webpack-require-js-seajs-browserify）\" class=\"headerlink\" title=\"前端的四种模块化方案(webpack/require.js/seajs/browserify）\"></a>前端的四种模块化方案(webpack/require.js/seajs/browserify）</h2><p>JS不具备原生的模块化技能，因此需要采用第三方开发的模块依赖处理库来实现模块化：CommonJS、AMD、CMD、ES6</p>\n<p>这四种方案的实现对比：</p>\n<blockquote>\n<p>CommonJS:  exports + require </p>\n</blockquote>\n<blockquote>\n<p>AMD: define + require </p>\n</blockquote>\n<blockquote>\n<p>CMD：define+require+exports/exports </p>\n</blockquote>\n<p>Ps. CommonJS 和AMD上下的require也不是一样的,cmd与amd的文字一样内容差了好多参数） </p>\n<blockquote>\n<p>ES6: export + import</p>\n</blockquote>\n<p>由于ES6本身是原生语言支持实现的模块化，但是现代浏览器大多都还未支持，因此必须使用相应的transpiler工具转换成ES5的AMD,CMD模块，再借助于systemjs/requirejs等模块加载工具才能使用。其中ES6的transpiler（代码转换器）一般是用babel，他的作用是将ES6</p>\n<h3 id=\"1-CommonJS\"><a href=\"#1-CommonJS\" class=\"headerlink\" title=\"1.CommonJS\"></a>1.CommonJS</h3><p>适合服务器端</p>\n<p>commonJS由nodeJS发扬光大，这标志着js模块化正式登场。</p>\n<p>1.1定义模块<br>根据commonJS规范，一个单独的文件是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非为global对象的属性。</p>\n<p>2.2 模块输出<br>模块只有一个出口，module.exports对象，我们需要把模块希望输出的内容放入该对象。<strong> 或者是exports，这些全都是因为commonjs规范一和规范二 </strong></p>\n<p>2.3加载模块<br>加载模块用require方法，该方法读取一个文件并且执行，返回文件内部的module.exports对象或者是exports。</p>\n<blockquote>\n<p>注意<br>(1). exports 与module.exports 的区别：exports 是对 module.exports 的引用，不能直接给exports 赋值，直接赋值无效，结果是一个空对象,module.exports 可以直接赋值：如示例</p>\n</blockquote>\n<pre><code>module.exports = 123; //123\n\nmodule.exports = function () { //[Function]\n    console.log(123)\n}\n\n exports = 123; //{}\n exports = function(){ //{}\n    console.log(123)\n}\n</code></pre><blockquote>\n<p>（2)一个文件不能写多个module.exports如果写多个，对外暴露的接口是最后一个module.exports<br>（3）模块如果没有指定使用module.exports 或者exports 对外暴露接口时，在其他文件就引用该模块，得到的是一个空对象{}</p>\n</blockquote>\n<p>仔细看上面的代码，您会注意到 require 是同步的。模块系统需要同步读取模块文件内容，并编译执行以得到模块接口。<br>然而， 这在浏览器端问题多多。<br>浏览器端，加载 JavaScript 最佳、最容易的方式是在 document中插入<code>&lt;script&gt;</code>标签。但脚本标签天生异步，传统 CommonJS 模块在浏览器环境中无法正常加载。</p>\n<p>解决思路是，用一套标准模板来封装模块定义：</p>\n<h3 id=\"2-AMD\"><a href=\"#2-AMD\" class=\"headerlink\" title=\"2.AMD\"></a>2.AMD</h3><p>Asynchronous Module Definition，称为异步模块。<br>由于不是js原生支持，使用AMD规范进行页面开发需要用到对应的函数库，也就是大名鼎鼎的RequireJS，实际上AMD是RequireJS在推广过程中对模块定义的规范化的产出。<br>requireJS主要解决两个问题：<br>1 多个js文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。<br>2 js加载的时候浏览器会停止页面渲染，加载文件愈多，页面失去响应的时间愈长。</p>\n<blockquote>\n<p>语法： requireJS定义了一个函数define，它是全局变量，用来定义模块。</p>\n</blockquote>\n<blockquote>\n<p>define(id,dependencies,factory) </p>\n</blockquote>\n<blockquote>\n<p>id 可选参数，用来定义模块的标识，如果没有提供该参数，脚本文件名（去掉拓展名） </p>\n</blockquote>\n<blockquote>\n<p>依赖dependencies是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。有默认值，长度是三个 </p>\n</blockquote>\n<blockquote>\n<p>factory工厂方法，模块初始化要执行的函数或对象，如果为函数，它应该只被执行一次，如果是对象，此对象应该为模块的输出值。</p>\n</blockquote>\n<p>在页面上使用require函数加载模块；</p>\n<p>require([dependencies], function(){}); 与上面的commonjs的require差别很大，上面是找文件这里的呢，是id+回调</p>\n<p>require()函数接受两个参数：</p>\n<p>——第一个参数是一个数组，表示所依赖的模块；</p>\n<p>——第二个参数是一个回调函数，当前面指定的模块都加载成功后，它将被调用。加载的模块会以参数形式传入该函数，从而在回调函数内部就可以使用这些模块</p>\n<p>AMD推崇的是依赖前置，被提前罗列出来并会背提前下载并执行，后来做了改进，可以不用罗列依赖模块，允许在回调函数中就近使用require引入并下载执行模块</p>\n<h3 id=\"3-CMD\"><a href=\"#3-CMD\" class=\"headerlink\" title=\"3.CMD\"></a>3.CMD</h3><p>即common module definition，就像AMD有个requireJS,CMD有个浏览器实现的sea.js，sj要解决的问题和rj一样，只不过在模块定义方式和模块加载时机上有所不同。</p>\n<blockquote>\n<p>1、AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 </p>\n<p>2、CMD推崇就近依赖，只有在用到某个模块的时候再去require</p>\n</blockquote>\n<p>这种区别各有优劣，只是语法上的差距，而且requireJS和SeaJS都支持对方的写法</p>\n<p>AMD和CMD最大的区别：依赖模块执行时机不同</p>\n<p>同样都是异步加载模块，AMD在加载模块完成后就会执行该模块<strong>（这里执行的被加载的模块而不是用户写的主逻辑模块），所有模块都加载执行完后会进入require的回调函数</strong>，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行<br>上面加载的模块需要：加载+执行<br>下面加载的模块：加载<br>CMD加载完某个依赖模块后并不执行<strong>，只是下载而已</strong>，在所有依赖模块加载完成后进入主逻辑，<strong>遇到require语句的时候才执行对应的模块</strong>，这样模块的执行顺序和书写顺序是完全一致的</p>\n<h2 id=\"一-模块化\"><a href=\"#一-模块化\" class=\"headerlink\" title=\"一.模块化\"></a>一.模块化</h2><p>模块化开发，一个实现特定功能的文件就是一个模块，有了模块我们就可以更方便的使用别人的代码，要用什么功能就加载什么模块。<br>模块化开发的4点好处：\n　　</p>\n<ul>\n<li>1 避免变量污染，命名冲突 　　</li>\n<li>2  提高代码复用率 　　</li>\n<li>3 提高维护性 　　</li>\n<li>4 依赖关系的管理</li>\n</ul>\n<p>前端模块化规范从原始野蛮阶段现在慢慢进入“文艺复兴”时代，实现的过程如下：</p>\n<h3 id=\"1-函数封装\"><a href=\"#1-函数封装\" class=\"headerlink\" title=\"1. 函数封装\"></a>1. 函数封装</h3><p>我们在讲到函数逻辑的时候提到过，函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了</p>\n<blockquote>\n<p> 详情见模块化（一）</p>\n</blockquote>\n<p>缺点：污染了全局变量，并且不能保证和其他模块起冲突，模块成员看起来似乎没啥关系</p>\n<h3 id=\"2-对象\"><a href=\"#2-对象\" class=\"headerlink\" title=\"2. 对象\"></a>2. 对象</h3><p>为了解决这个问题，有了新方法，将所有模块成员封装在一个对象中</p>\n<blockquote>\n<p> 详情见模块化（一）</p>\n</blockquote>\n<p>这样 两个函数就被包在这个对象中， 嘿嘿 看起来没毛病是吗 继续往下：<br>当我们要使用的时候，就是调用这个对象的属性<br>module.m1()<br>诶嘿 那么问题来了 这样写法会暴露全部的成员，内部状态可以被外部改变，比如外部代码可直接改变计数器的值</p>\n<pre><code>//坏人的操作\n\nmodule._count = 10;\n</code></pre><h3 id=\"3-立即执行函数\"><a href=\"#3-立即执行函数\" class=\"headerlink\" title=\"3. 立即执行函数\"></a>3. 立即执行函数</h3><p>这样就可以达到不暴露私有成员的目的<br>外部无法访问内部私有变量</p>\n<blockquote>\n<p> 详情见模块化（一）</p>\n</blockquote>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjlc3o50j0000vds630pt4y7a","tag_id":"cjlc3o50t0004vds61sj7w3jg","_id":"cjlc3o514000bvds6j6slij5q"},{"post_id":"cjlc3o50v0005vds6z8zny9u5","tag_id":"cjlc3o511000avds68dc9ckjh","_id":"cjlc3o51a000gvds6rwciv4c2"},{"post_id":"cjlc3o50v0005vds6z8zny9u5","tag_id":"cjlc3o518000evds66xexdopy","_id":"cjlc3o51b000hvds6pyhbq1af"},{"post_id":"cjlc3o50x0007vds6ekwdzxj9","tag_id":"cjlc3o511000avds68dc9ckjh","_id":"cjlc3o51c000kvds6tz4jd9yg"},{"post_id":"cjlc3o50x0007vds6ekwdzxj9","tag_id":"cjlc3o518000evds66xexdopy","_id":"cjlc3o51d000lvds6dseng3jw"},{"post_id":"cjlc3o515000cvds6l0lfav67","tag_id":"cjlc3o51c000jvds6evecy3ex","_id":"cjlc3o51d000nvds6hof0asct"},{"post_id":"cjlc3o517000dvds6x8qi2ypa","tag_id":"cjlc3o51c000jvds6evecy3ex","_id":"cjlc3o51e000ovds6ljodlp4v"}],"Tag":[{"name":"git","_id":"cjlc3o50t0004vds61sj7w3jg"},{"name":"react","_id":"cjlc3o511000avds68dc9ckjh"},{"name":"hoc-react","_id":"cjlc3o518000evds66xexdopy"},{"name":"模块化","_id":"cjlc3o51c000jvds6evecy3ex"}]}}