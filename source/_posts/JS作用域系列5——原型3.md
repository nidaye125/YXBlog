---
title: JS作用域系列5——原型2
date: 2018-09-28 15:55:59
tags: JS
categories: 总结
---

前两篇的总结

<!--more-->

## 1 函数对象
理解：本文的构造器指的是函数对象
### 1.1内置的函数对象
所有**函数对象**的_proto_都指向Function.prototype，它是一个空函数（Empty function）

这句话有条件限制，先去找构造函数的原型对象
```
Number.__proto__ === Function.prototype  // true
Number.constructor == Function //true

Boolean.__proto__ === Function.prototype // true
Boolean.constructor == Function //true

String.__proto__ === Function.prototype  // true
String.constructor == Function //true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Object.__proto__ === Function.prototype  // true
Object.constructor == Function // true

// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身
Function.__proto__ === Function.prototype // true
Function.constructor == Function //true

Array.__proto__ === Function.prototype   // true
Array.constructor == Function //true

RegExp.__proto__ === Function.prototype  // true
RegExp.constructor == Function //true

Error.__proto__ === Function.prototype   // true
Error.constructor == Function //true

Date.__proto__ === Function.prototype    // true
Date.constructor == Function //true

```
JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。

剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建。

Math，JSON是以对象形式存在的，无需new。它们的proto是Object.prototype。如下


```
Math.__proto__ === Object.prototype  // true
Math.construrctor == Object // true

JSON.__proto__ === Object.prototype  // true
JSON.construrctor == Object //true

```

### 1.2 自定义的函数对象


```
// 函数声明
function Person() {}
// 函数表达式
var Perosn = function() {}
console.log(Person.__proto__ === Function.prototype) // true
console.log(Man.__proto__ === Function.prototype)    // true

```
**所有的构造器（函数对象）都来自于 Function.prototype，甚至包括根构造器Object及Function自身。所有构造器都继承了==Function.prototype==的属性及方法。如length、call、apply、bind**

### 1.3 原型对象类型

Function.prototype也是唯一一个typeof XXX.prototype为 function的prototype。


```
console.log(typeof Function.prototype) // function
console.log(typeof Object.prototype)   // object
console.log(typeof Number.prototype)   // object
console.log(typeof Boolean.prototype)  // object
console.log(typeof String.prototype)   // object
console.log(typeof Array.prototype)    // object
console.log(typeof RegExp.prototype)   // object
console.log(typeof Error.prototype)    // object
console.log(typeof Date.prototype)     // object
console.log(typeof Object.prototype)   // object

```

知道了所有构造器（含内置及自定义）的__proto__都是Function.prototype，那Function.prototype的__proto__是谁呢？

相信都听说过JavaScript中函数也是一等公民，那从哪能体现呢？如下

```
console.log(Function.prototype.__proto__ === Object.prototype) // true
```

这说明所有的构造器的原型对象也都是一个普通对象，可以给构造器添加/删除属性等。同时它也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等。

最后Object.prototype的proto是谁？

```
Object.prototype.__proto__ === null // true
```


## 2 prototype和_proto_

### 2.1 Object.prototype
> 在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 prototype 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们**所有实例方法的真正所**在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。
> 

我们知道 JS 内置了一些方法供我们使用，比如：
> - 对象可以用 constructor/toString()/valueOf() 等方法;
> - 数组可以用 map()/filter()/reducer() 等方法；
> - 数字可用用 parseInt()/parseFloat()等方法；

Why ？？？

当我们创建一个函数时：

```
var Person = new Object()
```

Person 是 Object 的实例，所以 Person 继承了Object 的原型对象Object.prototype上所有的方法：

```
Object.prototype
{
constructor: ƒ Object()
hasOwnProperty: ƒ hasOwnProperty()
isPrototypeOf: ƒ isPrototypeOf()
propertyIsEnumerable: ƒ propertyIsEnumerable()
toLocaleString: ƒ toLocaleString()
toString: ƒ toString()
valueOf: ƒ valueOf()
__defineGetter__: ƒ __defineGetter__()
__defineSetter__: ƒ __defineSetter__()
__lookupGetter__: ƒ __lookupGetter__()
__lookupSetter__: ƒ __lookupSetter__()
get __proto__: ƒ __proto__()
set __proto__: ƒ __proto__()
}

```
**Object 的每个实例都具有以上的属性和方法。**
所以我可以用
```
Person.constructor
```
 也可以用 
```
Person.hasOwnProperty
```

### 2.2 Array.prototype

当我们创建一个数组时：

```
var num = new Array()
```

num 是 Array 的实例，所以 num 继承了Array 的原型对象Array.prototype上所有的方法：


```
[
    concat: ƒ concat()
    constructor: ƒ Array()
    copyWithin: ƒ copyWithin()
    entries: ƒ entries()
    every: ƒ every()
    fill: ƒ fill()
    filter: ƒ filter()
    find: ƒ find()
    findIndex: ƒ findIndex()
    flat: ƒ flat()
    flatMap: ƒ flatMap()
    forEach: ƒ forEach()
    includes: ƒ includes()
    indexOf: ƒ indexOf()
    join: ƒ join()
    keys: ƒ keys()
    lastIndexOf: ƒ lastIndexOf()
    length: 0
    map: ƒ map()
    pop: ƒ pop()
    push: ƒ push()
    reduce: ƒ reduce()
    reduceRight: ƒ reduceRight()
    reverse: ƒ reverse()
    shift: ƒ shift()
    slice: ƒ slice()
    some: ƒ some()
    sort: ƒ sort()
    splice: ƒ splice()
    toLocaleString: ƒ toLocaleString()
    toString: ƒ toString()
    unshift: ƒ unshift()
    values: ƒ values()
    Symbol(Symbol.iterator): ƒ values()
    Symbol(Symbol.unscopables): {copyWithin: true, entries: true, fill: true, find: true, findIndex: true, …}
    __proto__: Object
]
```

```
num.hasOwnProperty // ƒ hasOwnProperty() { [native code] }
```
当你用num.hasOwnPrototype()时，JS 会先查一下它的构造函数 （Array） 的原型对象 Array.prototype 有没有有hasOwnPrototype()方法，没查到的话继续查一下 Array.prototype 的原型对象 Array.prototype.__proto__有没有这个方法。


### 2.3 原型对象赋值方式


```
所有对象的 __proto__ 都指向其构造器的 prototype

所有函数对象的 __proto__ 都指向 Function.prototype，它是一个空函数（Empty function）

```
先看看 JS 内置构造器：
```
var obj = {name: 'jack'}
var arr = [1,2,3]
var reg = /hello/g
var date = new Date
var err = new Error('exception')
 
console.log(obj.__proto__ === Object.prototype) // true
console.log(arr.__proto__ === Array.prototype)  // true
console.log(reg.__proto__ === RegExp.prototype) // true
console.log(date.__proto__ === Date.prototype)  // true
console.log(err.__proto__ === Error.prototype)  // true

```
再看看自定义的构造器，这里定义了一个 Person：


```
function Person(name) {
  this.name = name;
}
var p = new Person('jack')
console.log(p.__proto__ === Person.prototype) // true
```
每个对象都有一个 constructor 属性，可以获取它的构造器，因此以下打印结果也是恒等的：


```
function Person(name) {
    this.name = name
}
var p = new Person('jack')
console.log(p.__proto__ === p.constructor.prototype) // true

```
上面的Person没有给其原型添加属性或方法，这里给其原型添加一个getName方法：


```
function Person(name) {
    this.name = name
}
// 修改原型
Person.prototype.getName = function() {}
var p = new Person('jack')
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // true

console.log(p.constructor) // ƒ Person(name) { this.name = name}
```

可以看到p.__proto__与Person.prototype，p.constructor.prototype都是恒等的，即都指向同一个对象。

如果换一种方式设置原型，结果就有些不同了：


```
function Person(name) {
    this.name = name
}
// 重写原型
Person.prototype = {
    getName: function() {}
}
var p = new Person('jack')
console.log(p.__proto__ === Person.prototype) // true
console.log(p.__proto__ === p.constructor.prototype) // false

console.log(p.constructor) //ƒ Object() { [native code] }
```

这里直接重写了 Person.prototype（注意：上一个示例是修改原型）。输出结果可以看出p.__proto__仍然指向的是Person.prototype，而不是p.constructor.prototype。

这也很好理解，给Person.prototype赋值的是一个对象直接量{getName: function(){}}，使用对象直接量方式定义的对象其构造器（constructor）指向的是根构造器Object，Object.prototype是一个空对象{}，{}自然与{getName: function(){}}不等。如下：

上面的的最后一句暴露了

```
Person.prototype !== Object.prototype
```


```
var p = {}
console.log(Object.prototype) // 为一个空的对象{}
console.log(p.constructor === Object) // 对象直接量方式定义的对象其constructor为Object
console.log(p.constructor.prototype === Object.prototype) // 为true，不解释(๑ˇ3ˇ๑)
```

## 4 继承

- 原型和原型链是JS实现继承的一种模型。
- 原型链的形成是真正是靠__proto__ 而非prototype

要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？

```
var animal = function(){};
 var dog = function(){};

 animal.price = 2000;
 dog.prototype = animal;
 var tidy = new dog();
 console.log(dog.price) //undefined
 console.log(tidy.price) // 2000
```

这里解释一下：

 
```
var dog = function(){};
 dog.prototype.price = 2000;
 var tidy = new dog();
 console.log(tidy.price); // 2000
 console.log(dog.price); //undefined
 var dog = function(){};
 var tidy = new dog();
 tidy.price = 2000;
 console.log(dog.price); //undefined
```

这个明白吧？想一想我们上面说过这句话：

> 实例（tidy）和 原型对象（dog.prototype）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（tidy）与构造函数的原型对象（dog.prototype）之间，而不是存在于实例（tidy）与构造函数（dog）之间。
> 

## 5 解惑
主要是Function和Object
疑点解惑：

- 
```
Object.__proto__ === Function.prototype // true
```
Object 是函数对象，是通过new Function()创建的，所以Object.__proto__指向Function.prototype。「所有函数对象的__proto__都指向Function.prototype」）


- 
```
Function.__proto__ === Function.prototype // true
```

Function 也是对象函数，也是通过new Function()创建，所以Function.__proto__指向Function.prototype。

自己是由自己创建的。


- 
```
Function.prototype.__proto__ === Object.prototype //true
```
JS一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向Object.prototype。Object.prototype.__proto__ === null，保证原型链能够正常结束。

