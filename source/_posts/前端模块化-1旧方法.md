---
title: 前端模块化-1旧方法
date: 2018-08-27 13:08:43
tags: 模块化
categories: 总结 工作

---

记得刚入门前端的时候，看到前端模块化，总是能看到cmd，amd，RequireJS，commonJS等等，这些究竟是什么，这里就为你揭开他们的面纱。

<!-- more -->

## 1.摘要
    
在互联网应用越来越复杂，不可避免的需要工具来管理我们的前端代码。以前是一个巨大的脚本文件，如今希望可以将文件写入不同的文件模块，并且希望代码可以重用，可以简单地引用和添加各种各样的依赖到我们的项目。
    
## 2.前提

  如果按照以往的以页面为单位的开发，会导致很多问题，类似依赖管理、命名冲突等等问题。

**命名冲突是最常见的问题，描述如下**：

  //在util.js中

```javascript
   
   function log(message){
   }
   
```

   //在logger.js中

```javascript

  function log(message){
   }

```

因此**如果在页面的script标签同时依赖这两个文件**的时候就会产生冲突，导致后面的函数会被覆盖。从而可能产生一些预料之外的结果。


**传统的解决方案是使用命名空间：**

   //在util.js中

```
   function util.log(message){
   }
```

   //在logger.js中

```
  function logger.log(message){
   }
```

这样带来的显而易见的问题是：**所有的代码会变得冗余并且编写困难**


## 3. 解决（从旧到新）

> 思路：
>
>在Java中有一个重要的概念——package，逻辑上相关的代码组织到同一个包内，包内是一个相对独立的王国，不用担心命名冲突什么的。
>
>**那么外部如果使用呢？直接import对应的package即可。**
>
>import java.util.ArrayList;

遗憾的是JavaScript在设计时定位原因，没有提供类似的功能，**javascript，甚至没有类的概念，更不用说模块(module)了**。

**前端开发人员需要模拟出类似的功能，来隔离、组织复杂的JavaScript代码，我们称为模块化。**

> 一个模块就是实现特定功能的文件，**有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块**。模块开发需要遵循一定的规范，各行其是就都乱套了


### 3.1 函数封装
函数一个功能就是实现特定逻辑的一组语句打包，在一个文件里面编写几个相关函数就是最开始的模块了

> 缺点：就如1所讲，污染了全局变量，无法保证不与其他模块发生变量名冲突，而且模块成员之间没什么关系。


### 3.2 对象
为了解决上面问题，对象的写法应运而生，可以把所有的模块成员封装在一个对象中
```javascirpt
var myModule = {
    var1: 1,

    var2: 2,

    fn1: function(){

    },

    fn2: function(){

    }
}
```

这样我们在希望调用模块的时候引用对应文件，然后


```
myModule.fn2();
```

这样避免了变量污染，只要保证模块名唯一即可，同时同一模块内的成员也有了关系

> 缺点：看似不错的解决方案，但是也有缺陷，外部可以随意修改内部成员

```
myModel.var1 = 100;
```

这样就会产生意外的安全问题

### 3.3 立即执行函数

可以通过立即执行函数，来达到隐藏细节的目的


```
var myModule = (function(){
    var var1 = 1;
    var var2 = 2;

    function fn1(){

    }

    function fn2(){

    }

    return {
        fn1: fn1,
        fn2: fn2
    };
})();
```

**这样在模块外部无法修改我们没有暴露出来的变量、函数。**

上述做法就是我们模块化的基础，目前，通行的JavaScript模块规范主要有两种：CommonJS和AMD和CMD

首先最先登场的是CommonJs，CommonJS规范是由NodeJS发扬光大，适用于服务器端。
